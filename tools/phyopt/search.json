[{"path":"./articles/example.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using the Phy Algorithm","text":"article, introduce use optimize_phy() function. ’ll work two examples, one trivial, one much. Consider also seeing vignette(\"theoretical_framework\", package = \"phyopt\") article theoretical background algorithm. problem interest : \\[ \\begin{array}{lr}     \\min_{x, \\tilde{x}} x^2 + \\tilde{x}^2 ~~s.t.~~ \\tilde{x} - 2 \\geq 0,\\\\     X = \\tilde{X} = [-10, 10] \\end{array} \\] First, let’s load package: ’ll also set objects , explain later.","code":"#> Loading required package: purrr #> Loading required package: rlang #> #> Attaching package: 'rlang' #> The following objects are masked from 'package:purrr': #> #>     %@%, flatten, flatten_chr, flatten_dbl, flatten_int, flatten_lgl, #>     flatten_raw, invoke, splice stopper <- flow_stopper(list(max_iter = t ~ .m >= 20)) logger <- flow_logger()"},{"path":"./articles/example.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Using the Phy Algorithm","text":"problem interest : \\[ \\begin{array}{lr}     \\min_{x, \\tilde{x}} x^2 + \\tilde{x}^2 ~~s.t.~~ \\tilde{x} - 2 \\geq 0,\\\\     X = \\tilde{X} = [-10, 10] \\end{array} \\] First, let’s load package: ’ll also set objects , explain later.","code":"#> Loading required package: purrr #> Loading required package: rlang #> #> Attaching package: 'rlang' #> The following objects are masked from 'package:purrr': #> #>     %@%, flatten, flatten_chr, flatten_dbl, flatten_int, flatten_lgl, #>     flatten_raw, invoke, splice stopper <- flow_stopper(list(max_iter = t ~ .m >= 20)) logger <- flow_logger()"},{"path":"./articles/example.html","id":"solving-the-example","dir":"Articles","previous_headings":"","what":"Solving The Example","title":"Using the Phy Algorithm","text":"First, let’s define mathematical objects problem: format x_dom? different. end, whichever format useful way ’ll define operators. Let’s get ; problem, ’ll choose random (uniform) sampler initialization, golden search optimization, genetic algorithm’s approach crossover+mutation updater. ’ve different choice, user can even mix match choices. number samples \\(N\\) fixed \\(10\\), ’ll set start. , consider example random sampler, resamples draw fails constraint: Note arguments must exactly (names). result required \\(N \\times \\tilde{m}\\) matrix: Now, let’s golden search optimizer. See Wikipedia page learn . , argument names required. denote optimizer run every sample \\(xtil_s\\) current population \\(S_t\\). functions f_s g_s receive values : Note required data frame format. Also note (.) used create matrix column. know data frames can matrices columns? See section [Advanced R (2e)](https://adv-r.hadley.nz/vectors-chap.html?q=(#matrix--data-frame-columns) information. neat trick enables elegant use flow_* formulas evaluation. Also note one create optimizer randomly chooses list optimizers, use different ones time, sensitivity reasons. Let’s join . simple terms, algorithm initializes : , enters loop (emulated t <- 1 first iteration), creates xtil_t (\\(S_t\\)) variable. , sample \\(s\\) loop via map (, see Advanced R), save 1-row data frames list. list ‘rbinded’ via list_rbind. See turns : Note matrices columns. case hard differentiate 1-column matrices, accommodate dimension \\(m\\) \\(\\tilde{m}\\). See full results : Now let’s move forward define genetic algorithm approach update sample. sort \\(S_t\\) based lowest values \\(f\\) decreasing = FALSE, looking minimum. , select pairs values, greater probability lower values. used create “child”, “mutated” random multiplicative noise. Finally, constraint checked triggers resampling needed. , fixed argument names matrix result. See output : ingredients combined optimize_phy() function, also tests : functions correct arguments. domains correct length. operators correct arguments generate results correct format. Catches errors operators calls help debug code. Calculates metrics check performance, log console, stop algorithm reaches desired value. Let’s talk flow_stopper flow_logger. See full help page details, flow_stopper receives list : element formula, expression LHS can access results point, .e.: current iteration t time. sequences f (\\(t \\times 1\\) vector) iterations. sequence x (\\(t \\times m\\) matrix) xtil (\\(t \\times \\tilde{m}\\) matrix). sequence meta-information , whichever format made . , user can define metric want. expression evaluated current context algorithm, via non-standard evaluation (, Advanced R, yes, favorite R book, know?), using columns \\(results_t\\) variables (hence beauty matrix-columns). , RHS expression takes value metric .m returns single boolean. Finally, check_expr expression gets vector booleans (.ms) combines logical expression single boolean, TRUE algorithm stopped. allows stopping algorithm group metrics true. flow_logger similar, can also access metrics calculated variables (hence names list ), RHS function formats .m single string. Let’s set . stopping criterion reaching 20 iterations. objects comprised elements used algorithm: Let’s run everything! can get duration, stopping criterias met, \\(R_t\\) \\(M_t\\), including best (last): can see got close global minimum \\((0, 2)\\). efficacy due number iters user code.","code":"f <- \\(x, xtil) x^2 + xtil^2 g <- \\(x, xtil) 0 gtil <- \\(xtil) xtil - 2  x_dom <- xtil_dom <- list(c(-10, 10)) n_samples <- 10  initializer <- function(xtil_dom, gtil) {   xtil <- rep(NA, n_samples)    for (s in seq_len(n_samples)) {     draw <- NA     while (is.na(draw)) {       draw <- runif(1, xtil_dom[[1]][1], xtil_dom[[1]][2])       draw <- ifelse(gtil(draw) >= 0, yes = draw, no = NA)     }     xtil[s] <- draw   }    matrix(xtil, n_samples, 1) } initializer(xtil_dom, gtil) #>           [,1] #>  [1,] 4.946839 #>  [2,] 6.988739 #>  [3,] 7.947151 #>  [4,] 3.528791 #>  [5,] 9.153805 #>  [6,] 5.392818 #>  [7,] 5.403080 #>  [8,] 4.809501 #>  [9,] 7.725783 #> [10,] 8.332233 optimizer <- function(f_s, g_s, x_dom, t, xtil_s) {   phi <- 2 / (sqrt(5) + 1)    a <- x_dom[[1]][1];  b <- x_dom[[1]][2]   x1 <- b - phi * (b - a);  x2 <- a + phi * (b - a)   fx1 <- f_s(x1);  fx2 <- f_s(x2)    iter <- 0    while (abs(b - a) > 1e-5 && iter < 1000) {     if (fx1 < fx2) {       b <- x2       x2 <- x1; fx2 <- fx1       x1 <- b - phi * (b - a)       fx1 <- f_s(x1)     } else {       a <- x1       x1 <- x2; fx1 <- fx2       x2 <- a + phi * (b - a)       fx2 <- f_s(x2)     }     iter <- iter + 1   }    x <- (a + b) / 2   data.frame(x = I(matrix(x)), xtil = I(matrix(xtil_s)), f = f_s(x), i = NA) } xtil_s <- 5 f_s <- \\(x) f(x, xtil_s) g_s <- \\(x) g(x, xtil_s)  optimizer(f_s = f_s, g_s = g_s, x_dom = x_dom, t = 5, xtil_s = xtil_s) #>              x xtil  f  i #> 1 2.053031e-06    5 25 NA results <- vector(\"list\", length(stopper$iter_upper))  results[[1]]$xtil <- initializer(xtil_dom, gtil) t <- 1 xtil_t <- results[[t]]$xtil  results[[t]] <- list_rbind(map(seq_len(nrow(xtil_t)), function(s) {   xtil_s <- xtil_t[s, ]   f_s <- \\(x) f(x, xtil_s)   g_s <- \\(x) g(x, xtil_s)   optimizer(f_s = f_s, g_s = g_s, x_dom = x_dom, t = t, xtil_s = xtil_s) })) str(results[[t]]) #> 'data.frame':    10 obs. of  4 variables: #>  $ x   : 'AsIs' num [1:10, 1] 2.05e-06 2.05e-06 2.05e-06 2.05e-06 2.05e-06 ... #>  $ xtil: 'AsIs' num [1:10, 1] 5.92 7.98 7.05 7.63 2.07 ... #>  $ f   : num  35.03 63.75 49.7 58.27 4.29 ... #>  $ i   : logi  NA NA NA NA NA NA ... results[[t]] #>               x     xtil        f  i #> 1  2.053031e-06 5.918194 35.02502 NA #> 2  2.053031e-06 7.984414 63.75086 NA #> 3  2.053031e-06 7.049588 49.69669 NA #> 4  2.053031e-06 7.633369 58.26832 NA #> 5  2.053031e-06 2.072337  4.29458 NA #> 6  2.053031e-06 5.456612 29.77462 NA #> 7  2.053031e-06 8.896251 79.14328 NA #> 8  2.053031e-06 5.158775 26.61296 NA #> 9  2.053031e-06 4.977768 24.77818 NA #> 10 2.053031e-06 7.863985 61.84227 NA updater <- function(xtil_dom, gtil, r_t, t) {   xtil_ordered <- r_t$xtil[order(r_t$f, decreasing = FALSE), 1]   xtil_new <- matrix(NA, nrow = n_samples, ncol = 1)    probs <- 1 / (1:n_samples)   probs <- probs / sum(probs)    for (s in seq_len(n_samples)) {     draw <- NA     while (is.na(draw)) {       parents <- sample(n_samples, 2, prob = probs)       draw <- (xtil_ordered[parents[1]] + xtil_ordered[parents[2]]) / 2       draw <- draw * (1 + runif(1, -0.1, 0.1))       draw <- ifelse(gtil(draw) >= 0, draw, NA)     }     xtil_new[s, 1] <- draw   }    xtil_new } updater(xtil_dom = xtil_dom, gtil = gtil, r_t = results[[t]], t = t) #>           [,1] #>  [1,] 3.268790 #>  [2,] 3.757443 #>  [3,] 6.782937 #>  [4,] 4.758979 #>  [5,] 5.452600 #>  [6,] 3.722823 #>  [7,] 5.029615 #>  [8,] 6.165588 #>  [9,] 5.685368 #> [10,] 3.843856 list(   max_iter = t ~ .m >= 20,   max_time = time ~ .m >= 600,   f_prop = (max(f[[t]]) - max(f[[t - l]])) / abs(max(f[[t - 1]])) ~ .m < 0.01 ) stopper <- flow_stopper(list(max_iter = t ~ .m >= 20)) logger <- flow_logger() str(stopper) #> List of 3 #>  $ iter_upper   : num 10000 #>  $ get_metrics  :function (results, t, time)   #>  $ check_metrics:function (metrics_t, which = FALSE)   #>  - attr(*, \"class\")= chr \"flow_stopper\" str(logger) #> List of 1 #>  $ log:function (results_t, t, time, metrics_t)   #>  - attr(*, \"class\")= chr \"flow_logger\" optima <- optimize_phy(   f, g, gtil,   x_dom, xtil_dom,   initializer, optimizer, updater,   stopper, logger,   check_op = 0 ) #> → => Iter: 1 -- mean(f): 39.0876 #> → => Iter: 2 -- mean(f): 26.8055 #> → => Iter: 3 -- mean(f): 18.7927 #> → => Iter: 4 -- mean(f): 11.8601 #> → => Iter: 5 -- mean(f): 10.8815 #> → => Iter: 6 -- mean(f): 10.3102 #> → => Iter: 7 -- mean(f): 9.3541 #> → => Iter: 8 -- mean(f): 8.6874 #> → => Iter: 9 -- mean(f): 7.1481 #> → => Iter: 10 -- mean(f): 6.6392 #> → => Iter: 11 -- mean(f): 6.1745 #> → => Iter: 12 -- mean(f): 5.1327 #> → => Iter: 13 -- mean(f): 4.8341 #> → => Iter: 14 -- mean(f): 4.8978 #> → => Iter: 15 -- mean(f): 5.0524 #> → => Iter: 16 -- mean(f): 5.0036 #> → => Iter: 17 -- mean(f): 4.6448 #> → => Iter: 18 -- mean(f): 4.6291 #> → => Iter: 19 -- mean(f): 4.9121 #> → => Iter: 20 -- mean(f): 4.6338 #>  #> ✔ Finished after 20 iterations. Stopping criteria(s) were: #> • max_iter: t ~ .m >= 20 str(optima, 1) #> List of 4 #>  $ results     :List of 20 #>  $ metrics     :List of 20 #>  $ metrics_stop: Named chr \"max_iter: t ~ .m >= 20\" #>   ..- attr(*, \"names\")= chr \"max_iter\" #>  $ duration    :List of 4 optima$duration #> $iters #> [1] 20 #>  #> $time_init #> Time difference of 0.03287697 secs #>  #> $time_loop #> Time difference of 1.208624 secs #>  #> $time_total #> Time difference of 1.241504 secs optima$metrics_stop #>                 max_iter  #> \"max_iter: t ~ .m >= 20\" r_t <- optima$results[[20]] r_t[which.max(r_t$f), ] #>              x    xtil        f  i #> 5 2.053031e-06 2.31753 5.370947 NA"},{"path":"./articles/example.html","id":"initializer","dir":"Articles","previous_headings":"","what":"Initializer","title":"Using the Phy Algorithm","text":"number samples \\(N\\) fixed \\(10\\), ’ll set start. , consider example random sampler, resamples draw fails constraint: Note arguments must exactly (names). result required \\(N \\times \\tilde{m}\\) matrix:","code":"n_samples <- 10  initializer <- function(xtil_dom, gtil) {   xtil <- rep(NA, n_samples)    for (s in seq_len(n_samples)) {     draw <- NA     while (is.na(draw)) {       draw <- runif(1, xtil_dom[[1]][1], xtil_dom[[1]][2])       draw <- ifelse(gtil(draw) >= 0, yes = draw, no = NA)     }     xtil[s] <- draw   }    matrix(xtil, n_samples, 1) } initializer(xtil_dom, gtil) #>           [,1] #>  [1,] 4.946839 #>  [2,] 6.988739 #>  [3,] 7.947151 #>  [4,] 3.528791 #>  [5,] 9.153805 #>  [6,] 5.392818 #>  [7,] 5.403080 #>  [8,] 4.809501 #>  [9,] 7.725783 #> [10,] 8.332233"},{"path":"./articles/example.html","id":"optimizer","dir":"Articles","previous_headings":"","what":"Optimizer","title":"Using the Phy Algorithm","text":"Now, let’s golden search optimizer. See Wikipedia page learn . , argument names required. denote optimizer run every sample \\(xtil_s\\) current population \\(S_t\\). functions f_s g_s receive values : Note required data frame format. Also note (.) used create matrix column. know data frames can matrices columns? See section [Advanced R (2e)](https://adv-r.hadley.nz/vectors-chap.html?q=(#matrix--data-frame-columns) information. neat trick enables elegant use flow_* formulas evaluation. Also note one create optimizer randomly chooses list optimizers, use different ones time, sensitivity reasons.","code":"optimizer <- function(f_s, g_s, x_dom, t, xtil_s) {   phi <- 2 / (sqrt(5) + 1)    a <- x_dom[[1]][1];  b <- x_dom[[1]][2]   x1 <- b - phi * (b - a);  x2 <- a + phi * (b - a)   fx1 <- f_s(x1);  fx2 <- f_s(x2)    iter <- 0    while (abs(b - a) > 1e-5 && iter < 1000) {     if (fx1 < fx2) {       b <- x2       x2 <- x1; fx2 <- fx1       x1 <- b - phi * (b - a)       fx1 <- f_s(x1)     } else {       a <- x1       x1 <- x2; fx1 <- fx2       x2 <- a + phi * (b - a)       fx2 <- f_s(x2)     }     iter <- iter + 1   }    x <- (a + b) / 2   data.frame(x = I(matrix(x)), xtil = I(matrix(xtil_s)), f = f_s(x), i = NA) } xtil_s <- 5 f_s <- \\(x) f(x, xtil_s) g_s <- \\(x) g(x, xtil_s)  optimizer(f_s = f_s, g_s = g_s, x_dom = x_dom, t = 5, xtil_s = xtil_s) #>              x xtil  f  i #> 1 2.053031e-06    5 25 NA"},{"path":"./articles/example.html","id":"joining-the-pieces","dir":"Articles","previous_headings":"","what":"Joining The Pieces","title":"Using the Phy Algorithm","text":"Let’s join . simple terms, algorithm initializes : , enters loop (emulated t <- 1 first iteration), creates xtil_t (\\(S_t\\)) variable. , sample \\(s\\) loop via map (, see Advanced R), save 1-row data frames list. list ‘rbinded’ via list_rbind. See turns : Note matrices columns. case hard differentiate 1-column matrices, accommodate dimension \\(m\\) \\(\\tilde{m}\\). See full results :","code":"results <- vector(\"list\", length(stopper$iter_upper))  results[[1]]$xtil <- initializer(xtil_dom, gtil) t <- 1 xtil_t <- results[[t]]$xtil  results[[t]] <- list_rbind(map(seq_len(nrow(xtil_t)), function(s) {   xtil_s <- xtil_t[s, ]   f_s <- \\(x) f(x, xtil_s)   g_s <- \\(x) g(x, xtil_s)   optimizer(f_s = f_s, g_s = g_s, x_dom = x_dom, t = t, xtil_s = xtil_s) })) str(results[[t]]) #> 'data.frame':    10 obs. of  4 variables: #>  $ x   : 'AsIs' num [1:10, 1] 2.05e-06 2.05e-06 2.05e-06 2.05e-06 2.05e-06 ... #>  $ xtil: 'AsIs' num [1:10, 1] 5.92 7.98 7.05 7.63 2.07 ... #>  $ f   : num  35.03 63.75 49.7 58.27 4.29 ... #>  $ i   : logi  NA NA NA NA NA NA ... results[[t]] #>               x     xtil        f  i #> 1  2.053031e-06 5.918194 35.02502 NA #> 2  2.053031e-06 7.984414 63.75086 NA #> 3  2.053031e-06 7.049588 49.69669 NA #> 4  2.053031e-06 7.633369 58.26832 NA #> 5  2.053031e-06 2.072337  4.29458 NA #> 6  2.053031e-06 5.456612 29.77462 NA #> 7  2.053031e-06 8.896251 79.14328 NA #> 8  2.053031e-06 5.158775 26.61296 NA #> 9  2.053031e-06 4.977768 24.77818 NA #> 10 2.053031e-06 7.863985 61.84227 NA"},{"path":"./articles/example.html","id":"updater","dir":"Articles","previous_headings":"","what":"Updater","title":"Using the Phy Algorithm","text":"Now let’s move forward define genetic algorithm approach update sample. sort \\(S_t\\) based lowest values \\(f\\) decreasing = FALSE, looking minimum. , select pairs values, greater probability lower values. used create “child”, “mutated” random multiplicative noise. Finally, constraint checked triggers resampling needed. , fixed argument names matrix result. See output :","code":"updater <- function(xtil_dom, gtil, r_t, t) {   xtil_ordered <- r_t$xtil[order(r_t$f, decreasing = FALSE), 1]   xtil_new <- matrix(NA, nrow = n_samples, ncol = 1)    probs <- 1 / (1:n_samples)   probs <- probs / sum(probs)    for (s in seq_len(n_samples)) {     draw <- NA     while (is.na(draw)) {       parents <- sample(n_samples, 2, prob = probs)       draw <- (xtil_ordered[parents[1]] + xtil_ordered[parents[2]]) / 2       draw <- draw * (1 + runif(1, -0.1, 0.1))       draw <- ifelse(gtil(draw) >= 0, draw, NA)     }     xtil_new[s, 1] <- draw   }    xtil_new } updater(xtil_dom = xtil_dom, gtil = gtil, r_t = results[[t]], t = t) #>           [,1] #>  [1,] 3.268790 #>  [2,] 3.757443 #>  [3,] 6.782937 #>  [4,] 4.758979 #>  [5,] 5.452600 #>  [6,] 3.722823 #>  [7,] 5.029615 #>  [8,] 6.165588 #>  [9,] 5.685368 #> [10,] 3.843856"},{"path":"./articles/example.html","id":"the-optimize_phy-aggregation","dir":"Articles","previous_headings":"","what":"The optimize_phy() Aggregation","title":"Using the Phy Algorithm","text":"ingredients combined optimize_phy() function, also tests : functions correct arguments. domains correct length. operators correct arguments generate results correct format. Catches errors operators calls help debug code. Calculates metrics check performance, log console, stop algorithm reaches desired value.","code":""},{"path":"./articles/example.html","id":"metrics","dir":"Articles","previous_headings":"","what":"Metrics","title":"Using the Phy Algorithm","text":"Let’s talk flow_stopper flow_logger. See full help page details, flow_stopper receives list : element formula, expression LHS can access results point, .e.: current iteration t time. sequences f (\\(t \\times 1\\) vector) iterations. sequence x (\\(t \\times m\\) matrix) xtil (\\(t \\times \\tilde{m}\\) matrix). sequence meta-information , whichever format made . , user can define metric want. expression evaluated current context algorithm, via non-standard evaluation (, Advanced R, yes, favorite R book, know?), using columns \\(results_t\\) variables (hence beauty matrix-columns). , RHS expression takes value metric .m returns single boolean. Finally, check_expr expression gets vector booleans (.ms) combines logical expression single boolean, TRUE algorithm stopped. allows stopping algorithm group metrics true. flow_logger similar, can also access metrics calculated variables (hence names list ), RHS function formats .m single string. Let’s set . stopping criterion reaching 20 iterations. objects comprised elements used algorithm:","code":"list(   max_iter = t ~ .m >= 20,   max_time = time ~ .m >= 600,   f_prop = (max(f[[t]]) - max(f[[t - l]])) / abs(max(f[[t - 1]])) ~ .m < 0.01 ) stopper <- flow_stopper(list(max_iter = t ~ .m >= 20)) logger <- flow_logger() str(stopper) #> List of 3 #>  $ iter_upper   : num 10000 #>  $ get_metrics  :function (results, t, time)   #>  $ check_metrics:function (metrics_t, which = FALSE)   #>  - attr(*, \"class\")= chr \"flow_stopper\" str(logger) #> List of 1 #>  $ log:function (results_t, t, time, metrics_t)   #>  - attr(*, \"class\")= chr \"flow_logger\""},{"path":"./articles/example.html","id":"the-full-algorithm","dir":"Articles","previous_headings":"","what":"The Full Algorithm","title":"Using the Phy Algorithm","text":"Let’s run everything! can get duration, stopping criterias met, \\(R_t\\) \\(M_t\\), including best (last): can see got close global minimum \\((0, 2)\\). efficacy due number iters user code.","code":"optima <- optimize_phy(   f, g, gtil,   x_dom, xtil_dom,   initializer, optimizer, updater,   stopper, logger,   check_op = 0 ) #> → => Iter: 1 -- mean(f): 39.0876 #> → => Iter: 2 -- mean(f): 26.8055 #> → => Iter: 3 -- mean(f): 18.7927 #> → => Iter: 4 -- mean(f): 11.8601 #> → => Iter: 5 -- mean(f): 10.8815 #> → => Iter: 6 -- mean(f): 10.3102 #> → => Iter: 7 -- mean(f): 9.3541 #> → => Iter: 8 -- mean(f): 8.6874 #> → => Iter: 9 -- mean(f): 7.1481 #> → => Iter: 10 -- mean(f): 6.6392 #> → => Iter: 11 -- mean(f): 6.1745 #> → => Iter: 12 -- mean(f): 5.1327 #> → => Iter: 13 -- mean(f): 4.8341 #> → => Iter: 14 -- mean(f): 4.8978 #> → => Iter: 15 -- mean(f): 5.0524 #> → => Iter: 16 -- mean(f): 5.0036 #> → => Iter: 17 -- mean(f): 4.6448 #> → => Iter: 18 -- mean(f): 4.6291 #> → => Iter: 19 -- mean(f): 4.9121 #> → => Iter: 20 -- mean(f): 4.6338 #>  #> ✔ Finished after 20 iterations. Stopping criteria(s) were: #> • max_iter: t ~ .m >= 20 str(optima, 1) #> List of 4 #>  $ results     :List of 20 #>  $ metrics     :List of 20 #>  $ metrics_stop: Named chr \"max_iter: t ~ .m >= 20\" #>   ..- attr(*, \"names\")= chr \"max_iter\" #>  $ duration    :List of 4 optima$duration #> $iters #> [1] 20 #>  #> $time_init #> Time difference of 0.03287697 secs #>  #> $time_loop #> Time difference of 1.208624 secs #>  #> $time_total #> Time difference of 1.241504 secs optima$metrics_stop #>                 max_iter  #> \"max_iter: t ~ .m >= 20\" r_t <- optima$results[[20]] r_t[which.max(r_t$f), ] #>              x    xtil        f  i #> 5 2.053031e-06 2.31753 5.370947 NA"},{"path":"./articles/theoretical_framework.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Theoretical Framework","text":"article, present motivation theoretical framework behind phyopt package. See also vignette(\"example\", package = \"phyopt\") article practical example implementation explanation algorithm. literature use hybrid optimization methods use two stages first deal complex aspects problem solve remaining simpler problem efficient methods. focus hybrid methods random first step, provide space custom operators, possibly based heuristics. flexibility important solve non-standard problems. ’ll start describing problems interest rewriting language section Section 2. general framing, ’ll describe method’s design section Section 3, essence coding implementation Section 4.","code":""},{"path":"./articles/theoretical_framework.html","id":"sec-theory","dir":"Articles","previous_headings":"","what":"Theoretical Framework","title":"Theoretical Framework","text":"’ll consider three types ‘bad behaviors’: non-real variable domains (integer, categorical, etc.); variables affect objective constraints functions complex (non-linear) way; endogenous structure – problems structure problem part optimization choice (e.g., objective function domain can chosen). Also consider variables separable characteristics: imply clear global optimum others don’t – \\((x + \\sin(2y))\\); convex others aren’t – \\((x^2 + \\text{floor}(x)^2)\\); ‘difficult’ constraints others don’t. use examples economics, context really matter; mathematical characteristics important. Consider central planner choosing lump-sum taxes \\(\\tau\\) maximize social welfare function. higher tax, higher government’s utility, smaller population’s \\(\\\\{1, 2, \\dots, N\\}\\). \\[ \\begin{array}{lr}     \\max_{\\tau} u(\\tau) = U_G(\\tau) + \\sum_{= 1}^N U_P^(\\tau), &     u: \\mathbb{R}^+ \\\\mathbb{R} \\end{array} \\] Let’s add difficulty steps. Considering discrete nature money, mixed-integer problem: \\[ \\begin{array}{lr}     \\max_{\\tau} u(\\tau) = U_G(\\tau) + \\sum_{= 1}^N U_P^(\\tau), &     u: [0.01, 0.02, \\dots] \\\\mathbb{R} \\end{array} \\] Suppose government can choose different taxes \\(\\tau_s\\) given person’s group \\(s_i \\\\{, B\\}\\). , problem now mixed categorical variable: \\[ \\begin{array}{lr}   \\max_{\\tau, s} u(\\tau, s) = U_G(\\tau, s) + \\sum_{= 1}^N U_P^(\\tau_i(s_i)), &   u: (\\mathbb{R}^+)^2 \\times \\{, B\\}^N \\\\mathbb{R}\\\\   \\tau_i(s_i) = \\{s_i = \\}\\tau_A + \\{s_i = B\\}\\tau_B & \\end{array} \\] central planner, choosing \\(\\tau\\), must commit interval \\([\\underline{\\tau}, \\underline{\\tau} + c]\\), \\(c \\\\mathbb{R}\\)? perhaps number groups can chosen, \\(s \\\\{, B\\}\\) \\(\\{, B, C\\}\\), …? \\[ \\begin{array}{lr}   \\max_{\\tau, S, \\mathcal{S}} u(\\tau, S) = U_G(\\tau, S) + \\sum_{= 1}^N U_P^(\\tau_i(S_i)), &   u: (\\mathbb{R}^+)^2 \\times \\mathcal{S}^N \\\\mathbb{R}\\\\   \\max_{\\tau, \\underline{\\tau}} u(\\tau), &   u: [\\underline{\\tau}, \\underline{\\tau} + c] \\\\mathbb{R} \\end{array} \\] Additionally, consider researcher’s problem: data \\(\\tau\\) \\(u(\\tau; \\theta)\\) want estimate parameter \\(\\theta\\) minimizing loss function \\(L(\\theta; y - u(\\tau; \\theta))\\). know scale abstract parameter \\(\\theta\\) must choose domain computational method. \\[ \\begin{array}{lr}   \\min_{\\theta, \\Theta} L(\\theta; y - u(\\tau; \\theta)), &   L: \\Theta \\\\mathbb{R} \\end{array} \\] formulation interesting, fundamentally different using general domain creating new constraint \\(x \\\\{\\underline{\\tau}, \\underline{\\tau} + c\\}\\). Similar manipulations done endogeneity structure set objective function options. Consider general problem optimizing real-value function, possibly non-real domain. ’ll show alterations can done transform generalist problem, aligned hybrid methods. \\[ \\begin{array}{lr}   \\max_{x, X} f(x) ~~s.t.~~ g(x) \\geq 0, &   f: X \\\\mathbb{R}^n,~ g: X \\\\mathbb{R}^m,~ X \\\\mathcal{X} \\end{array} \\] : domain endogenous options \\(\\mathcal{X}\\); \\(n, m \\\\mathbb{N}\\) dimensions result constraints, respectively; restrictions can irrelevant \\(g(x) = 0\\); dimensions \\(x\\) need used \\(f\\) \\(g\\). First, note can always separate, full \\(x\\), variables \\(\\tilde{x}\\) worked first step. constraints depend \\(\\tilde{x}\\), can separate \\(\\tilde{g}(\\tilde{x})\\). Additionally, can map domain options \\(\\mathcal{X}\\) set indexes \\(\\tilde{X}\\). , can rewrite problem choosing index: \\[ \\begin{array}{lr}   \\max_{x, \\tilde{x}} f(x) ~~s.t.~~ g(x) \\geq 0, &   f: X_{\\tilde{x}} \\\\mathbb{R}^n,~ g: X_{\\tilde{x}} \\\\mathbb{R}^{m},~ \\tilde{x} \\\\tilde{X} \\end{array} \\] Based equivalence , can change domain options \\(\\mathcal{X}\\) restriction options \\(H_{\\mathcal{X}}\\). , can trade domain choosing constraint \\(g_{m+1}\\): \\[ \\begin{array}{c}   x \\X ~~\\Leftrightarrow~~ h(x) \\geq 0,~ h: X = \\{x: h(x) \\geq 0\\}\\\\   H_{\\mathcal{X}} = \\{h_{\\tilde{x}}: X = \\{x: h_{\\tilde{x}}(x) \\geq 0\\},~ X \\\\mathcal{X}\\}\\\\   g_{m+1}(x, \\tilde{x}) = \\sum_{\\\\tilde{X}} \\{= \\tilde{x}\\}h_{\\tilde{x}}(x) \\end{array} \\] \\(\\mathcal{X}\\) uncountable, \\(\\tilde{X} \\subseteq \\mathbb{R}\\) use integral. manipulations, reframed problem becomes: \\[ \\begin{array}{lr}     \\max_{x, \\tilde{x}} f(x, \\tilde{x}) ~~s.t.~~ g(x, \\tilde{x}) \\geq 0,~ \\tilde{g}(\\tilde{x}) \\geq 0, &     f: X \\\\mathbb{R}^n,~ g: X \\times \\tilde{X} \\\\mathbb{R}^{m},~ \\tilde{g}: \\tilde{X} \\\\mathbb{R}^{\\tilde{m}} \\end{array} \\] \\(X \\subseteq \\mathbb{R}^k\\) open \\(g: X \\rightarrow \\mathbb{R}^m\\) differentiable, KKT conditions satisfied. Thus, ’ll describe method problems next section.","code":""},{"path":"./articles/theoretical_framework.html","id":"considered-problems-and-examples","dir":"Articles","previous_headings":"","what":"Considered Problems and Examples","title":"Theoretical Framework","text":"’ll consider three types ‘bad behaviors’: non-real variable domains (integer, categorical, etc.); variables affect objective constraints functions complex (non-linear) way; endogenous structure – problems structure problem part optimization choice (e.g., objective function domain can chosen). Also consider variables separable characteristics: imply clear global optimum others don’t – \\((x + \\sin(2y))\\); convex others aren’t – \\((x^2 + \\text{floor}(x)^2)\\); ‘difficult’ constraints others don’t. use examples economics, context really matter; mathematical characteristics important. Consider central planner choosing lump-sum taxes \\(\\tau\\) maximize social welfare function. higher tax, higher government’s utility, smaller population’s \\(\\\\{1, 2, \\dots, N\\}\\). \\[ \\begin{array}{lr}     \\max_{\\tau} u(\\tau) = U_G(\\tau) + \\sum_{= 1}^N U_P^(\\tau), &     u: \\mathbb{R}^+ \\\\mathbb{R} \\end{array} \\] Let’s add difficulty steps. Considering discrete nature money, mixed-integer problem: \\[ \\begin{array}{lr}     \\max_{\\tau} u(\\tau) = U_G(\\tau) + \\sum_{= 1}^N U_P^(\\tau), &     u: [0.01, 0.02, \\dots] \\\\mathbb{R} \\end{array} \\] Suppose government can choose different taxes \\(\\tau_s\\) given person’s group \\(s_i \\\\{, B\\}\\). , problem now mixed categorical variable: \\[ \\begin{array}{lr}   \\max_{\\tau, s} u(\\tau, s) = U_G(\\tau, s) + \\sum_{= 1}^N U_P^(\\tau_i(s_i)), &   u: (\\mathbb{R}^+)^2 \\times \\{, B\\}^N \\\\mathbb{R}\\\\   \\tau_i(s_i) = \\{s_i = \\}\\tau_A + \\{s_i = B\\}\\tau_B & \\end{array} \\] central planner, choosing \\(\\tau\\), must commit interval \\([\\underline{\\tau}, \\underline{\\tau} + c]\\), \\(c \\\\mathbb{R}\\)? perhaps number groups can chosen, \\(s \\\\{, B\\}\\) \\(\\{, B, C\\}\\), …? \\[ \\begin{array}{lr}   \\max_{\\tau, S, \\mathcal{S}} u(\\tau, S) = U_G(\\tau, S) + \\sum_{= 1}^N U_P^(\\tau_i(S_i)), &   u: (\\mathbb{R}^+)^2 \\times \\mathcal{S}^N \\\\mathbb{R}\\\\   \\max_{\\tau, \\underline{\\tau}} u(\\tau), &   u: [\\underline{\\tau}, \\underline{\\tau} + c] \\\\mathbb{R} \\end{array} \\] Additionally, consider researcher’s problem: data \\(\\tau\\) \\(u(\\tau; \\theta)\\) want estimate parameter \\(\\theta\\) minimizing loss function \\(L(\\theta; y - u(\\tau; \\theta))\\). know scale abstract parameter \\(\\theta\\) must choose domain computational method. \\[ \\begin{array}{lr}   \\min_{\\theta, \\Theta} L(\\theta; y - u(\\tau; \\theta)), &   L: \\Theta \\\\mathbb{R} \\end{array} \\] formulation interesting, fundamentally different using general domain creating new constraint \\(x \\\\{\\underline{\\tau}, \\underline{\\tau} + c\\}\\). Similar manipulations done endogeneity structure set objective function options.","code":""},{"path":"./articles/theoretical_framework.html","id":"different-natures-of-variables","dir":"Articles","previous_headings":"Theoretical Framework","what":"Different Natures of Variables","title":"Theoretical Framework","text":"Also consider variables separable characteristics: imply clear global optimum others don’t – \\((x + \\sin(2y))\\); convex others aren’t – \\((x^2 + \\text{floor}(x)^2)\\); ‘difficult’ constraints others don’t. use examples economics, context really matter; mathematical characteristics important.","code":""},{"path":"./articles/theoretical_framework.html","id":"non-real-valued-variables","dir":"Articles","previous_headings":"Theoretical Framework","what":"Non Real-Valued Variables","title":"Theoretical Framework","text":"Consider central planner choosing lump-sum taxes \\(\\tau\\) maximize social welfare function. higher tax, higher government’s utility, smaller population’s \\(\\\\{1, 2, \\dots, N\\}\\). \\[ \\begin{array}{lr}     \\max_{\\tau} u(\\tau) = U_G(\\tau) + \\sum_{= 1}^N U_P^(\\tau), &     u: \\mathbb{R}^+ \\\\mathbb{R} \\end{array} \\] Let’s add difficulty steps. Considering discrete nature money, mixed-integer problem: \\[ \\begin{array}{lr}     \\max_{\\tau} u(\\tau) = U_G(\\tau) + \\sum_{= 1}^N U_P^(\\tau), &     u: [0.01, 0.02, \\dots] \\\\mathbb{R} \\end{array} \\] Suppose government can choose different taxes \\(\\tau_s\\) given person’s group \\(s_i \\\\{, B\\}\\). , problem now mixed categorical variable: \\[ \\begin{array}{lr}   \\max_{\\tau, s} u(\\tau, s) = U_G(\\tau, s) + \\sum_{= 1}^N U_P^(\\tau_i(s_i)), &   u: (\\mathbb{R}^+)^2 \\times \\{, B\\}^N \\\\mathbb{R}\\\\   \\tau_i(s_i) = \\{s_i = \\}\\tau_A + \\{s_i = B\\}\\tau_B & \\end{array} \\]","code":""},{"path":"./articles/theoretical_framework.html","id":"endogenous-structure","dir":"Articles","previous_headings":"Theoretical Framework","what":"Endogenous Structure","title":"Theoretical Framework","text":"central planner, choosing \\(\\tau\\), must commit interval \\([\\underline{\\tau}, \\underline{\\tau} + c]\\), \\(c \\\\mathbb{R}\\)? perhaps number groups can chosen, \\(s \\\\{, B\\}\\) \\(\\{, B, C\\}\\), …? \\[ \\begin{array}{lr}   \\max_{\\tau, S, \\mathcal{S}} u(\\tau, S) = U_G(\\tau, S) + \\sum_{= 1}^N U_P^(\\tau_i(S_i)), &   u: (\\mathbb{R}^+)^2 \\times \\mathcal{S}^N \\\\mathbb{R}\\\\   \\max_{\\tau, \\underline{\\tau}} u(\\tau), &   u: [\\underline{\\tau}, \\underline{\\tau} + c] \\\\mathbb{R} \\end{array} \\] Additionally, consider researcher’s problem: data \\(\\tau\\) \\(u(\\tau; \\theta)\\) want estimate parameter \\(\\theta\\) minimizing loss function \\(L(\\theta; y - u(\\tau; \\theta))\\). know scale abstract parameter \\(\\theta\\) must choose domain computational method. \\[ \\begin{array}{lr}   \\min_{\\theta, \\Theta} L(\\theta; y - u(\\tau; \\theta)), &   L: \\Theta \\\\mathbb{R} \\end{array} \\] formulation interesting, fundamentally different using general domain creating new constraint \\(x \\\\{\\underline{\\tau}, \\underline{\\tau} + c\\}\\). Similar manipulations done endogeneity structure set objective function options.","code":""},{"path":"./articles/theoretical_framework.html","id":"reframing-the-problems","dir":"Articles","previous_headings":"","what":"Reframing the Problems","title":"Theoretical Framework","text":"Consider general problem optimizing real-value function, possibly non-real domain. ’ll show alterations can done transform generalist problem, aligned hybrid methods. \\[ \\begin{array}{lr}   \\max_{x, X} f(x) ~~s.t.~~ g(x) \\geq 0, &   f: X \\\\mathbb{R}^n,~ g: X \\\\mathbb{R}^m,~ X \\\\mathcal{X} \\end{array} \\] : domain endogenous options \\(\\mathcal{X}\\); \\(n, m \\\\mathbb{N}\\) dimensions result constraints, respectively; restrictions can irrelevant \\(g(x) = 0\\); dimensions \\(x\\) need used \\(f\\) \\(g\\). First, note can always separate, full \\(x\\), variables \\(\\tilde{x}\\) worked first step. constraints depend \\(\\tilde{x}\\), can separate \\(\\tilde{g}(\\tilde{x})\\). Additionally, can map domain options \\(\\mathcal{X}\\) set indexes \\(\\tilde{X}\\). , can rewrite problem choosing index: \\[ \\begin{array}{lr}   \\max_{x, \\tilde{x}} f(x) ~~s.t.~~ g(x) \\geq 0, &   f: X_{\\tilde{x}} \\\\mathbb{R}^n,~ g: X_{\\tilde{x}} \\\\mathbb{R}^{m},~ \\tilde{x} \\\\tilde{X} \\end{array} \\] Based equivalence , can change domain options \\(\\mathcal{X}\\) restriction options \\(H_{\\mathcal{X}}\\). , can trade domain choosing constraint \\(g_{m+1}\\): \\[ \\begin{array}{c}   x \\X ~~\\Leftrightarrow~~ h(x) \\geq 0,~ h: X = \\{x: h(x) \\geq 0\\}\\\\   H_{\\mathcal{X}} = \\{h_{\\tilde{x}}: X = \\{x: h_{\\tilde{x}}(x) \\geq 0\\},~ X \\\\mathcal{X}\\}\\\\   g_{m+1}(x, \\tilde{x}) = \\sum_{\\\\tilde{X}} \\{= \\tilde{x}\\}h_{\\tilde{x}}(x) \\end{array} \\] \\(\\mathcal{X}\\) uncountable, \\(\\tilde{X} \\subseteq \\mathbb{R}\\) use integral. manipulations, reframed problem becomes: \\[ \\begin{array}{lr}     \\max_{x, \\tilde{x}} f(x, \\tilde{x}) ~~s.t.~~ g(x, \\tilde{x}) \\geq 0,~ \\tilde{g}(\\tilde{x}) \\geq 0, &     f: X \\\\mathbb{R}^n,~ g: X \\times \\tilde{X} \\\\mathbb{R}^{m},~ \\tilde{g}: \\tilde{X} \\\\mathbb{R}^{\\tilde{m}} \\end{array} \\] \\(X \\subseteq \\mathbb{R}^k\\) open \\(g: X \\rightarrow \\mathbb{R}^m\\) differentiable, KKT conditions satisfied. Thus, ’ll describe method problems next section.","code":""},{"path":"./articles/theoretical_framework.html","id":"sec-design","dir":"Articles","previous_headings":"","what":"Method Design","title":"Theoretical Framework","text":"First, define number \\(T \\\\mathbb{N}\\) iterations (denoted \\(t\\)) number \\(N \\\\mathbb{N}\\) samples (denoted \\(s\\)) population \\(S_t\\). Denote step \\(S_0 = \\text{init}(\\tilde{X}, \\tilde{g})\\). first step create initial population separated variables \\(\\tilde{x}\\), \\(S_0 = (\\tilde{x}_s)_{s = 1}^N\\). population must created respect constraints \\(\\tilde{g}\\). Denote step \\(S_0 = \\text{initialize}(\\tilde{X}, \\tilde{g})\\). several methods create initial sample. generally can divided : One can use uniform distribution, heuristic guess based knowledge problem, -la importance sampling. Examples grid sampling, Latin Hypercube sampling, Kronecker sampling, Sobol Halton sequences. Additionally, domain can split groups sampling done within group (stratified/cluster-based sampling). main goal guarantee algorithm able explore whole domain. Kazimipour et. al. (2014) provides comprehensive review initialization methods. , guarantee validity \\(\\tilde{g}\\) constraints, several methods: Using closest valid point, projection valid space, amongst others. Sampling dimension \\(\\tilde{x}_s\\) time, updating valid space rest time; choosing distribution \\(P\\) likely sample valid points; amongst others. Note \\(\\tilde{x}\\) contains encoded variables, Researcher’s Problem, heuristics used depend encoding done. Denote step \\(R_t = \\text{optimize}(X, g, t, S_t)\\). given sample \\(\\tilde{x}_s\\), left reduced problem, doesn’t depend \\(\\tilde{x}\\) \\(\\tilde{g}\\): \\[ \\begin{array}{lr}   \\max_{x} f_s(x;~ \\tilde{x}_s) ~~s.t.~~ g_s(x;~ \\tilde{x}_s) \\geq 0, &   f: X \\\\mathbb{R}^n,~ g: X \\\\mathbb{R}^m \\end{array} \\] One chooses solver liking problem. One can also choose several options, get randomly picked sample, helps generality solution. , \\(\\tilde{x}_s \\S_t\\), problem solved \\(x_s^*\\), ordered set results - optional meta-information \\(I_s\\) (e.g.: time completion) - stored: \\[ \\begin{array}{lr}   O_s = (\\tilde{x}_s,~ x^*_s,~ f(x^*_s, \\tilde{x}_s),~ I_s), &   R_t = (O_s)_{s = 1}^N \\end{array} \\] set metrics \\(M_t\\) calculated \\(R_t\\). stopping criteria can drawn combination options. top maximum time elapsed iterations, one can consider best/median/sample value \\((\\tilde{x}, x)\\) performance \\(f((\\tilde{x}, x))\\) (denote \\(o\\)), via: threshold \\(o \\gtrless k\\); convergence \\(|o_{t'} - o_t| < \\epsilon\\); stability \\(sd(o) < \\epsilon\\). Let \\(R = (R_t)_{t = 1}^T\\) \\(M = (M_t)_{t = 1}^T\\). last step update sample: \\(S_{t+1} = \\text{update}(\\tilde{X}, \\tilde{g}, t, S_t, R_t)\\). general objective create new population “direction” best performing samples \\(S_t\\). many literatures motivate \\(\\text{update}\\) operators, user-supplied coding implementation, setup can encompass many options. present explanation, ’ll focus operators easily applied numeric problems economics, mainly related Evolutionary Algorithms literature. Consider option combining random tuples samples (“crossover”), adding randomization, avoid local optima (“mutation”). simplistic terms, ‘child’ sample created : Position crossover: taking positions/dimensions ‘parents’, randomly. Arithmetic crossover: combining parents’ values, averages else. Distributional crossover: sampling distribution based parents’ values. Resample mutation: randomly choosing dimension resample distribution. Noise mutation: randomly choosing dimension add noise. amount crossover mutation, amongst others, can hyperparameters, can even depend iteration \\(t\\). , remotely exhaustive list. crossover mutation can found Kora Yadlapalli (2017), De Falco et. al. (2002), many random optimization literatures can considered. Note operators need account possibly non-real non-numeric variables, also constraints \\(\\tilde{g}\\). flexibility able define operator major advantage method.","code":""},{"path":"./articles/theoretical_framework.html","id":"first-step-create-initial-sample-of-tildex","dir":"Articles","previous_headings":"","what":"First Step: Create Initial Sample of \\(\\tilde{x}\\)","title":"Theoretical Framework","text":"first step create initial population separated variables \\(\\tilde{x}\\), \\(S_0 = (\\tilde{x}_s)_{s = 1}^N\\). population must created respect constraints \\(\\tilde{g}\\). Denote step \\(S_0 = \\text{initialize}(\\tilde{X}, \\tilde{g})\\). several methods create initial sample. generally can divided : One can use uniform distribution, heuristic guess based knowledge problem, -la importance sampling. Examples grid sampling, Latin Hypercube sampling, Kronecker sampling, Sobol Halton sequences. Additionally, domain can split groups sampling done within group (stratified/cluster-based sampling). main goal guarantee algorithm able explore whole domain. Kazimipour et. al. (2014) provides comprehensive review initialization methods. , guarantee validity \\(\\tilde{g}\\) constraints, several methods: Using closest valid point, projection valid space, amongst others. Sampling dimension \\(\\tilde{x}_s\\) time, updating valid space rest time; choosing distribution \\(P\\) likely sample valid points; amongst others. Note \\(\\tilde{x}\\) contains encoded variables, Researcher’s Problem, heuristics used depend encoding done.","code":""},{"path":"./articles/theoretical_framework.html","id":"second-step-solve-the-reduced-problem","dir":"Articles","previous_headings":"","what":"Second Step: Solve the Reduced Problem","title":"Theoretical Framework","text":"Denote step \\(R_t = \\text{optimize}(X, g, t, S_t)\\). given sample \\(\\tilde{x}_s\\), left reduced problem, doesn’t depend \\(\\tilde{x}\\) \\(\\tilde{g}\\): \\[ \\begin{array}{lr}   \\max_{x} f_s(x;~ \\tilde{x}_s) ~~s.t.~~ g_s(x;~ \\tilde{x}_s) \\geq 0, &   f: X \\\\mathbb{R}^n,~ g: X \\\\mathbb{R}^m \\end{array} \\] One chooses solver liking problem. One can also choose several options, get randomly picked sample, helps generality solution. , \\(\\tilde{x}_s \\S_t\\), problem solved \\(x_s^*\\), ordered set results - optional meta-information \\(I_s\\) (e.g.: time completion) - stored: \\[ \\begin{array}{lr}   O_s = (\\tilde{x}_s,~ x^*_s,~ f(x^*_s, \\tilde{x}_s),~ I_s), &   R_t = (O_s)_{s = 1}^N \\end{array} \\] set metrics \\(M_t\\) calculated \\(R_t\\). stopping criteria can drawn combination options. top maximum time elapsed iterations, one can consider best/median/sample value \\((\\tilde{x}, x)\\) performance \\(f((\\tilde{x}, x))\\) (denote \\(o\\)), via: threshold \\(o \\gtrless k\\); convergence \\(|o_{t'} - o_t| < \\epsilon\\); stability \\(sd(o) < \\epsilon\\). Let \\(R = (R_t)_{t = 1}^T\\) \\(M = (M_t)_{t = 1}^T\\).","code":""},{"path":"./articles/theoretical_framework.html","id":"third-step-update-the-sample","dir":"Articles","previous_headings":"","what":"Third Step: Update the Sample","title":"Theoretical Framework","text":"last step update sample: \\(S_{t+1} = \\text{update}(\\tilde{X}, \\tilde{g}, t, S_t, R_t)\\). general objective create new population “direction” best performing samples \\(S_t\\). many literatures motivate \\(\\text{update}\\) operators, user-supplied coding implementation, setup can encompass many options. present explanation, ’ll focus operators easily applied numeric problems economics, mainly related Evolutionary Algorithms literature. Consider option combining random tuples samples (“crossover”), adding randomization, avoid local optima (“mutation”). simplistic terms, ‘child’ sample created : Position crossover: taking positions/dimensions ‘parents’, randomly. Arithmetic crossover: combining parents’ values, averages else. Distributional crossover: sampling distribution based parents’ values. Resample mutation: randomly choosing dimension resample distribution. Noise mutation: randomly choosing dimension add noise. amount crossover mutation, amongst others, can hyperparameters, can even depend iteration \\(t\\). , remotely exhaustive list. crossover mutation can found Kora Yadlapalli (2017), De Falco et. al. (2002), many random optimization literatures can considered. Note operators need account possibly non-real non-numeric variables, also constraints \\(\\tilde{g}\\). flexibility able define operator major advantage method.","code":""},{"path":"./articles/theoretical_framework.html","id":"sec-implementation","dir":"Articles","previous_headings":"","what":"Coding Implementation","title":"Theoretical Framework","text":"unfeasible explain details implementation , explained package’s documentation. main function optimize_phy(). , others, documentation pages math notation , similar argument names (e.g.: xtil \\(\\tilde{x}\\) x_dom \\(X\\)). function receives main arguments: functions f, g, gtil, must receive correct arguments x /xtil. domains x_dom, xtil_dom, lists length \\(m\\) \\(\\tilde{m}\\). used user-supplied operators elements can whatever user needs. operators initializer, optimizer, updater, must receive arguments described previous section, return output specific format. helper stopper, calculates metrics performance iteration, sets stopping criteria; logger, logs performance console user feedback. created helper functions flow_stopper() flow_logger(). algorithm presented . user-provided function calls wrapped try_op function catch report errors user-friendly way. notation x\\$y indicates object \\(y\\) within object \\(x\\).  important read “Using Phy Algorithm” vignette vignette(\"example\", package = \"phyopt\"), thoroughly explains package logic usage. core, package wraps operators two-step hybrid procedure. user responsible making smart choices operators, package guarantees () thorough tests error handling help debugging, (ii) flexible, generalist, agnostic setup restrict user. tricks allow () size \\(m\\) \\(\\tilde{m}\\); (ii) kind operator; (iii) kind metric \\(M_t\\) stopping criteria especially important.","code":""},{"path":"./authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ricardo Semião. Author, maintainer.","code":""},{"path":"./authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Semião R (2025). phyopt: General-Use Population-Based Hybrid-Optimization. R package version 0.0.0.9000, https://https://github.com/ricardo-semiao/phyopt.","code":"@Manual{,   title = {phyopt: General-Use Population-Based Hybrid-Optimization},   author = {Ricardo Semião},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://https://github.com/ricardo-semiao/phyopt}, }"},{"path":"./index.html","id":null,"dir":"","previous_headings":"","what":"General-Use Population-Based Hybrid-Optimization","title":"General-Use Population-Based Hybrid-Optimization","text":"package implements two-step, population-based, hybrid optimization algorithm, solving problems form: \\[ \\begin{array}{c}   \\max_{x, \\tilde{x}} f(x, \\tilde{x}) ~~s.t.~~ g(x, \\tilde{x}) \\geq 0,~ \\tilde{g}(\\tilde{x}) \\geq 0,\\\\   x \\X,~ \\tilde{x} \\\\tilde{X} \\end{array} \\] paper fully describing motivation, theoretical framework, method design available vignette(\"theoretical_framework\", package = \"phyopt\"). goal package provide flexible framework users implement optimization strategies, combining different types initializers, optimizers, updaters. now, see vignette vignette(\"example\", package = \"phyopt\"), contains simple example thorough explanation package works. Additionally, see documentation optimize_phy() function, main function package. Disclaimer: package early stage development. hasn’t thoroughly tested may contain several bugs. don’t recommend using large-scale projects yet. Please report problems GitHub issue. comments can posted GitHub discussion, sent email . Thank ! Author: Ricardo Semião e Castro (ricardo.semiao@outlook).","code":""},{"path":"./index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"General-Use Population-Based Hybrid-Optimization","text":"can install development version phyopt like :","code":"# install.packages(\"devtools\") devtools::install_github(\"ricardo-semiao/phyopt\")"},{"path":"./index.html","id":"development-comments","dir":"","previous_headings":"","what":"Development Comments","title":"General-Use Population-Based Hybrid-Optimization","text":"package young places much optimization responsibility user. said, believe reasonably solid. implement tests run examples, expect stable. important features plan add future : testthat package structure created package, haven’t time write unit tests yet. Add complicated examples vignette(\"example\", package = \"phyopt\"). Expand suggested metrics get_metrics, also add suggestions formatters logger object. Add suggested operators optimize_phy(), common initializers, optimizers, updaters literature. Add .exit() call optimize_pbhy(), safely returns reaching eventual error. Create summary() plot() methods optimize_pbhy() result. Note package: Using styler lintr packages style consistency. Uses testthat 3 automate tests. Uses rlang frameworks tidy eval rlang errors.","code":""},{"path":"./LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 phyopt authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"./reference/flow_logger.html","id":null,"dir":"Reference","previous_headings":"","what":"Flow Logger Constructor — flow_logger","title":"Flow Logger Constructor — flow_logger","text":"function creates flow logger object calculates metrics logs console. metrics definition done similarly flow_stopper() function (see help page), formulas divided lists, list printed different line.","code":""},{"path":"./reference/flow_logger.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flow Logger Constructor — flow_logger","text":"","code":"flow_logger(   formulas_list = list(list(t ~ paste(\"=> Iter:\", .m), mean(f) ~ paste(\"mean(f):\",     round(.m, 4)))),   log_each = 1,   sep = \" -- \",   args_alert = list(),   args_ul = list() )"},{"path":"./reference/flow_logger.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flow Logger Constructor — flow_logger","text":"formulas_list list formulas flow_stopper() (list lists), except RHS function takes LHS value .m returns single string printed. log_each integer specifying frequency logging. sep character string used concatenate logs associated list inside formulas_list. args_alert, args_ul list arguments passed cli::cli_alert() cli::cli_ul(), functions format console output.","code":""},{"path":"./reference/flow_logger.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flow Logger Constructor — flow_logger","text":"\"flow_logger\"-class object passed optimize_phy().","code":""},{"path":"./reference/flow_logger.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Flow Logger Constructor — flow_logger","text":"LHS formulas evaluated way flow_stopper() (see help page), user access current results (\\(R_t\\)). Additionally, metric current iteration (\\(M_t\\)) can accessed name (formulas named).","code":""},{"path":"./reference/flow_stopper.html","id":null,"dir":"Reference","previous_headings":"","what":"Flow Stopper Constructor — flow_stopper","title":"Flow Stopper Constructor — flow_stopper","text":"function creates flow stopper object calculate metrics, iteration, based current results algorithm, checks algorithm stop based metrics. Given objects \\(R\\) (list results every iteration), user can define set metrics \\(M_t\\), calculated every iteration \\(t\\). Based metric\\(m\\), stopping criterion can defined via expression \\(m\\) returns boolean. Finally, list booleans given iteration \\(t\\) can combined logic expression determine algorithm stop.","code":""},{"path":"./reference/flow_stopper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flow Stopper Constructor — flow_stopper","text":"","code":"flow_stopper(   formulas = list(get_metric$iter(100), get_metric$f_prop(0.01)),   check_expr = ~any(.ms, na.rm = TRUE),   iter_upper = 10000 )"},{"path":"./reference/flow_stopper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flow Stopper Constructor — flow_stopper","text":"formulas list formulas specifying metrics \\(m\\) calculated LHS (see details), stopping criterion depending metric value .m, RHS. check_expr RHS-formula logic operation, depending vector booleans .ms. iter_upper technical argument used initialize containers \\(R\\) \\(M\\). stopping criterion based \\(t\\) defined formulas argument.","code":""},{"path":"./reference/flow_stopper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flow Stopper Constructor — flow_stopper","text":"\"flow_stopper\"-class object passed optimize_phy().","code":""},{"path":"./reference/flow_stopper.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Flow Stopper Constructor — flow_stopper","text":"LHS evaluated context algorithm, .e., can depend variables t (current iteration), time (current time seconds), list element \\(R\\) (length t). example, f[[t - 1]] evaluate vector objective function values samples previous iteration. Note can set unfeasible stopping criteria, FALSE get value metric end algorithm.","code":""},{"path":"./reference/get_metric.html","id":null,"dir":"Reference","previous_headings":"","what":"Get common metrics' formulas — get_metric","title":"Get common metrics' formulas — get_metric","text":"Get common metrics' formulas","code":""},{"path":"./reference/get_metric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get common metrics' formulas — get_metric","text":"","code":"get_metric"},{"path":"./reference/get_metric.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Get common metrics' formulas — get_metric","text":"object class list length 2.","code":""},{"path":"./reference/optimize_phy.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimize a function with the PB-Hybrid algorithm — optimize_phy","title":"Optimize a function with the PB-Hybrid algorithm — optimize_phy","text":"function implements two-step, population-based, hybrid optimization algorithm, solving problems form: \\[ \\begin{array}{c} \\max_{x, \\tilde{x}} f(x, \\tilde{x}) ~~s.t.~~ g(x, \\tilde{x}) \\geq 0, ~ \\tilde{g}(\\tilde{x}) \\geq 0,\\ x \\X,~ \\tilde{x} \\\\tilde{X} \\end{array} \\] See readme vignettes details format problems, phy algorithm useful.","code":""},{"path":"./reference/optimize_phy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimize a function with the PB-Hybrid algorithm — optimize_phy","text":"","code":"optimize_phy(   f = function(x, xtil) NA,   g = function(x, xtil) 0,   gtil = function(xtil) 0,   x_dom,   xtil_dom,   initializer,   optimizer,   updater,   stopper = flow_stopper(),   logger = flow_logger(),   check_samples = NULL,   check_op = c(1, 2) )"},{"path":"./reference/optimize_phy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimize a function with the PB-Hybrid algorithm — optimize_phy","text":"f Objective function \\(f(x, \\tilde{x})\\). g, gtil Constraint functions \\(g(x, \\tilde{x})\\) \\(\\tilde{g}(\\tilde{x})\\). default, never-binding ones. x_dom, xtil_dom Domains \\(X\\) \\(\\tilde{X}\\). used optimizer (\\(X\\)), initializer/updater (\\(\\tilde{X}\\)). list \\(m\\) \\(\\tilde{m}\\) entries. initializer Operator (function) initialize population, \\(S_0 = \\text{initializer}(\\tilde{X}, \\tilde{g})\\) (see details). optimizer Operator (function) solve reduced problem, \\(R_t = \\text{optimizer}(X, g, t, S_t)\\) (see details). updater Operator (function) update population, \\(S_{t+1} = \\text{updater}(\\tilde{X}, \\tilde{g}, t, S_t, R_t)\\). stopper Stopping criteria algorithm, created via flow_stopper(). logger Logger tracking process, created via flow_logger(). check_samples Number samples expected \\(S_t\\). Set NULL check (required changes iterations \\(t\\)). check_op Integer vector iterations check operators producing results needed format. Helps catching errors. Set 0 check.","code":""},{"path":"./reference/optimize_phy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimize a function with the PB-Hybrid algorithm — optimize_phy","text":"list containing: results Optimization results iteration. metrics Metrics calculated optimization process. duration Timing information initialization, main loop, total execution.","code":""},{"path":"./reference/optimize_phy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimize a function with the PB-Hybrid algorithm — optimize_phy","text":"function wrapper operator functions, organizing correct structure population-based, two-step, hybrid algorithm. , job user implement operators correctly. highly recommend seeing vignette(\"example\") fully understand use: initializer: Arguments: xtil_dom gtil. Returns: \\(N \\times \\tilde{m}\\) matrix initial guesses \\(\\tilde{x}\\), \\(N\\) initial population size. optimizer: Arguments: f_s, g_s - functions conditional sample \\(\\tilde{x}_s\\) -, x_dom, t - current iteration -, xtil_s - current sample. Returns: data.frame four columns: x: \\(1 \\times m\\) vector optimal values \\(x^*\\), given \\(\\tilde{x}_s\\). Hint: use () create matrix-columns. xtil: \\(1 \\times \\tilde{m}\\) matrix xtil_s. f: value \\(f(x^*, \\tilde{x}_s)\\) (single double). : meta-information want add, use updater metrics methods. none, use single NA. updater: Arguments: xtil_dom, gtil, r_t - results last iteration's optimizer (data frame) -, t. Returns: new \\(N \\times \\tilde{m}\\) matrix guesses, note \\(N\\) can change iterations.","code":""},{"path":"./reference/phyopt-package.html","id":null,"dir":"Reference","previous_headings":"","what":"phyopt: General-Use Population-Based Hybrid-Optimization — phyopt-package","title":"phyopt: General-Use Population-Based Hybrid-Optimization — phyopt-package","text":"Implement population-based hybrid-optimization algorithms. Separate problem two steps, define methods initializing population first-step guesses, optimizing second step, updating population, comprehensive helpers error handling.","code":""},{"path":[]},{"path":"./reference/phyopt-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"phyopt: General-Use Population-Based Hybrid-Optimization — phyopt-package","text":"Maintainer: Ricardo Semião ricardo.semiao@outlook.com","code":""},{"path":"./news/index.html","id":"phyopt-development-version","dir":"Changelog","previous_headings":"","what":"phyopt (development version)","title":"phyopt (development version)","text":"Initiated development package.","code":""}]
