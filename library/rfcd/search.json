[{"path":"index.html","id":"bem-vindoa","chapter":"Bem Vindo(a)!","heading":"Bem Vindo(a)!","text":"Este livro tem o objetivo de ensinar linguagem R. O material tem duas especificidades principais:É um livro para níveis diversos de experiência – é introdutório, mas expõe conceitos avançados e com profundidade.Tem uma abordagem mista – primeiro focando na teoria, fundamentos, e funcionamento da linguagem, mas depois apresentando temas aplicados.Abaixo explico motivação para esse estilo, bem como para quem ele pode ser útil.este livro está em construção. O material aqui presente ainda é um rascunho, o estilo livro pode vir sofrer mudanças drásticas. Adicionalmente, precisão dos conceitos não está 100% garantida.\nmomento, o início livro, até o capítulo 3, está relativamente em ordem, depois, até 7 + 9 e 11 existe um rascunho bem feito. Atualmente, estou mais focado material de Julia. Voltarei à este projeto em 2026, após finalizar meu mestrado.","code":""},{"path":"index.html","id":"por-que-este-livro","chapter":"Bem Vindo(a)!","heading":"Por que Este Livro?","text":"Existem diferentes estilos de aprendizagem, alguns preferem “aprender fazendo”, outros preferem “aprender estudando”. Este livro é, em sua maior parte, signatário segundo. Porém, mesmo se esse não seu estilo preferido, argumento que ele combina com o estudo de R.R é uma linguagem única, para o bem e para o mal:Ela contém muitas exceções, particularidades, e heranças de outros tempos. Elas são causas comuns de erros e dificuldades de compreensão. Aprender regra, teoria, o contexto geral, facilita muito aprender lidar com exceções da maneira menos dolorosa possível.Ela contém ferramentas poderosas e incomuns. especialização em estatística motiva existência de construtos nada óbvios, mas muito úteis. Existe uma variedade de estilos (funcionais, orientado ao objeto, metalinguísticos) igualmente importantes, mas difíceis de alcançar sem um estudo mais teórico.Essas especificidades são exploradas na primeira metade livro, “Fundamentos”. ideia é que o leitor fique confiante de saber “como o R funciona”, e não apenas “saber escrever códigos”, mas sem investir tempo nas complexidades não-essenciais. Adicionalmente, introduzo o tidyverse, que dispõe ferramentas poderosas e acessíveis, graças à sua filosofia e sintaxe intuitiva.Mas claro que o conhecimento aplicado também é quisto (deixemos o estudo puramente teórico para os nerds da ciência da computação). Portanto, na segunda metade livro, “Ciência de Dados”, foco em aplicar o conhecimento recém adquirido para aprender algumas das tarefas mais comuns em projetos R: arrumação, manipulação, visualização, e modelagem de dados. Aqui, os conhecimentos da primeira metade permitem um aprendizado mais rápido e profundo.Antes de seguir adiante, uma palava motivacional: vezes uma pessoa passa mais tempo estudando um assunto que deveria, e quanto mais fundo vai, mais difícil é parar de estudar. Esse é o meu caso, mas gostaria de ter companhia nessa situação (ninguém é de ferro). Foi com isso em mente que montei esse material, para dar oportunidade leitor fazer o mesmo, “se afundar R”, da forma mais eficiente possível. Espero que goste!","code":""},{"path":"index.html","id":"organização-do-livro","chapter":"Bem Vindo(a)!","heading":"Organização do Livro","text":"O livro é dividido em quatro partes: “- Fundamentos: R Base”, “II - Fundamentos: Tidyverse”, “III - Ciência de Dados: Processar e Visualizar”, e “IV - Ciência de Dados: Modelar”.bases desse material estão descritas na seção 1.3, já adianto o disclaimer: boa parte conteúdo deste livro é uma curadoria, adaptação, e tradução dos materiais abaixo.Parte - “R Language Definition”,1 “R Internals”2 e “Advanced R” (2e).3Parte II - Documentação tidyverse4 e ggplot2,5 “Data Manipulation R”,6 e “R Programming Data Science”.7Partes III e IV - “R Data Science” (2e)8 e “R Cookbook” (2e).9","code":""},{"path":"index.html","id":"introdução","chapter":"Bem Vindo(a)!","heading":"Introdução","text":"Para começar, exponho alguns temas iniciais, como: história da linguagem, suas características gerais, porque aprender R; literatura sobre R, e referências deste livro.Também preparo o leitor para iniciar sua jornada, explicando o estilo e didática livro, bem como mostrando instalação e interface RStudio (de uma maneira bastante preguiçosa).","code":""},{"path":"index.html","id":"parte-i---fundamentos-r-base","chapter":"Bem Vindo(a)!","heading":"Parte I - Fundamentos: R base","text":"Os conceitos basilares R costumam ser ensinados rapidamente, para dar prioridade na manipulação de dados e aplicações. Esse curso não fará isso, iremos passar com bastante calma por essa dimensão, tanto porque existem menos tutoriais que fazem isso, mas principalmente, porque aprender sobre como o R funciona com detalhe gera uma série de benefícios:Permite aprender fontes comuns de erros e como evitá-las.Facilitará o entendimento dos conceitos que empoderam o tidyverse e diversas aplicações possíveis.Permite escrever códigos mais elegantes e, principalmente, mais eficientes.Permite entender códigos mais complexos.Essa abordagem é algo como “ter aulas formais de uma língua”, em oposição “ensino para turismo”. utilidade desse enfoque depende de seu objetivo.","code":""},{"path":"index.html","id":"parte-ii---fundamentos-tidyverse","chapter":"Bem Vindo(a)!","heading":"Parte II - Fundamentos: Tidyverse","text":"O tidyverse é um conjunto incrível de extensões ao R, com uma filosofia e sintaxe unificada e intuitiva. Ele apresenta ferramentas poderosas para maior parte das tarefas essenciais em projetos R.Nessa parte, explicarei seus fundamentos, relacionando com os conceitos da Parte , e darei rápidos tutoriais sobre ferramentas nele contidas. Todas serão imediatamente aplicadas na parte seguinte.","code":""},{"path":"index.html","id":"parte-iii---ciência-de-dados-processar","chapter":"Bem Vindo(a)!","heading":"Parte III - Ciência de Dados: Processar","text":"Aqui começa segunda metade livro. Inicio respondendo “o que é ciência de dados?”, e em qual formato queremos esse tal de “dados”. partir daí, o objetivo é aprender obter, arrumar, manipular, e unir dados, de modo alcançar esse formato quisto.Além da formatação, aprenderemos manipular dados como uma ferramenta de exploração.Em termos simplistas, parte III é parte II aplicada (menos visualização).","code":""},{"path":"index.html","id":"parte-iv---ciência-de-dados-explorar","chapter":"Bem Vindo(a)!","heading":"Parte IV - Ciência de Dados: Explorar","text":"última parte livro foca em como descrever dados com base em visualizações e modelos.Iremos aplicar ferramentas de visualização da parte II para criar gráficos que ajudem explorar e entender relações presentes nos dados.Irei explicar o que é um modelo, e apresentar algumas estratégias e frameworks disponíveis. Ao fim, listo referências para outras aplicações de possível interesse.","code":""},{"path":"index.html","id":"treinamento","chapter":"Bem Vindo(a)!","heading":"Treinamento","text":"Contarei mais sobre mim na seção abaixo, mas antes, uma auto-divulgação (que nunca fez mal ninguém).Eu aplico aulas personalizadas de R para qualquer tipo de grupo/indivíduo. aulas podem incluir o conteúdo deste livro e/ou focar em temas aplicados específicos, bem como conter tópicos teóricos de áreas de meu conhecimento – estatística, economia, finanças, matemática, entre outros.Se tiver interesse, mande um email! Sou bastante aberto para conversar e criar projetos em conjunto.","code":""},{"path":"index.html","id":"sobre-o-autor","chapter":"Bem Vindo(a)!","heading":"Sobre o Autor","text":"Meu nome é Ricardo Semião e Castro, sou mestrando em economia na FGV-EESP, e sou fã de R. Se tiver algum comentário sobre este material, por favor mande em meu email (ricardo.semiao@outlook.com). Minhas redes são:Site pessoal.Github.Linkedin.StackOverflow.Twitter.O livro tem relação com meus outros materiais educativos, mas em oposição ao resto, foi criado para ser um material independente e voltado ao público geral. Veja-os abaixo:“Ciência da Computação: Introdução e Aplicações” (course-ccia): conceitos básicos de ciência da computação, de maneira bem simplificada. Define fundação para os outros livros, focados em linguagens/ferramentas específicas.Linguagens de baixo nível, e outros tópicos (em course-ccia): conceitos básicos de linguagens de baixo nível, databases, controle de versão, para empoderar seu uso como acessórios em projetos.“Julia: Performance e Ciência” (em course-ccia): Typing, multiple dispatch, e performance; programação científica.“R: Fundamentos e Ciência de Dados” (este livro): metaprogramação e programação funcional; manipulação e visualização de dados.“Python: Automação, Apps, e Machine Learning” (course-paaml): oop; automação, desenvolvimento de aplicações, e modelagem de machine learning.","code":""},{"path":"index.html","id":"licença","chapter":"Bem Vindo(a)!","heading":"Licença","text":"Esse material, como um todo, está licenciado pela Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.","code":""},{"path":"introduction.html","id":"introduction","chapter":"1 Introdução","heading":"1 Introdução","text":"","code":""},{"path":"introduction.html","id":"história","chapter":"1 Introdução","heading":"1.1 História","text":"R é “uma linguagem de programação e um ambiente para computação estatística e gráfica”10. Ambiente sentido que é um “sistema totalmente planejado e coerente”, não uma ferramenta específica e inflexível. É uma linguagem especializada, com ferramentas poderosas e acessíveis para projetos de campos como estatística e ciência de dados. Ao mesmo tempo, é facilmente incrementável, com centenas de extensões para mais diversas áreas.O R foi criado em 1993 por Ross Ihaka e Robert Gentleman da Universidade de Auckland, Nova Zelândia, com o apoio de John Chambers Bell Laboratories. Sucedeu linguagem S, e junto com inicial dos autores, o nome R foi cunhado. Não, infelizmente, não é R de “Ricardo”.Existem várias entidades associadas ao desenvolvimento da linguagem:O Comprehensive R Archive Network (CRAN) foi criado em 1997 por Kurt Hornik e Fritz Leisch para armazenar o código fonte, documentação, e pacotes R.O R Core Team foi formado em 1997 para desenvolver linguagem.linguagem como projeto e homepage oficial é o R Project. Também existe homepage das versões em desenvolvimento R.R Foundation foi fundada em 2003 para guiar o R Project.O RStudio, agora Posit foi fundado para expandir qualidade projeto, lançando um ambiente de desenvolvimento integrado em 2011, e oferecendo soluções para empresas.O R Journal e R Blog.","code":""},{"path":"introduction.html","id":"características-da-linguagem-e-porque-r","chapter":"1 Introdução","heading":"1.2 Características da Linguagem, e “Porque R?”","text":"O R é uma linguagem bem específica. Abaixo cito algumas de suas características, e porque elas podem motivar seu estudo.R está disponível como código aberto, com sua licença GNU General Public License. Adicionalmente, é acessível para maioria das máquinas/sistemas operacionais. Isso faz com que projetos R sejam acessíveis e facilmente replicados por outros.R está disponível como código aberto, com sua licença GNU General Public License. Adicionalmente, é acessível para maioria das máquinas/sistemas operacionais. Isso faz com que projetos R sejam acessíveis e facilmente replicados por outros.R é uma linguagem popular, ficou na posição 21 TIOBE Index em fev/2024. Especialmente, ele conta com uma comunidade muito ativa e amigável, na #rstats Twitter, StackOverflow, Posit Community, e pessoalmente.R é uma linguagem popular, ficou na posição 21 TIOBE Index em fev/2024. Especialmente, ele conta com uma comunidade muito ativa e amigável, na #rstats Twitter, StackOverflow, Posit Community, e pessoalmente.Um produto dessa popularidade é quantidade massiva de extensões, para toda sorte de tarefa.\nExistem múltiplas abordagens para manipulação de dados, modelagem, e criação de visualizações.\nPoderosas ferramentas para comunicação, o RMarkdown (que foi utilizado para construir esse livro), e o Shiny, utilizado para construir Apps.\nFerramentas na fronteira de pesquisa, uma vez que pesquisadores costumam criar pacotes R para acompanhar suas inovações.\nUm produto dessa popularidade é quantidade massiva de extensões, para toda sorte de tarefa.Existem múltiplas abordagens para manipulação de dados, modelagem, e criação de visualizações.Poderosas ferramentas para comunicação, o RMarkdown (que foi utilizado para construir esse livro), e o Shiny, utilizado para construir Apps.Ferramentas na fronteira de pesquisa, uma vez que pesquisadores costumam criar pacotes R para acompanhar suas inovações.Ocupa um espaço muito interessante na paisagem de softwares:\nÉ uma linguagem de programação verdadeira, permitindo soluções para problemas mais complexos, e dando mais flexibilidade ao usuário, quando comparado com outros softwares estatísticos não programáticos como o SAS, SPSS, Stata, Eviews, e GRETL.\nMas é especializado, interpretada, e high-level, facilitando seu uso, e apresentando uma cuva de aprendizado mais rápida que linguagens mais complexas/generalistas como C.\nespecialização em estatística faz com que ferramentas muito necessárias para análise de dados sejam de fácil acesso, como data frames e vetorização. O usuário não precisa aprender extensões para realizar projetos em ciência de dados.\nOcupa um espaço muito interessante na paisagem de softwares:É uma linguagem de programação verdadeira, permitindo soluções para problemas mais complexos, e dando mais flexibilidade ao usuário, quando comparado com outros softwares estatísticos não programáticos como o SAS, SPSS, Stata, Eviews, e GRETL.Mas é especializado, interpretada, e high-level, facilitando seu uso, e apresentando uma cuva de aprendizado mais rápida que linguagens mais complexas/generalistas como C.especialização em estatística faz com que ferramentas muito necessárias para análise de dados sejam de fácil acesso, como data frames e vetorização. O usuário não precisa aprender extensões para realizar projetos em ciência de dados.Algumas características mais técnicas:\nSua sintaxe é similar à C e Python, mas sua semântica é de uma linguagem funcional, mais similar à Lisp e APL. Veremos que o estilo funcional é muito útil para projetos de ciência de dados.\nDito isso, o R é uma linguagem com múltiplos paradigmas: tem capacidades incomuns de metaprogramação, permitindo códigos elegantes e sucintos; provê programação orientada ao objeto de forma limitada, mas de maneira útil e simples.\nO R usa código em C, C++, e Fortran para executar tarefas computacionalmente intensivas. Isso é algo que o usuário também pode explorar.\nAlgumas características mais técnicas:Sua sintaxe é similar à C e Python, mas sua semântica é de uma linguagem funcional, mais similar à Lisp e APL. Veremos que o estilo funcional é muito útil para projetos de ciência de dados.Dito isso, o R é uma linguagem com múltiplos paradigmas: tem capacidades incomuns de metaprogramação, permitindo códigos elegantes e sucintos; provê programação orientada ao objeto de forma limitada, mas de maneira útil e simples.O R usa código em C, C++, e Fortran para executar tarefas computacionalmente intensivas. Isso é algo que o usuário também pode explorar.Porém, nem tudo são flores. Muitas dessas características tem prós e contras, e execução dessas ideias conta com heranças obsoletas e inconsistências. Neste livro, deixarei claro os pontos negativos mais importantes, e ensino evitá-los.","code":""},{"path":"introduction.html","id":"biblio","chapter":"1 Introdução","heading":"1.3 Literatura sobre R","text":"literatura base pode ser encontrada CRAN. Ela é composta de, principalmente:O código fonte.O manual “R Language Definition”, que descreve linguagem em si.O manual “R Internals”, que descreve estruturas internas R, e fundação código em C.documentação de ajuda para o R base e extensões padrões.documentação de ajuda para extensões externas.11Nenhuma dessas é exatamente didática, mas existe uma vasta bibliografia de livros para R, tanto para ensinar linguagem geral, quanto para toda sorte de aplicações.Abaixo apresento bibliografia principal deste livro. Na seção de introdução de cada parte, descreverei melhor sugestões de leitura, e como elas complementam o material.Bibliografia base da parte : “R Language Definition”,12 “R Internals”13 e “Advanced R” (2e).14Outras documentações utilizadas: código fonte15 e documentação das extensões básicas.16Outros livros utilizados: “Working R”,17 e “Forgot Teach R”.18Sugestões de leitura: “Hands Programming R”,19 e “Introduction R”.20Bibliografia base da parte II: documentação tidyverse,21 “ggplot2: Elegant Graphics Data Analysis” (3e).22Outros livros utilizados: “Data Manipulation R”,23 e “R Programming Data Science”.24Sugestões de leitura: “Modern R tidyverse”,25 e “STAT 545”.26Bibliografia base das partes III e IV: “R Data Science”,27 e “R Cookbook” (2e).28Sugestões de leitura: “ModernDive R Tidyverse”,29 “Everything need Exploratory Data Analysis & Visualization”,30 “Introduction Data Exploration Analysis R”,31 “Big Book R”Existem muitos outros livros e tutoriais dedicados aplicações específicas. Algumas listas (incompletas) podem ser encontradas arquivo CRAN.","code":""},{"path":"introduction.html","id":"estilo-do-livro","chapter":"1 Introdução","heading":"1.4 Estilo do Livro","text":"Antes de prosseguir, quero expor de antemão o estilo e organização dos capítulos.Este livro tem muito cobrir, e tem um andamento acelerado. Para facilitar ao máximo vida leitor, o estilo dos capítulos foi definido para ajudar direcionar atenção para o que é mais importante, e menos atenção para o extra. Abaixo apresento alguns dos construtos utilizados para tal.Pequenos excertos de código são apresentados na linha 1 + 1, e blocos de código como abaixo.Nos exemplos deste livro, um comentário formato #> ... indica o resultado esperado da declaração que o precede.Palavras em negrito normalmente indicam conceitos que serão definidos. Após sua apresentação, os conceitos costumam deixar de aparecer em negrito.Palavras em itálico costumam denotar um termo com significado específico contexto relevante.‘Nome’ resultado\nResultados importantes são expostos neste tipo de bloco. Note que nem todos os resultados serão simples de entender imediatamente, mas são expostos momento em que é relevante para o estudo da linguagem.vezes é importante apresentar um exemplo para esclarecer um conceito. Tendo colocar exemplos apenas quando necessário, de modo que é importante entendê-los. Em contrapartida, não há muitos exemplos “complementares”. É natural que essa baixa frequência torne difícil compreensão de alguns temas. Mas para isso existem os exercícios.nesse bloco explicito pontos que o leitor deve prestar atenção. Na maioria dos casos, apresento causas comuns de erros.observações deste tipo costumam ser sobre organização livro ou outros esclarecimentos menos importantes.nesse tipo de bloco apresento referências que tratam tema relevante com mais calma, ou trazem tópicos adicionais para o leitor que queira expandir seus conhecimentos.Itens desse tipo costumam trazer curiosidades menos importantes.Ao final de cada capítulo existe uma seção de “Complemento”. Nele, há:Uma recapitulação dos conceitos apresentados.Uma lista de funções apresentadas capítulo.Uma seção de referências, inclusive com links para conceitos deixados de lado capítulo, para o leitor que quiser ir além.Uma lista de exercícios, que normalmente também apresenta novos conceitos/funções.","code":"\nx <- 1 + 1\nx * 2 #> 4"},{"path":"introduction.html","id":"instalação-interface-e-ferramentas","chapter":"1 Introdução","heading":"1.5 Instalação, Interface, e Ferramentas","text":"Antes de começar o aprendizado, é preciso instalar linguagem (R), e se familiarizar com interface editor de código oficial (RStudio).Veja como instalar neste tutorial curso “R Para Jornalistas”. PS: coincidentemente, maneira que jornalistas instalam o R serve para qualquer outra profissão também.Existem vários tutoriais online explicando interface, como o da Datacamp (veja até “Write R Scripts RStudio”), e o video “RStudio Total Beginner”. Eu gosto bastante capítulo “Getting know RStudio” meu amigo Bruno Rodrigues32.Além disso, existem três configurações mais comuns de serem alteradas: alterar onde os arquivos são salvos por padrão; impedir que os dados da última sessão R sejam recarregados quando você voltar; e alterar aparência – afinal, você só se torna um programador após passar 3h escolhendo o tema perfeito. Elas podem ser encontradas em [barra de menu] > Tools > Global Options, nas abas General e Appearance.vide capítulo “3 - Using RStudio”,33 e 3 - “Navigating Software”,34 para mais informações sobre interface.Até o momento, eu fui preguiçoso e não trouxe esse material para o livro. Ainda assim, veja referências com calma, não deixe confusões com o software atrapalharem seu aprendizado.Última coisa, eu juro. O R provê alguns comandos para procurar por ajuda. função vignette() abre uma lista de artigos de ajuda das extensões R. Adicionalmente, se você quer saber informações sobre uma função chamada acaba_pelo_amor_de_deus, os códigos abaixo abrem suas documentações de ajuda.Agora sim, vamos começar. Boa sorte!","code":"\n?acaba_pelo_amor_de_deus\nhelp(\"acaba_pelo_amor_de_deus\")"},{"path":"intro1.html","id":"intro1","chapter":"Introdução","heading":"Introdução","text":"Bem vindo à primeira parte deste livro, onde estudaremos os conceitos na base R. Partirei zero absoluto, de modo que é possível que o leitor tenha algum nível de familiaridade com os temas, mas idealmente, não na profundidade aqui abordada.Nessa parte mais “teórica”, é difícil de traçar o limite nível de complexidade ideal. Por conta disso, muitos conceitos tiveram de ser introduzidos rapidamente. Mas não se assuste, muitas vezes, meu objetivo maior é passar uma intuição geral de como o R funciona, e dar um primeiro contato com os temas mais complexos. Tento ao máximo deixar claro onde gastar seu cérebro e onde nem tanto.Meu foco é mostrar lógica R, “sintaxe e semântica” da linguagem. “gramática” ou “vocabulário”, isto é, funções, truques, e aplicações específicas, serão ensinadas de passagem e via exercícios. Mas final, ideia é ter apresentado maioria das funções comumente relevantes, construindo uma lista de referência para futuras consultas.Os capítulos dessa seção estão organizados da seguinte maneira:Capítulo 2: aqui aprenderemos, principalmente, estrutura de um programa em R, os tijolinhos que compõe, e como é relação entre variáveis e memória computador. Outros temas mais concretos serão sintaxe básica, variáveis, e operadores básicos.Capítulo 3: veremos como organização de tipos de dados R é elegantemente simples, incluindo complexidade através da existência de metadados. principal conclusão será entender relação entre os diferentes tipos, uma vez que esse conhecimento torna mais fácil pensar como operações são aplicadas cada tipo de dado.Capítulo 4: nessa altura campeonato, capaz que você esteja cansado de ver apenas teoria, esse capítulo é o mais “gramatical” de todos. Aprenderemos o que é operação de selecionar e alterar partes de uma variável. Aqui, já fica claro o benefício de entender organização dos tipos de dados.Capítulo 5: aprenderemos controlar o fluxo de um programa, isto é, como fazer um programa tomar decisões e repetir operações. Aprenderemos também lidar com erros e avisos.Capítulo 6: em oposição ao capítulo 3, agora é hora de dar atenção aos sentimentos R. Estávamos utilizando-, mas não explicamos o que são funções. Esse é o capítulo mais desafiador, mas boa parte da dificuldade pode ser deixada de lado, com perdas reduzidas ao leitor.Capítulo 7: aqui, aprenderemos sobre os paradigmas/estilos de programação funcional, orientada ao objeto, e meta, especificamente sobre sua abordagem R. programação funcional é uma ferramenta com ligação direta nos projetos de ciência de dados; Entender o básico de POO R é importante para entender o uso de … funções35; Metaprogramação é um assunto útil em si mesmo, mas especialmente importante para entender bases tidyverse na parte II.Capítulo 8: por fim, temos algum outros tópicos úteis, mas não essenciais para o seguimento livro. Aqui, aprenderemos sobre algumas ferramentas de melhoria de vida que o RStudio provê, e alguns temas avançados sobre gerenciamento de memória, performance, e organização.Recapitulado: não só em cada capítulo, mas cada parte deste livro, existe uma seção para retomar os conteúdos, especialmente o que será mais útil para próxima parte.","code":""},{"path":"syntax-vars.html","id":"syntax-vars","chapter":"2 Sintaxe e Variáveis","heading":"2 Sintaxe e Variáveis","text":"","code":""},{"path":"syntax-vars.html","id":"introdução-1","chapter":"2 Sintaxe e Variáveis","heading":"Introdução","text":"Neste capítulo, vamos aprender, principalmente, estrutura de um programa em R, e os tijolinhos que compõe.Haverão dois aprendizados principais: () estrutura pode ser entendida como de um texto instrucional; (ii) temos apenas dois tijolos, (nomes de) objetos e (chamadas de) funções; (iii) como é relação entre variáveis e memória computador. Esses tópicos principais são bastante teóricos/abstratos, mas serão úteis futuro, e seu entendimento gera habilidade de generalizar esses conceitos para outras linguagens de programação.Aprenderemos também tópicos mais concretos: () sintaxe básica da linguagem; (ii) como definir e como funcionam variáveis; (iii) funções (operadores) básicas da linguagem.","code":""},{"path":"syntax-vars.html","id":"sintaxe-e-tijolinhos","chapter":"2 Sintaxe e Variáveis","heading":"2.1 Sintaxe e Tijolinhos","text":"Em termos simplistas, um script é um arquivo de texto com instruções serem executadas por um computador.Note que o computador, nível mais baixo, apenas entende sequências de 0s e 1s, de modo que um script precisa ser “traduzido”. Algumas linguagens são compiladas, onde o texto inteiro é traduzido antes de serem executado, outras são interpretadas, traduzidas “na hora”, frase frase. O R é o segundo caso, por isso que conseguiremos rodar códigos linha linha – em vez de apenas poder executar um arquivo inteiro.Um script é um texto instrucional como qualquer outro, escrito em um tipo de linguagem especial, “de programação”, mas é um texto. Similar à receita de bolo de cenoura da minha vó, ou o roteiro da peça escolar onde interpretei, com maestria, árvore #3.Como em qualquer linguagem, temos um vocabulário à disposição, um conjunto de palavras (ou tokens) existentes, organizadas em categorias como substantivos, verbos, etc. Nós combinamos palavras em frases (ou statements/declarações) para descrever instruções. Por fim, podemos opcionalmente organizar o texto em parágrafos (ou blocks), conjuntos de frases que devem ser lidas juntas, para definir estrutura e facilitar o entendimento texto.Ok, receita da minha vó não tinha parágrafos, metáfora não é perfeita, paciência.seguir, vamos descrever com mais calma esses conceitos de tokens, statements e blocks.","code":""},{"path":"syntax-vars.html","id":"objetos-e-funções","chapter":"2 Sintaxe e Variáveis","heading":"2.1.1 Objetos e Funções","text":"Existem dois tijolinhos principais R:Objetosvalores (dados), que podem carregar também atributos (metadados).Cada valor tem um tipo/type36.Podem ser associados à um nome/symbol. O conjunto nome-objeto é chamado de variável. Mas também podem ser escritos “por extenso”, como 1 ou \"Hello World!\".em ciência da computação, o termo “objeto” é relacionado à Programação Orientada ao Objeto, significando “uma instância de uma classe”. Esse conceito irá existir R, mas não é o que estamos tratando aqui. Aqui, “objeto” é um termo mais genérico.FunçõesDefinem operações à serem realizadas usando objetos.Operadores, símbolos como + e >, são uma categoria de função especial, que apresentam uma sintaxe mais enxuta.Note que descrevemos tudo que há na linguagem em apenas dois conceitos, objetos e funções. Em outras palavras:“[R,] everything exists object; everything happens function call.” — John Chambers.É esse tipo de simplicidade que, na minha opinião, torna aprender “teoria” sobre o R tão interessante:Veremos que ter essa categoria de conhecimento sobre linguagem facilitará muito o entendimento de temas futuros.Estaremos adquirindo habilidade de aprender o funcionamento de linguagens de programação geral, usando um exemplo (R) simples.O capítulo 3 explicará os objetos, e 6 funções. Pela lógica, esses dois devem conter completude conhecimento sobre R, e o resto livro é só enfeite.","code":""},{"path":"syntax-vars.html","id":"palavras","chapter":"2 Sintaxe e Variáveis","heading":"2.1.2 Palavras","text":"Voltando à nossa analogia, tudo que você lê em um script é uma de duas (três) coisas.VocabulárioQuais palavras/tokens, temos disponíveis na linguagem R?Substantivos, os nomes de objetos (ou objetos escritos por extenso).Verbos, (chamadas de) funções.Para ser preciso, também tempos alguns caracteres puramente estéticos, syntactic sugar, como espaços e tabs.Mais para frente, veremos que podemos salvar excertos de código R em um objeto, e teremos apenas três tipos de objetos da linguagem.Mas vamos sair da abstração. Como escrevemos essas palavras em um texto de R?Valores:\nStrings: utilize aspas duplas \" ou aspas simples': \"Hello World!\", 'Hello World!'. galerinha R costuma usar mais duplas..\nNúmeros: simplesmente escreva-os: 1. Use um ponto . como o separador decimal 0.01.\nBooleanos: escreva palavras especiais TRUE e FALSE.\nStrings: utilize aspas duplas \" ou aspas simples': \"Hello World!\", 'Hello World!'. galerinha R costuma usar mais duplas..Números: simplesmente escreva-os: 1. Use um ponto . como o separador decimal 0.01.Booleanos: escreva palavras especiais TRUE e FALSE.Variáveis: o operador <- associa o nome à esquerda ao valor à direita: <- 1. Não se preocupe muito com isso por agora.Funções: escreva o nome da função, e os argumentos que ela receberá entre parênteses sum(1, 1). Não se preocupe muito com elas por agora.\nOperadores: são imputados como 1 + 1.\nParênteses podem ser utilizados em operações múltiplas: (1+1)/2.\nOperadores: são imputados como 1 + 1.Parênteses podem ser utilizados em operações múltiplas: (1+1)/2.Comentários: texto que não será avaliado como código. Use o símbolo #, que torna tudo após dele, na mesma linha, um comentário.","code":""},{"path":"syntax-vars.html","id":"frases","chapter":"2 Sintaxe e Variáveis","heading":"2.1.3 Frases","text":"Como dito, frases R serão combinações de tokens. Qualquer combinação. Podem ser apenas um valor (1), o nome de uma variável (), ou chamada de uma função (sum(1, 1)).cada linha código abaixo é uma frase:E quanto um código como 1 +? Bom, esse código não é sintaticamente correto. Normalmente, chamamos de statement/declaração apenas frases sintaticamente corretas, e eu irei passar usar essa nomenclatura em diante.","code":"\n1\n1 + 1\na <- 1\na #retorna o valor da variável \"a\"\nsum(1, 1)\nsum(1, 1) + a"},{"path":"syntax-vars.html","id":"parágrafos","chapter":"2 Sintaxe e Variáveis","heading":"2.1.4 Parágrafos","text":"Um mesmo texto pode ser organizado de várias maneiras diferentes, e isso é verdade para um script também. Como delimitamos declarações?Por padrão, uma declaração acaba na quebra de linha.\nSe declaração terminar inacabada (como exemplo 1 +), o R ignora quebra de linha, e tenta completar declaração com linha seguinte.\nUm ponto e vírgula pode ser usado para delimitar uma declarações explicitamente: 1 + 1; 2 + 2. Mas seu uso não é uma comum nem recomendável.\nSe declaração terminar inacabada (como exemplo 1 +), o R ignora quebra de linha, e tenta completar declaração com linha seguinte.Um ponto e vírgula pode ser usado para delimitar uma declarações explicitamente: 1 + 1; 2 + 2. Mas seu uso não é uma comum nem recomendável.Várias declarações podem ser agregadas em grupos ou blocks usando chaves {}.um grupo de declarações é uma declaração em si. chaves são uma função, que combina várias declarações em uma só. Uou, tudo realmente é uma chamada de função.Note que, assim como em um texto, organização em parágrafos não necessariamente afeta lógica texto, o que o script faz, pode afetar apenas sua organização.Antes de avançar, vou mentir um pouco e dar duas definições, mas que serão melhor detalhadas futuro.ExpressãoÉ uma declaração não avaliada, “congelada”, que o R não rodou. Elas terão seu próprio tipo de objeto.Ter um tipo de objeto para isso é uma característica definidora R, usaremos padrões de programação que operam sobre própria linguagem.FunçãoÉ uma expressão, que depende de variáveis, possivelmente associada à um nome. Utilizar esse nome, indicando os valores das variáveis envolvidas (entre parênteses ()), avalia declaração, retornando seu resultado. Elas terão seus próprios tipos de objeto (mais de um).Veja o exemplo abaixo, mas não se preocupe, irei detalhar mais sobre funções capítulo 6. Mas note como salvamos uma função da mesma maneira que salvamos qualquer outro objeto.Com essa definição em mente, na nossa analogia começo capítulo, funções são “parágrafos nomeáveis”.","code":"\nliar <- function(x, y) {x + y}\nliar(x = 1, y = 2) #> 3\nliar(1, 2) #equivalente à declaração anterior"},{"path":"syntax-vars.html","id":"variáveis","chapter":"2 Sintaxe e Variáveis","heading":"2.2 Variáveis","text":"variáveis merecem mais da nossa atenção. Mas não é para elas se acharem demais, valores/atributos e funções terão seus próprios capítulos.","code":""},{"path":"syntax-vars.html","id":"definindo-variáveis","chapter":"2 Sintaxe e Variáveis","heading":"2.2.1 Definindo Variáveis","text":"Para definir variáveis, escrevemos seu nome, = ou <-, e declaração que definirá seu valor e atributos: x = 1 + 1, x <- 1 + 1.Também podemos usar função assign(), mas que será explicada futuro.Ao rodar algo como x <- 1, o objeto 1 é salvo na memória computador, e associado ao nome x. Como dito anteriormente, variável é o conjunto objeto-nome.O diagrama abaixo, inspirado presente em Advanced R, ilustra esse processo. Note que o objeto existe na memória computador, em uma localidade específica, e o nome é apenas uma referência à ele.O objeto pode ser pensado como localidade na memória em si, ou o que reside nela. Portanto, diagrama, o objeto tem uma etiqueta, com o seu endereço de memória37.","code":""},{"path":"syntax-vars.html","id":"copy-on-modify","chapter":"2 Sintaxe e Variáveis","heading":"2.2.2 Copy on Modify","text":"","code":""},{"path":"syntax-vars.html","id":"criando-referências-repetidas","chapter":"2 Sintaxe e Variáveis","heading":"2.2.2.1 Criando Referências Repetidas","text":"Com base que aprendeu, o que acontece ao rodar y <- x? Temos duas opções:y pode ser um novo nome, associado ao mesmo objeto – mesma posição na memória computador – que x.y pode ser um novo nome, associado um novo objeto – nova posição na memória computador – que x, mas carregando mesma informação.Note que sempre temos duas variáveis, pois são dois pares nome-objetos diferentes.O que acontece R é o primeiro caso. Isso evita que se separe um novo lugar na memória quando não se é necessário, economizando espaço e tempo.","code":""},{"path":"syntax-vars.html","id":"modificando-referências-repetidas","chapter":"2 Sintaxe e Variáveis","heading":"2.2.2.2 Modificando Referências Repetidas","text":"Agora, o que acontece com x quando modificamos y, ou vice versa? Por exemplo, y <- 2? Novamente, temos duas opções:O objeto associado à y é modificado diretamente em seu local da memória, de modo que x também “verá” mudança.O objeto é antes copiado para um novo local de memória, para então ser modificado apenas lá, de modo que x não “veja” mudança.O nome comportamento caso 1 é modify--place.R, o que acontece é o caso 2. Esse processo, de apenas “separar”/“copiar” objetos quando modificados, é chamado de copy--modify. Também falamos que os objetos R, fora exceções descritas abaixo, são imutáveis.Copy--modifyNo R, um mesmo objeto pode ter ser referenciado mais de um nome, gerando várias variáveis. Modificar alguma delas não modifica o objeto diretamente, mas copia-o em um novo local na memória, para abrigar o objeto modificado. Isso é, os objetos são copiados-após-mudanças.Existem duas exceções: objetos com apenas uma referência/um nome, e ambientes38. Esses são alterados “na hora”/“lugar”, ou modify--place.melhor maneira de ver quando um objeto é copiado é olhando empiricamente. Veja função tracemem() na seção 2.3.1 Advanced R.","code":""},{"path":"syntax-vars.html","id":"especificidades","chapter":"2 Sintaxe e Variáveis","heading":"2.2.2.3 Especificidades","text":"Diferentes tipos de valores terão diferentes relações com esse processo, mas vou poupá-los disso. O importante é saber que, na maioria dos casos, alterar y não altera x e vice versa, independente da complexidade objeto.se você está familiar com o conceito de lista, veja como elas se comportam em Advanced R seção 2.3.3. Em termos simplistas, listas são coleções de referências objetos, e não coleções de objetos (diretamente).este tema é complexo, e foi bastante simplificado. Vide Advanced R, seções “2.3 - Copy--modify” e “2.5 - Modify--place”. Os exemplos utilizando função tracemem() são especialmente úteis.","code":""},{"path":"syntax-vars.html","id":"outras-características","chapter":"2 Sintaxe e Variáveis","heading":"2.2.3 Outras Características","text":"Note que = e <- são muito similares, mas = serve para mais coisas que somente definição de variáveis, como indicar argumentos em uma função. Portanto, <- funciona como “definidor” em mais contextos, e é uma má prática utilizar = como definidor.Ambos podem definir várias variáveis de uma vez: x = y = 3, x <- y <- 3, x = y <- 3.Podemos usar também -> da esquerda pra direita: 3 -> x.Existe um terceiro operador <<-, que será discutido capítulo 6.","code":""},{"path":"syntax-vars.html","id":"regras-de-nomenclatura","chapter":"2 Sintaxe e Variáveis","heading":"2.2.4 Regras de Nomenclatura","text":"Nem toda combinação de caracteres pode ser um nome de variável. principais regras são:Nomes podem conter letras, números, “.” e “_“.São case-sensitive.Podem começar apenas com letras ou “.”.Não podem ser palavras reservadas como “TRUE”.Nomes não sintáticos podem ser definidos, se escritos usando crases (backticks): `_x` <- 1. Você provavelmente encontrará isso ao importar dados que não foram criados R.em muitos momentos, o R converte nomes não sintáticos utilizando função make.names(). Você aprenderá sobre ela nos exercícios. É muito importante estar atento à esse comportamento, uma vez que é causa comum de erros.\nVocê verá que isso é um tema comum: o R tenta facilitar muitas tarefas, fazendo coisas por você. Isso por um lado é o que o torna fácil de sair trabalhando, mas é causa de inconsistências.","code":""},{"path":"syntax-vars.html","id":"operadores","chapter":"2 Sintaxe e Variáveis","heading":"2.3 Operadores","text":"princípio, deixaria os detalhes sobre operadores para os exercícios, mas fiquei com medo deles se sentirem excluídos.Abaixo estão os operadores relevantes para o momento, suas descrições, e seu uso. Clique nos links dos operadores para abrir suas páginas de ajuda.Tabela 2.1: Principais operadores R.na coluna de “Uso”, “logi” se refere qualquer valor que se comporte como um valor booleano, “num” qualquer valor que se comporte como número, “expr” à qualquer statement, e “x”/“y” à valores mais genéricos, ou à nomes de variáveis.Agora vou apresentar ordem de precedência da aplicação dos operadores. Associatividade se refere à como são resolvidos “empates”, “direita pra esquerda” significa que o operador mais à direita é analisado antes. Tudo ficará mais claro exemplo que segue.Tabela 2.2: Precedência dos operadores R.linhas com um “(*)” apresentam operadores que ainda não foram apresentados.para deixar mais claro, na declaração (3+6)/(1+2)/5^4 o seguinte ocorre:() são analisados primeiro, porque tem precedência (estão acima na tabela).\nComo é da direita pra esquerda, primeiro (1+2) vira 3, e depois, (3+6) vira 9.\nComo é da direita pra esquerda, primeiro (1+2) vira 3, e depois, (3+6) vira 9.^ é analisado seguir, logo, 5^4 vira 625./ é analisado seguir.\nComo é da esquerda pra direita, primeiro 9/3 vira 3, e depois 3/625 vira 0.0048.\nComo é da esquerda pra direita, primeiro 9/3 vira 3, e depois 3/625 vira 0.0048.Vide Working R, capítulo “6 - Basic Operations” para mais detalhes e exemplos. Cuidado, alguns conceitos utilizados lá não foram vistos ainda.","code":""},{"path":"syntax-vars.html","id":"complemento","chapter":"2 Sintaxe e Variáveis","heading":"Complemento","text":"","code":""},{"path":"syntax-vars.html","id":"recapitulando","chapter":"2 Sintaxe e Variáveis","heading":"Recapitulando","text":"","code":""},{"path":"syntax-vars.html","id":"sintaxe","chapter":"2 Sintaxe e Variáveis","heading":"Sintaxe","text":"Neste capítulo, vimos estrutura geral de um script:Temos palavras/tokens, frases/statements/declarações, e parágrafos/blocks.R, tudo que existe é um objeto, e tudo que acontece é uma chamada de função.\nObjetos serão o tema próximo capítulo, e funções, capítulo 6.\nVimos como imputar cada token.\nObjetos serão o tema próximo capítulo, e funções, capítulo 6.Vimos como imputar cada token.declarações são combinações de tokens.\nCostumam ser delimitadas por quebras de linha.\nCostumam ser delimitadas por quebras de linha.Declarações podem ser organizadas em parágrafos vias chaves.Scripts são sequências de declarações.Vimos definições inciais para dois conceitos importantes:Uma expressão é uma declaração ainda não avaliada.Uma função é uma expressão, que depende de variáveis, associada à um nome.\nFunções podem ser entendidas como “parágrafos nomeáveis”.\nFunções podem ser entendidas como “parágrafos nomeáveis”.","code":""},{"path":"syntax-vars.html","id":"variáveis-1","chapter":"2 Sintaxe e Variáveis","heading":"Variáveis","text":"Também demos uma atenção extra ao conceito de variável:Variáveis são um objeto com um nome associado.Aprendemos os operadores que definem variáveis = e <-, e porque <- é preferível.Vimos características como x <- y <- 3 e regras de nomenclatura.Bem como alguns conceitos mais técnicos e avançados:dinâmica da memória R é pautada pelo conceito de copy--modify. R, um mesmo objeto pode ter ser referenciado mais de um nome. Modificar algum deles não modifica o objeto original, e sim copia-o, criando um novo objeto. Isso é, os objetos são copiados-após-mudanças.\nexceções são objetos com apenas uma referência, e ambientes, que usam modify--place (são modificados “lugar”).\nexceções são objetos com apenas uma referência, e ambientes, que usam modify--place (são modificados “lugar”).","code":""},{"path":"syntax-vars.html","id":"operadores-1","chapter":"2 Sintaxe e Variáveis","heading":"Operadores","text":"Por fim, apresentamos os operadores básicos, seu uso, e ordem de preferência. Foi dito que operadores são funções, apenas com sintaxe diferente.","code":""},{"path":"syntax-vars.html","id":"dicionário-de-funções","chapter":"2 Sintaxe e Variáveis","heading":"Dicionário de Funções","text":"Abaixo segue lista de funções vistas neste capítulo.","code":""},{"path":"syntax-vars.html","id":"referências","chapter":"2 Sintaxe e Variáveis","heading":"Referências","text":"referências principais deste capítulo são:“Advanced R” capítulo “2 - Names Values”, excluindo seções 2.4 e 2.6.“R Language” seções “2.1.3 - Language Objects” e “2.1.3 - Expression Objects”.“R Introduction” seções “2.1 - Vectors Assignment” e “2.2 - Vector Arithmetic”.“R Internals” seção “1.1 - SEXPs”.“R Help” os documentos de ajuda das funções aqui expostas.para outros temas não contidos aqui, mas fortemente relacionados com esse capítulo, vide Advanced R seções “2.4 - Object Size” e “2.6 - Unbinding Garbage Collector”.","code":""},{"path":"syntax-vars.html","id":"exercícios","chapter":"2 Sintaxe e Variáveis","heading":"Exercícios","text":"os exercícios usam variáveis de mesmo nome. Garanta que você está utilizando definições corretas. É necessário ver páginas de ajuda das funções. Rode ?nome_na_funcao console.","code":""},{"path":"syntax-vars.html","id":"sintaxe-1","chapter":"2 Sintaxe e Variáveis","heading":"Sintaxe","text":"Considere o código abaixo, e estilize seus componentes de acordo com sua natureza, e explique seu raciocínio, conectando com os conceitos vistos em aula.Fonte de (nomes de) variáveis em verde.Fonte de valores em laranja.Grifo de chamadas de funções em vermelho.","code":"\na <- 1\n2\na\nsum(a, 3)\nsum(a, 3) + a"},{"path":"syntax-vars.html","id":"variáveis-2","chapter":"2 Sintaxe e Variáveis","heading":"Variáveis","text":"Explique diferença entre o objeto 1 e cada uma das variáveis abaixo.Foi comentado que objetos mais complexos têm comportamentos diferentes com relação ao processo de definição , mas todos seguem uma característica geral. Com base nisso, o que você espera que ocorra com b após terceira linha de cada um dos código abaixo? Justifique, fazendo referência à essa tal característica geral.função list() cria uma lista, que é uma coleção de valores. O operador [[ seleciona um elemento dela. Aprenderemos esses conceitos nos capítulos seguintes.Leia página de ajuda da função make.names() para aprender regras completas de definição de nomes, sobre como o R converte nomes não sintáticos. Preveja qual será o resultado das chamadas abaixo.","code":"\n1\na <- 1\nb <- a\nc <- a + 1\nd <- b\ne <- 1\na <- 1\nb <- list(1, a)\na <- 2\na <- list(1, 2)\nb <- a\na[[2]] <- 3\nmake.names(\"\")\nmake.names(\"@\")\nmake.names(\"TRUE\")\nmake.names(\"`TRUE`\")\nmake.names(c(\"a\", \"a\", \"a\", \"b\", \"b\"), unique = TRUE)"},{"path":"syntax-vars.html","id":"operadores-2","chapter":"2 Sintaxe e Variáveis","heading":"Operadores","text":"Parta de um número qualquer x, por exemplo, x <- 5. Use os ensinados operadores para criar:Uma frase que retorne TRUE se x múltiplo de 2.Uma frase que retorne TRUE se x não múltiplo nem de 3, nem de 5.Uma frase que retorne TRUE se parte inteira da divisão de x por 4 é igual 2, ou se seu quadrado maior ou igual à 10.Liste ordem das ações executadas cálculo da expressão abaixo:","code":"\nx <- FALSE | !5.2 %% 2 * 7 * 4 - -3 <= 100 & TRUE"},{"path":"data-attrs.html","id":"data-attrs","chapter":"3 Tipos de Valores e Atributos","heading":"3 Tipos de Valores e Atributos","text":"","code":""},{"path":"data-attrs.html","id":"introdução-2","chapter":"3 Tipos de Valores e Atributos","heading":"3.1 Introdução","text":"Como vimos capítulo passado, tudo que existe R é um objeto. Eles são compostos de valores/dados e (potencialmente) atributos/metadados.Haverão dois aprendizados principais: () temos duas famílias de tipos, todos os valores “dia--dia” são vetores, e o resto são os poucos tipos internos R; (ii) diferença entre vetores atômicos e genéricos (listas); (iii) atributos são metadados, que alteram interação dos objetos com funções, mas não suas características básicas.Aprenderemos também tópicos mais concretos: () quais são os tipos de vetores atômicos; (ii) valores NA; (iii) coerção de tipos; (iv) como criar e combinar vetores; (v) o básico dos atributos nome e dimensão, bem como das classes mais comuns R.","code":""},{"path":"data-attrs.html","id":"famílias-de-valores","chapter":"3 Tipos de Valores e Atributos","heading":"3.2 Famílias de Valores","text":"Na descrição dos tipos de valores, o R também apresenta uma simplicidade muito interessante! Existem duas famílias de tipos de valores: os vetores, e o resto39.O resto são os tipos internos R. Os principais estão abaixo, e não existem muitos outros:Funções (closures), ambientes, promessas – serem estudadas capítulo 6.Expressões, símbolos, e chamadas de funções – serem estudadas capítulo 7.NULL, o objeto que denota ausência de valor – ser explicado neste capítulo.Os vetores são os tipos de valores que estamos mais acostumados lidar. Eles são divididos em dois: temos seis tipos de vetores atômicos, e um tipo de vetores genéricos (mais conhecidos como listas). Cada um será explicado em sua própria seção.Antes, um contexto geral. Em termos simplistas, na ciência da computação, um escalar é um objeto que que representa um único valor, uma unidade de valor. Uma coleção é um conjunto de valores. Os componentes de uma coleção são chamados de elementos.Quando todos seus elementos são mesmo tipo, falamos que uma coleção é atômica, caso contrário, é genérica. Muitas vezes, chamamos uma coleção atômica de vetor, e uma genérica de lista. R, listas também são referidas como vetores, e portanto existe nomenclatura “vetores atômicos” e “vetores genéricos”.","code":""},{"path":"data-attrs.html","id":"vetores-atômicos","chapter":"3 Tipos de Valores e Atributos","heading":"3.3 Vetores Atômicos","text":"","code":""},{"path":"data-attrs.html","id":"escalares-e-vetores-atômicos","chapter":"3 Tipos de Valores e Atributos","heading":"3.3.1 Escalares e Vetores Atômicos","text":"Vetores AtômicosUm vetor atômico é uma coleção de escalares de um mesmo tipo.R, um escalar é uma “coleção de tamanho um”, e portanto, todo escalar é um vetor atômico, não existe diferenciação real entre os dois.Para esclarece, vamos visualizar. Uma coleção (1, 3, 8)40 pode ser desenhada como três escalares conectados:Mas note que cada escalar tem sua própria “caixa”, estrutura ao redor é inseparável. Isto é, um escalar é coleção (1), não existe o número 1 “sem estar em uma coleção”.Adicionalmente, note que os resultados dos testes abaixo:o último teste usa o conceito de subsetting, que será explicado capítulo 4. função identical() é uma forma mais robusta de comparar objetos, ela compara tudo sobre os objetos, e não apenas seus valores.Por mais que estrutura não seja separável dos escalares, é possível ter vetores sem elementos. Eu gosto de entender esse fato de um ponto de vista prático: vezes queremos “contar pro R” que, futuro, teremos um vetor com conteúdo, então, presente, criamos um “placeholder”. Vide funções integer(), logical(), etc.","code":"\n1 == c(1) #> TRUE\nidentical(1, c(1)) #> TRUE\nidentical(c(1)[1], c(1)) #> TRUE"},{"path":"data-attrs.html","id":"tipos-de-vetores-atômicos","chapter":"3 Tipos de Valores e Atributos","heading":"3.3.2 Tipos de Vetores atômicos","text":"É intuitivo que existem diferentes categorias de dados de interesse, mas como foi falado, o conceito de tipo (de valor) é um conceito específico na ciência da computação. Lembre-se, o computador “entende” binário, e o que o R salva na memória computador são valores em binário.O que são os tipos, então? O R mantém informação sobre o que cada sequência representa, sobre seu tipo, e este tipo está associado à uma “receita”/“blueprint” de como interpretar essa sequência. Um exemplo hipotético, seria um tipo double, que indica que uma sequência de 64 bits deve ser interpretada como os 32 primeiros bits representando parte inteira de um número, e os 32 últimos, parte decimal.Tipos de vetores atômicosOs vetores atômicos podem ser de seis tipos, mas quatro são os principais:Logical são os dados booleanos, podem ser TRUE ou FALSE. Podem ser abreviados para T e F 41.Characters são os dados de texto (strings).Integers são números inteiros, e são escritos com um “L” fim: 12L.Doubles são os números decimais, podem ser escritos na forma decimal 1.245, científica 1.23e4, ou hexadecimal 0xadfe.\nValores especiais: Inf, -Inf, e NaN (“number”, usado em indefinições matemáticas).\nValores especiais: Inf, -Inf, e NaN (“number”, usado em indefinições matemáticas).Adicionalmente, existe raw, para dados em binário; e complex, para números complexos. Por fim, existe NULL que, como dito, não é um vetor, mas pode ser entendido como “ausência de dado”/“vetor de tamanho zero”.","code":""},{"path":"data-attrs.html","id":"combinando-vetores","chapter":"3 Tipos de Valores e Atributos","heading":"3.3.3 Combinando Vetores","text":"função c() combina (daí o nome) vetores em um mais longo. Ela serve com atômicos ou genéricos, mas por enquanto, vamos usá-la com atômicos: c(TRUE, FALSE), c(1, 3.5, 1.23e4).Quando usada com vetores atômicos, c() coage os inputs escalares mesmo tipo, resultando em um outro atomic vector.Existe uma ordem de prioridade: se houver um character, tudo vira character, fora isso, tudo vira double, depois, integer, e por fim, logical. Veja o exemplo abaixoFunções que pedem argumentos de um mesmo tipo normalmente os coagem caso eles sejam diferentes, e isso é causa comum de erros.Note duas coerções diferentes abaixo:Lembre-se que um vetor atômico é uma coleção de escalares, não aceita elementos com tamanho maior que um.","code":"\nc(1, 2, \"a\", \"b\") #> c(\"1\" \"2\" \"a\" \"b\")\nc(c(1, 2), c(3, 4)) #> c(1, 2, 3, 4)"},{"path":"data-attrs.html","id":"funções-úteis","chapter":"3 Tipos de Valores e Atributos","heading":"3.3.4 Funções Úteis","text":"Podemos utilizar função typeof() para descobrir o tipo de um objeto.Para testar se um objeto é de um tipo específico, existem funções .logical(), .integer(), .double(), e .character(). Existem também .vector(), .atomic(), e .numeric(), mas são imprevisíveis.Na seção de atributos, vamos ver como podemos criar classes em cima dos tipos básicos. Essa complexidade torna os testes de tipo menos confiáveis em alguns contextos, por isso, recomendo usar variações rlang::is_logical() e cia. pacote rlang42, que tem uma relação mais confiável de 1-pra-1 com typeof().Podemos transformar o tipo de um vetor com .logical(), .integer(), .double(), ou .character(). Se você um usuário avançado, leia sobre o pacote vctrs.função length() retorna o tamanho, o número de elementos, de um vetor. Ela tem algumas peculiaridades, mas por enquanto, vamos deixar isso de lado.função str() retorna uma descrição mais detalhada de um objeto, com seu tipo, valores, e atributos. Especialmente como instrumento educacional, ela é sua melhor amiga. Abuse-.","code":""},{"path":"data-attrs.html","id":"valores-na","chapter":"3 Tipos de Valores e Atributos","heading":"3.3.5 Valores NA","text":"Todos os tipos explicados assumem um valor especial, o “valor desconhecido”: NA, “non aplicable”.melhor maneira de entender um valor especial é pensar que ele é um conceito. Isto é, o Inf é o valor double onde x + Inf #> Inf, x > Inf #> FALSE, etc., por construção.O NA não é diferente, ele representa o conceito de “não sei”. Operações que dependam de um valor desconhecido, intuitivamente, também retornam um valor que não se conhece: 1 + NA #> NA; NA == NA #> NA43. Para checar se um valor é NA, use .na().Por trás dos panos, existe um NA diferente para cada tipo de vetor atômico (NA_integer_, etc.). Isso acontece por conta das leis de coerção. Um valor desconhecido numérico pode ser coagido para um valor desconhecido de texto. Essa ideia será explorada nos exercícios.","code":""},{"path":"data-attrs.html","id":"listas","chapter":"3 Tipos de Valores e Atributos","heading":"3.4 Listas","text":"","code":""},{"path":"data-attrs.html","id":"definição-listas","chapter":"3 Tipos de Valores e Atributos","heading":"3.4.1 Definição: Listas","text":"Vimos que vetores atômicos não aceitam elementos de tipos diferentes, nem elementos não-escalares, de length maior que 1. Porém, o R permite coleções diferentes, como (1, \"\", (1, 2, 3), TRUE, 1)44.Vetores Genéricos/ListasUma lista é uma coleção de objetos. Qualquer objeto.\nNote definição mais flexível/genérica.\nUma lista é um objeto, portanto listas podem conter outras listas.\nNote definição mais flexível/genérica.Uma lista é um objeto, portanto listas podem conter outras listas.Listas tem seu próprio tipo, list.Para criar uma lista, usamos função list(). listas também tem suas variantes .*() e .*().Lembre que com vetores atômicos, “caixa”, estrutura ao redor dos elementos não era separável. Agora temos essa diferenciação! lista list(1) não é um escalar, mas sim uma lista que contém um escalar. Esta é uma diferença importante, e será relevante capítulo 4. Para esclarecer, vamos visualizar.Veja o código e representação visual de cada vetor ao lado.capítulo anterior, comentei rapidamente que, por trás dos panos, listas são coleções de referências objetos, e não coleções de objetos (diretamente). Veja mais em Advanced R seção 2.3.3. Por conta disso, list(x, x) ocupa bem menos que o dobro espaço de list(x)","code":"\nv1 <- c(1, 2, 3)\n\nv2 <- list(1, 2, 3)\n\nv3 <- list(1, c(2, 3))\n\nv4 <- list(1, list(2, 3))\n\nv5 <- list(1, list(c(2, 3)))"},{"path":"data-attrs.html","id":"manipulação-listas","chapter":"3 Tipos de Valores e Atributos","heading":"3.4.2 Manipulação Listas","text":"Como listas podem conter outros vetores de tamanhos variados, inclusive outras listas, podem ter formatos bastante complexos.Falarei sobre algumas manipulações comuns, mas de fato aprendê-las, ficar para os exercícios.","code":""},{"path":"data-attrs.html","id":"combinando-listas","chapter":"3 Tipos de Valores e Atributos","heading":"3.4.2.1 Combinando listas","text":"função list() cria uma lista envolta dos inputs, enquanto função c() (quando usada com alguma lista), concatena Listas.Lembre-se, função c() coage os inputs para um tipo comum, e list está acima de character na ordem de prioridade.","code":""},{"path":"data-attrs.html","id":"diminuindo-a-hierarquia-de-listas","chapter":"3 Tipos de Valores e Atributos","heading":"3.4.2.2 Diminuindo a Hierarquia de Listas","text":"Transformar list(1, list(2, 3)) em list(1, 2, 3).Transformar list(1, 2, 3) em c(1, 2, 3).Ou, os dois ao mesmo tempo: list(1, list(2, 3)) em c(1, 2, 3).Para isso, podemos usar função unlist(), que por padrão, remove todas camadas de hierarquia de uma lista (caso 3). Para o caso 1, podemos usar o argumento recursive = FALSE45. funções purrr::list_flatten() e purrr::list_c() são opções mais consistentes, com menos resultados inesperados. primeira funciona para o caso 1, e segunda, para o caso 2.função c() pode ser utilizada para, ao mesmo tempo que combina, simplificar complexidade de listas, via o argumento recursive = FALSE. Esse comportamento pode ser útil, mas é confuso e inesperado, prefira ser explícito com primeiro combinar, e depois simplificar.","code":""},{"path":"data-attrs.html","id":"transpondo-listas","chapter":"3 Tipos de Valores e Atributos","heading":"3.4.2.3 Transpondo listas","text":"função purrr::transpose() executa seguinte operação:","code":"\npurrr::transpose(list(c(1, \"a\"), c(2, \"b\"), c(3, \"c\")))\n#> list(c(1, 2, 3), c(\"a\", \"b\", \"c\"))"},{"path":"data-attrs.html","id":"atributos","chapter":"3 Tipos de Valores e Atributos","heading":"3.5 Atributos","text":"Os vetores podem carregar mais informações que apenas os valores de seus elementos, eles podem carregar metadados/atributos, dados sobre o vetor e seus elementos em si.Praticamente todos os objetos R podem carregar atributos, mas é raro isso ser útil. Vamos focar em vetores.Atributos não afetam “essência” de um vetor, seu dado ou seu tipo, mas podem afetar como ele interage com funções.Pode-se criar atributos livremente, mas alguns são mais comumente encontrados na natureza:names, um vetor character, que nomeia cada elemento de um vetor.dim (diminutivo de dimensions), um vetor de inteiros, que reorganiza vetores em matrizes e arrays (em termos simplistas, “matrizes multidimensionais”).class, um vetor character, que indica classe de um vetor, um outro sistema de “tipagem” de objetos, construído em cima dos tipos.","code":""},{"path":"data-attrs.html","id":"conceitos-básicos","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.1 Conceitos Básicos","text":"Algumas funções relacionadas à atributos:atributes() retorna uma lista com os atributos de x.attr(x, \"attr\") retorna o valor atributo \"attr\". Pode ser utilizada para alterar atributos também.structure(x, \"attr\" = 1 + 1) adiciona o atributo \"attr\" em x.str() como já explicado, retorna uma visualização de x incluindo seus atributos.Os atributos principais tem funções dedicadas: names() e unname(), dim(), class(), unclass(). Mas cuidado com class(), veremos diante que ela pode retornar uma classe implícita. maneira mais confiável de checar um atributo é com attr().Atributos são objetos como quaisquer outros, que estão ligados ao objeto “principal” via referências. Como qualquer outro objeto, salvo exceções, são copied--modified. Similarmente, alterar atributos de um objeto o modifica, o que desencadeia cópia objeto, se necessário.","code":""},{"path":"data-attrs.html","id":"nomes","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.2 Nomes","text":"Nomear um vetor o torna mais compreensível. Adicionalmente, fica mais fácil de fazer referências à seus elementos, veremos isso capítulo 4.Podemos nomear um vetor de várias formas:Na criação objeto: x <- c(= 1, b = 2, c = 3)46.Com names(x) <- c(\"\", \"b\", \"c\"), ou usando attr() ou structure().x <- setNames(x, c(\"\", \"b\", \"c\")). Considere também função purrr::set_names().Podemos remover nomes com:names(x) <- NULL47, ou usando attr() ou structure().x <- unname(x).x <- setNames(x, NULL).É fácil ver como estrutura básica fica inalterada. Tente transpor essa ideia para os outros atributos mais complexos seguir.","code":""},{"path":"data-attrs.html","id":"dimensões","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.3 Dimensões","text":"Muitas vezes, nossos dados tem uma lógica de organização como de uma matriz, com linhas e colunas. Algumas vezes, precisamos até de matrizes multi-dimensionais.","code":""},{"path":"data-attrs.html","id":"criação-de-matrizes-e-arrays","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.3.1 Criação de Matrizes e Arrays","text":"Um vetor com o atributo dimensão é um vetor que deve ser interpretado como matriz:Ou como array:O dado é o mesmo, e veremos exemplos de como podemos tratar esse objetos exatamente como vetores, ignorando completamente suas dimensões. Mas, ao mesmo tempo, podemos tratar esses objetos como matrizes ou arrays, e fazer operações matriciais com eles. Use função str()!Ambos podem ser criados diretamente, com funções matrix() e array():matrix(m1, nrow = 2, ncol = 3).array(a1, c(2, 3, 2)).Também podemos criar e remover dimensões com attr() ou structure().Note que utilizei vetores atômicos nos exemplos, mas listas também podem ter dimensões. Iremos explorar isso nos exercícios.Note que podemos ter matrizes com apenas uma linha ou uma coluna, ou arrays com apenas uma dimensão. Eles são diferentes de vetores sem dimensão (NULL-dimensionais), e vão interagir diferentemente com funções (ex: matemática de matrizes).","code":"\nm1 <- c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE)\ndim(m1) <- c(2, 3)\nm1\n\n#>       [,1] [,2]  [,3]\n#> [1,]  TRUE TRUE FALSE\n#> [2,] FALSE TRUE  TRUE\na1 <- c(1:8)\ndim(a1) <- c(2, 2, 2)\na1\n\n#> , , 1\n#>\n#>      [,1] [,2]\n#> [1,]    1    3\n#> [2,]    2    4\n#>\n#> , , 2\n#>\n#>      [,1] [,2]\n#> [1,]    5    7\n#> [2,]    6    8"},{"path":"data-attrs.html","id":"funções-úteis-1","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.3.2 Funções Úteis","text":"Como atributos não alteram estrutura básica, funções para vetores tem generalizações para matrizes e arrays:Tabela 3.1:  Funções para Vetores, Matrizes e Arrays.Note que adicionar dimensões gerou algumas possibilidades:Um tamanho e um atributo de nome para cada dimensão.Maneiras diferentes de combinar vetores: por linhas, por colunas, ou por outras dimensões.Operação de transposição: com t() e aperm().Mais diferenças surgirão capítulo 4, onde veremos como acessar elementos de vetores com e sem dimensões.Entender que matrizes e arrays são, em sua base, vetores atômicos, será muito útil para prever como funções vão agir sobre eles.funções .vector(), .matrix(), e .array() devem gerar estranheza, já que não à nenhum tipo relacionado à essas coisas. Nos exercícios, veremos exatamente o que essas funções estão testando.","code":""},{"path":"data-attrs.html","id":"classes","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.4 Classes","text":"Outro atributo importante é class, que permite criação de vetores diferenciados, criados em cima dos tipos básicos. Esse é o conceito vindo da Programação Orientada ao Objeto (OOP), e objeto aqui não é o termo genérico que venho usando, mas sim “uma instância de uma classe”.Por que criar um segundo sistema de “tipagem”? Porque classes são mais flexíveis, não se precisa criar uma “receita” para interagir com memória computador. Qualquer pessoa pode criar uma classe, e colher frutos da programação orientada ao objeto.Falaremos mais sobre o sistema de OOP R capítulo 7, mas o principal se entender é que funções irão agir de modo diferente, depender da classe de seu argumento.Classes podem ser criadas livremente. Abaixo vão algumas muito presentes R:factor são utilizados para dados que podem assumir categorias pré definidas. São construídos em cima de integers.Date, POSIXct, e difftime são para datas. São construídos em cima de doubles.data.frame e tibble são para tabelas de dados. São construídos em cima de lists.Entender que classes são construídas em cima dos tipos será muito útil para prever como funções vão agir sobre eles.muitas vezes queremos esse comportamento de classes, mas sobre objetos mais “elementares”, como vetores “crus” e matrizes. Por conta disso, o R assume implicitamente classe de um objeto, via função class(), mesmo que ele não tenha o atributo classe.","code":""},{"path":"data-attrs.html","id":"factors","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.4.1 Factors","text":"Factors tem o atributo class como \"factor\", e um atributo levels que define os valores/categorias possíveis.Cuidado, factors comumente geram erros: parecem strings, mas não são. Aplicar manipulações de texto à eles costuma dar errado. Deve-se manipular seus níveis, ou transformar o factor em texto antes. Adicionalmente, vide também stringsAsFactors = sigh.Também existem os ordered factors, onde indicamos uma ordem para os levels, e costumam ser usados em funções de modelagem e visualização. Vide ordered().","code":"\nfactor(c(\"m\", \"f\", \"f\", \"m\"), levels = c(\"m\", \"f\", \"o\"))\n#> [1] m f f m\n#> Levels: m f o"},{"path":"data-attrs.html","id":"datas","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.4.2 Datas","text":"Dates: são um double com o atributo class \"Date\". Por trás dos panos são o número de dias entre 01/01/1970 e data em questão. Para criar, use função .Date().Date-times: são um double com o atributo class \"POSIXct\"48. Por trás dos panos são o número de segundos entre 01/01/1970 e hora em questão. Para criar, use função .POSIXct().Durations: são um double com o atributo class \"difftime\", que conta distância entre duas datas. Têm o atributo \"units\" que indica como o valor deve ser interpretado. Para criar, use função .difftime().Essa classe de vetores são bem complexos, existem muitas complexidades como fusos horários, conversão de formatos, e operações matemáticas. Vou deixar para explicar como manipular essa classe de dado capítulo 14.","code":""},{"path":"data-attrs.html","id":"data-frames","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.4.3 Data Frames","text":"Um dataframe é uma representação de uma tabela de dados. Basicamente, uma é uma lista nomeada de vetores, normalmente atômicos, todos de mesmo tamanho. Isto é, similar :Como sempre, ter isso em mente ajudará muito transpor o conhecimento sobre listas para dataframes. Adicionalmente, dataframes tem, implicitamente, dimensões. Portanto, eles apresentarão, muitas vezes, ambos os comportamentos, de lista e de matriz.Eles tem os atributos names/colnames (nomes das “colunas”), row.names (nomes das “linhas”). can accessed rownames() colnames(). Um data frame tem nrow() linhas, e ncol()/length() colunas.Data frames são criados com função data.frame(), e tem class \"data.frame\". Também existem funções .data.frame() e .data.frame().Uma coluna de um data frame pode também ser uma matriz/array (se o número de linhas coincidir), ou uma lista (se o número de elementos coincidir)49. O uso disso é raro.","code":"\nlist(\n  coluna1 = c(1, 2, 3),\n  coluna2 = c(\"c\", \"b\", \"d\"),\n  coluna3 = c(TRUE, FALSE, NA)\n)"},{"path":"data-attrs.html","id":"tibbles","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.4.4 Tibbles","text":"Um Tibble é um sucessor dataframe, trazido pelo pacote tibble.Tibbles tem classe c(\"data.frame\", \"tbl_df\"). São “preguiçosos e grosseiros: fazem menos e reclamam mais”:Não geram vetores maiores partir de vetores menores (data.frame(x = 1:4, y = 1:2)).Não mudam nomes não sintáticos.Não aceitam rownames, vindo da filosofia que “metadata data”.Um subset de um tibble sempre é um tibble. Mais sobre isso capítulo 4.Não tem matching parcial nos nomes de colunas50.Permitem referenciar colunas na hora da criação – tibble(x = 1:4, y = 2*x).Tem uma melhor visualização console.","code":""},{"path":"data-attrs.html","id":"complemento-1","chapter":"3 Tipos de Valores e Atributos","heading":"Complemento","text":"","code":""},{"path":"data-attrs.html","id":"recapitulando-1","chapter":"3 Tipos de Valores e Atributos","heading":"Recapitulando","text":"","code":""},{"path":"data-attrs.html","id":"tipos-de-valores","chapter":"3 Tipos de Valores e Atributos","heading":"Tipos de Valores","text":"Existem duas famílias de tipos, os vetores e o resto. Veja figura 3.1.\nTodos os valores “dia--dia” são vetores. O resto são os tipos internos R, e serão estudados futuro.\nTodos os valores “dia--dia” são vetores. O resto são os tipos internos R, e serão estudados futuro.Vetores atômicos são coleções de escalares de um mesmo tipo. Listas (vetores genéricos) são coleções de objetos.Existem seis tipos de VA, e os quatro principais são: logical, character, integer e double. Listas tem tipo list.Valores especiais: NA, Inf, -Inf, e NaN. NULL é um tipo de objeto especial, que indica ausência de valor.\nFigura 3.1: Descrição dos tipos de dados.\n","code":""},{"path":"data-attrs.html","id":"manipulações-básicas","chapter":"3 Tipos de Valores e Atributos","heading":"Manipulações Básicas","text":"Combinamos qualquer vetor com c(). Para listas, temos também list(). c() coage os inputs para um mesmo tipo.Vimos funções .* (e rlang::is_*) e .* para testar e coagir tipos.Passamos rapidamente por manipulação de listas listas com unlist(), purrr::list_flatten(), e purrr::list_c(). Também vimos purrr::transpose().","code":""},{"path":"data-attrs.html","id":"atributos-1","chapter":"3 Tipos de Valores e Atributos","heading":"Atributos","text":"Atributos são metadados, que alteram interação dos objetos com funções, mas não suas características básicas.Atributos comuns são names, dim, e class.Classes criam um segundo sistema de tipagem, em cima dos tipos básicos. Classes comuns são factor, Date, POSIXct, data.frame, e tibble.Vimos como visualizar e alterar os atributos de um objeto.","code":""},{"path":"data-attrs.html","id":"dicionário-de-funções-1","chapter":"3 Tipos de Valores e Atributos","heading":"Dicionário de Funções","text":"Abaixo segue lista de funções vistaSs neste capítulo.","code":""},{"path":"data-attrs.html","id":"referências-1","chapter":"3 Tipos de Valores e Atributos","heading":"Referências","text":"referências principais deste capítulo são:“Advanced R” capítulo “3 - Vectors”.“R Language” seções “2.1.1 - Vectors”, “2.1.2 - Lists”, “2.1.6 - NULL”, “2.2 - Attributes”, e “2.3 - Special compound objects”.“R Introduction” capítulos “2 6”.“R Internals” seção “1.3 - Attributes”.“R Help” os documentos de ajuda das funções aqui expostas.","code":""},{"path":"data-attrs.html","id":"exercícios-1","chapter":"3 Tipos de Valores e Atributos","heading":"Exercícios","text":"os exercícios usam variáveis de mesmo nome. Garanta que você está utilizando definições corretas. É necessário ver páginas de ajuda das funções. Rode ?nome_na_funcao console.","code":""},{"path":"data-attrs.html","id":"tipos-de-valores-1","chapter":"3 Tipos de Valores e Atributos","heading":"Tipos de Valores","text":"Vimos que existem vários tipos de valores. Vamos primeiro falar sobre como se testa por um tipo, e, na próxima questão, como se convertem tipos.Contei rapidamente que existem funções .*. Vamos estudar um pouco mais sobre elas. O objetivo não é decorar funções e suas propriedades, mas sim exercitar habilidade de entender qual operação está realmente sendo feita, e deixar de tratar funções como “caixas pretas”.Qual diferença entre .vector() e rlang::is_vector()? .vector() está de acordo com definição de vetor vista em aula?.numeric() não testa se um elemento é tipo double ou integer, o que ela testa?O número NA é finito ou infinito? Como funções .finite() e .infinite() funcionam?Dada uma variável x, escreva uma expressão que cheque se x é exatamente igual ao objeto TRUE. Após escrever sua expressão (!!) compare seu resultado com função isTRUE().Falamos sobre como o R converte tipos de valores em outros, para poder juntá-los em um vetor atômico, ou realizar uma operação que precise de tipos comuns. Essa coerção é feita pelas funções .*. Esse é um tema muito importante, mas que vimos apenas de passagem. Vamos explorar alguns casos abaixo.Porque 1 < FALSE é verdadeiro?funções .* são pouco estritas, e tentam adivinhar resultados (como vocês já sabem que o R gosta de fazer). Com base nisso, porque 1 == \"1\" é verdadeiro? Compare com rlang::as_integer(\"1\").Agora com operações aritméticas: 1 + \"2\" funciona? E TRUE + 1? Qual é regra?Ocorre coerção na operação c(list(1, 2), 3)? Busque na página de ajuda ?c() pela ordem completa de coerção, e use para justificar sua resposta.","code":""},{"path":"data-attrs.html","id":"vetores","chapter":"3 Tipos de Valores e Atributos","heading":"Vetores","text":"Relembre definição de vetores atômicos e de listas. Seguindo convenção capítulo, desenhe os objetos abaixo.Um vetor ‘complicado’: list(1, list(c(2, 3), c(4, 5)).Vetores atômicos: c(1, 2), c(1), o primeiro elemento deste, e o primeiro elemento daquele. Qual diferença entre os três últimos?Vetores vazios: list(), NULL, e integer(0). Qual length de cada um dos objetos? Qual intuição desse resultado? Você deve ter tido dificuldade em desenhar integer(0), vamos trabalhar nisso. Pense sobre list(), como você descreveria seu desenho, você desenhou o que de uma lista? Essa coisa é separável em um vetor atômico? Conclua: é possível desenhar integer(0)? Qual diferença entre NULL e integer(0)?Vimos que os vetores atômicos são unidade básica de dados R, e que eles podem ser de seis tipos (sendo quatro os mais importantes). Vimos também que função c() combina vetores. Com base nisso, responda questões abaixo, sobre NA e NULL:O vetor atômico c(1, NULL) pode existir? Porque?Qual é o tipo segundo elemento de c(1, Inf)?Qual é o tipo segundo elemento de c(TRUE, NA)? E de c(\"1.5\", NA)? O que isso te faz concluir sobre natureza de NA? Alguma coerção está acontecendo segundo caso?Falamos rapidamente sobre manipulação de listas. Considere os objetos x e y, e escreva expressões que gerem cada um dos itens em seguida. Ao final, discuta diferenças de purrr::list_flatten(), unlist(), e purrr::list_c().list(list(list(1, 10), list(2, 20)), 1)list(list(list(1, 10), list(2, 20), 1))list(list(list(1, 10), list(2, 20), list(1)))list(1, 10, 2, 20)c(1, 10, 2, 20)list(list(1, 2), list(10, 20))","code":"\nx <- list(list(1, 10), list(2, 20))\ny <- 1"},{"path":"data-attrs.html","id":"atributos-2","chapter":"3 Tipos de Valores e Atributos","heading":"Atributos","text":"Vamos estudar com mais calma os factors.O que acontece com um factor ao alterar seus níveis?O que o código abaixo faz? como f2 e f3 diferem de f1?O que faz função table()? Que objeto retorna? Qual seu tipo? Quais seus atributos? Como sua dimensão muda ao adicionar variáveis para tabular?Vamos estudar com mais calma os .dataframesPode haver um data frame com zero linhas? E zero colunas?O que ocorre se você definir rownames não únicos?Se df é um data frame, o que é t(df)? Porque? E t(t(df))?O que .matrix() faz quando aplicada um data frame com colunas de tipos diferentes? Como isso difere de usar data.matrix()?Estude o objeto abaixo. colunas tem mesma length? O que elas tem igual? Essa é uma medida implícita, ou é um atributo real da coluna?Outros exercícios sobre atributos que não sabia onde colocar :).Como setNames() funciona? Como unname() funciona? Olhe o código fonte\nMuitas funções .* não estão testando tipos dos objetos, e sim classes. Qual é o método que .data.frame() e tibble::is_tibble() utilizam para tal? E .array() e .matrix()? Toda matriz é um array?Explique com detalhe o que função identical() faz, e quais suas opções.","code":"\nf1 <- factor(letters)\nlevels(f1) <- rev(levels(f1))\nf2 <- rev(factor(letters))\nf3 <- factor(letters, levels = rev(letters))\nx <- data.frame(a = 1:2)\nx$b <- c(matrix(1, 1, 1), matrix(2, 1, 1))\nx$c <- list(matrix(1, 1, 1), matrix(2, 1, 1))\nx$d <- data.frame(c1 = factor(c(\"a\", \"b\")))"},{"path":"subset.html","id":"subset","chapter":"4 Subsetting","heading":"4 Subsetting","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"subset.html","id":"introdução-3","chapter":"4 Subsetting","heading":"4.1 Introdução","text":"Referência básica: Advanced R (2e) cap. 4 cap. 5.Na aula de hoje, aprenderemos operações mais concretas, mas muito essenciais.Haverão três aprendizados principais:() como funciona o sistema de subsetting, e sua relação com os tipos de valores;(ii) ferramentas de control flow R;(iii) o sistema de condições e suas ferramentas.Para os exemplos, considere:","code":"\nx <- c(1.3, 7.4, 6.0, 5.9)\nm <- matrix(1:9, nrow = 3, ncol = 3)\ncolnames(m) <- c(\"A\", \"B\", \"C\")\ndf <- as.data.frame(m)\nl <- list(\"a\" = 1:3, \"b\" = \"oi\", \"c\" = 4:6)"},{"path":"subset.html","id":"subset---operador","chapter":"4 Subsetting","heading":"4.2 Subset - Operador [","text":"","code":""},{"path":"subset.html","id":"operador","chapter":"4 Subsetting","heading":"4.2.1 Operador [","text":"O operador [ é utilizado após um vetor x[...], para selecionar um subconjunto de seus elementos.O conteúdo em ... pode tomar seis formas.","code":""},{"path":"subset.html","id":"operador-com-vetores-atômicos","chapter":"4 Subsetting","heading":"4.2.2 Operador [ Com Vetores Atômicos","text":"Seis ‘insumos’ para selecionar com [:A1. Inteiros positivos: retornam elementos nas posições:x[1] #> 1.3.x[1:3] #> 1.3 7.4 6.0.x[c(1,3)] #> 1.3 6.0.A2. Inteiros negativos: retornam todos os elementos menos os das posições.x[-c(1,3)] #> 7.4 5.9Obs: decimais são truncados x[1.7] == x[1], e factors ‘viram’ inteiros.A3. Vetores lógicos: retornam os elementos nas posições onde tem-se TRUE’s.x[c(TRUE, TRUE, FALSE, FALSE)] #> 1.3 7.4.A4. Vetores de texto: retornam os elementos com os nomes escolhidos.c(= 1, b = 2, c = 3)[c(\"\", \"c\")] #> 1 3.Reciclagem: para relacionar vetores de tamanhos diferentes, o R multiplica o tamanho menor, se múltiplo maior: x[c(TRUE, FALSE)].A5. Nada: x[] retorna o vetor original.Será relevante para matrizes, e para substituir o conteúdo, deixando estrutura intacta.A6. Zero: retorna um vetor de tamanho 0.Note que 1. e 4. podem reordear um vetor x[c(1, 3, 2)], bem como retornar um único elemento.","code":""},{"path":"subset.html","id":"operador-com-matrizes-e-arrays","chapter":"4 Subsetting","heading":"4.2.3 Operador [ Com Matrizes e Arrays","text":"Com matrizes (vetores com dimensão), existem três ‘métodos’:M1. Múltiplos vetores: um vetor para cada dimensão:m[c(TRUE, FALSE, TRUE), c(\"B\", \"\")].Um vetor omisso retorna todos os ‘elementos da dimensão’: [, c(1, 3)].Para arrays, use um argumento para cada dimensão [1:2, 2, , 4].M2. Vetor único: como matrizes são vetores, podemos tratá-las como tal:m[5:7] elemento 5 até o 7 (ordem é “column-major”).Podemos usar um vetor lógico aqui. E, como dimensão é um mero meta-dado, uma matriz lógica.M3. Matrizes seletoras: onde cada coluna é uma dimensão, e cada linha um elemento quisto:m[rbind(c(1,1), c(3,1), c(2,4))].Para arrays, precisamos de três ou mais colunas.","code":""},{"path":"subset.html","id":"operador-com-listas-e-dataframes","chapter":"4 Subsetting","heading":"4.2.4 Operador [ Com Listas e Dataframes","text":"Com listas, não temos nenhuma diferença. [ sempre retorna uma lista, mesmo ao selecionar um único elemento.E para data frames? O que df[1:2] deve retornar?E df[1:2, ]? É “natural” que esses métodos coexistam?Com dataframes, que são uma ‘lista com cara de matriz’, ambos os métodos existem.","code":""},{"path":"subset.html","id":"operador-e-simplificação","chapter":"4 Subsetting","heading":"4.2.5 Operador [ e Simplificação","text":"O operador [ simplifica dimensão resultado.Em matrizes/arrays, dimensões de length 1 são desfeitas:\nm[1,], e m[,1]. Ou também m[1:9].\nm[1,], e m[,1]. Ou também m[1:9].Ou ao selecionar uma única coluna de um dataframe ‘modo matriz’ df[..., 2].\nMas selecionar linhas, mais de uma coluna, ou pelo ‘modo elemento’, mantêm dimensão.\nMas selecionar linhas, mais de uma coluna, ou pelo ‘modo elemento’, mantêm dimensão.Isso é controlado pelo argumento drop = TRUE operador. Podemos alterá-lo: df[1, , drop = FALSE].Tibbles tem drop = FALSE por padrão, sempre retornando outra tibble/nunca simplificando (alá preguiça).","code":""},{"path":"subset.html","id":"subset---operador-1","chapter":"4 Subsetting","heading":"4.3 Subset - Operador [[","text":"","code":""},{"path":"subset.html","id":"operador-1","chapter":"4 Subsetting","heading":"4.3.1 Operador [[","text":"Lembre que, em listas, [ sempre retorna uma lista – retorna o(s) elemento(s) e ‘estrutura em volta’.Para retornar apenas um (único) elemento, usamos os operadores [[...]] ou $....Qual deve ser o resultado de x[1] == x[[1]]? Porque?Pode ser útil usar [[ mesmo assim?","code":""},{"path":"subset.html","id":"operador-com-listas","chapter":"4 Subsetting","heading":"4.3.2 Operador [[ Com Listas","text":"Dois ‘insumos’ para selecionar com [[:L1. Um escalar inteiro: selecionando o elemento pelo índide.L2. Um escalar string: selecionando pelo nome.segundo caso, podemos usar abreviação l$, lugar de l[[\"\"]].Obs:Selecionar com um vetor seleciona recursivamente na lista, x[[c(1, 2)]] é similar à x[[1]][[2]].$ faz matching parcial nos nomes, use options(warnPartialMatchDollar = TRUE).","code":""},{"path":"subset.html","id":"subset---seleções-erradas-e-assignment","chapter":"4 Subsetting","heading":"4.4 Subset - Seleções Erradas e Assignment","text":"","code":""},{"path":"subset.html","id":"seleções-erradas","chapter":"4 Subsetting","heading":"4.4.1 Seleções Erradas","text":"E se selecionarmos um elemento que não existe? resposta é suco de R:Obs: o comportamento é o mesmo com ’x’s de tamanho zero.Não é importante decorar essa matriz, mas note:[ é mais permissivo, retorna “nada” em vez de um erro.\nCom -Int, retorna x, faz sentido.\nO que pode representar “nada” em listas? E em atômicos?\nCom -Int, retorna x, faz sentido.O que pode representar “nada” em listas? E em atômicos?[[ é menos permissivo, retorna erro em vez de nada.\nMas com listas, temos duas exceções.\nMas com listas, temos duas exceções.O que significa selecionar com NA? Em qual dos tipos de conteúdo ele se encaixa?Para lidar com essas inconsistências, existem seguintes funções:Para [: purrr::keep_at(), vctrs::vec_slice.Para [: purrr::pluck(), purrr::chuck().","code":""},{"path":"subset.html","id":"assingment","chapter":"4 Subsetting","heading":"4.4.2 Assingment","text":"Todos os operadores de subset podem ser combinados com <-: x[] <- ....x[[]] <- NULL remove o item de uma lista, x[] <- list(NULL) adiciona um elemento NULL.Subsetar com nada seleciona o ‘conteúdo’ de um objeto, e pode ser combinado com assignment para manter estrutura inalterada:","code":"\ndf[] <- lapply(df, as.integer) # df se mantem um dataframe\ndf <- lapply(df, as.integer) # df vira uma lista"},{"path":"subset.html","id":"control-flow---condicionais","chapter":"4 Subsetting","heading":"4.5 Control Flow - Condicionais","text":"","code":""},{"path":"subset.html","id":"control-flow","chapter":"4 Subsetting","heading":"4.5.1 Control Flow","text":"ferramentas de control flow são aquelas que alteram ordem de execução de um dado código.R, temos dois grupos principais:Choices, com , else, switch(), e ifelse()Loops, com repeat, , e ","code":""},{"path":"subset.html","id":"if-e-else","chapter":"4 Subsetting","heading":"4.5.2 If e Else","text":"Podemos criar uma expressão que apenas é avaliada se uma certa condição verdade. Se não , podemos complementar com expressões auxiliares:","code":"\nx <- 60\nif (x > 90) {\n  \"A\"\n} else if (x > 80) {\n  \"B\"\n} else if (x > 50) {\n  \"C\"\n} else {\n  \"F\"\n}"},{"path":"subset.html","id":"if-e-else-1","chapter":"4 Subsetting","heading":"4.5.3 If e Else","text":"Características gerais:condição deve gerar TRUE ou FALSE (os escalares). Outras coisas geram erros.condição deve gerar TRUE ou FALSE (os escalares). Outras coisas geram erros.Podemos escrever essas expressões em uma linha, sem “{”.Podemos escrever essas expressões em uma linha, sem “{”.Podemos utilizá-las para assinalar valores: x <- (TRUE) 1 else 2.\nSe não houver nenhum else, retorna um NULL.\nPodemos utilizá-las para assinalar valores: x <- (TRUE) 1 else 2.Se não houver nenhum else, retorna um NULL.Mais pra fente, veremos que é uma função! `(cond, expr1, expr2)`.Mais pra fente, veremos que é uma função! `(cond, expr1, expr2)`.","code":""},{"path":"subset.html","id":"if-e-else-vetorizado","chapter":"4 Subsetting","heading":"4.5.4 If e Else Vetorizado","text":"função ifelse() funciona para um vetor de condições, diferentemente de , que exigia um único valor booleano.Para cada elemento, ela checa condição, e avalia uma ou outra expressão, salvando os resultados em um vetor.O que o código abaixo vai retornar?Outra opção é dplyr::case_when(), que permite vários pares condição-resultado:","code":"\nx <- 1:10\nifelse(x > 5, NA, x)\nk <- 1:10\ndplyr::case_when(\n  k %% 35 == 0 ~ \"fizz buzz\",\n  k %% 5 == 0 ~ \"fizz\",\n  k %% 7 == 0 ~ \"buzz\",\n  is.na(k) ~ \"???\",\n  TRUE ~ as.character(k)\n)\n#>  [1] \"1\"    \"2\"    \"3\"    \"4\"    \"fizz\" \"6\"    \"buzz\" \"8\"    \"9\"    \"fizz\""},{"path":"subset.html","id":"and-and-e-or-or","chapter":"4 Subsetting","heading":"4.5.5 And And e Or Or","text":"Existem os operadores “” && e “” || que garantem sempre um único valor booleano (dão erros com vetores longos), além de serem “short circuit”.Por isso, use && e || em , & e | em ifelse().","code":"\nc(FALSE, TRUE) && TRUE\n#> erro por usar vetor longo\n\nc(FALSE) && stop()\n#> FALSE pois para no `FALSE`\n\nc(FALSE) & stop() #gera erro,\n#> erro, pois não para no `FALSE`"},{"path":"subset.html","id":"switch","chapter":"4 Subsetting","heading":"4.5.6 Switch","text":"Existe uma maneira mais simples de escrever uma expressão de “escolha de opções”, com função switch():","code":"\nif (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"`x` inválido\")\n}\nswitch(x,\n  a = \"option 1\",\n  b = \"option 2\",\n  c = \"option 3\",\n  stop(\"`x` inválido\")\n)"},{"path":"subset.html","id":"infix-operator","chapter":"4 Subsetting","heading":"4.5.7 Infix Operator","text":"Muitas vezes, queremos substituir o valor de uma variável caso ela seja NULL. Muitas vezes, funções usam isso para definir argumentos padrão.Para isso, temos o infix operator:","code":"\nk <- NULL\nk <- k %||% 10"},{"path":"subset.html","id":"control-flow---loops","chapter":"4 Subsetting","heading":"4.6 Control Flow - Loops","text":"","code":""},{"path":"subset.html","id":"loops-for","chapter":"4 Subsetting","heading":"4.6.1 Loops For","text":"Loops são usados para iterar em elementos de um vetor:item é literalmente um objeto, cujo valor vai sendo atualizado cada iteração, e fica armazenado ambiente global.Dicas gerais:O R é uma lingua vetorizada, use operações vetorizadas lugar de loops!Ao usar um loop para criar uma variável, crie o “contêiner” de antemão, pois é bem mais rápido:Prefira usar seq_along(x) lugar de 1:length(x).Prefira usar seq_along(x) lugar de 1:length(x).Cuidado que loops costuma remover atributos. Use seq_along() e acesse os itens você mesmo:Cuidado que loops costuma remover atributos. Use seq_along() e acesse os itens você mesmo:","code":"\nfor (item in vector) expr\nifelse(x < 0, -x, x)\nfor (i in seq_along(x)) {\n  if (x[1] < 0) x[1] <- -x[1] else x[1] <- x[1]\n}\nx <- NULL; for(i in 1:5) x <- c(x, i)\nx <- NULL; for(i in 1:5) x[[i]] <- i\nx <- as.Date(c(\"2020-01-01\", \"2010-01-01\"))\nfor (i in x) print(i)"},{"path":"subset.html","id":"map","chapter":"4 Subsetting","heading":"4.6.2 Map","text":"Em muitas linguagens, um map é uma higher-order-function que aplica uma função aos elementos de uma coleção.Este é um padrão funcional, e será discutido na aula 5, mas tem sua semelhança com loops.R, existem vários maps:E existem muitas variações:","code":"\nlapply(x, \\(a) a + 1)\npurrr::map(x, \\(a) a + 1)\nsapply(x, \\(a) a + 1)\nreplicate(1:10, rnorm(1000))\napply(df, 1, \\(a) a + 1)\nMap(\\(a) a + 1, x)"},{"path":"subset.html","id":"outros-loops","chapter":"4 Subsetting","heading":"4.6.3 Outros Loops","text":"Se você não tem um vetor de opções de antemão, não sabe sobre quais valores quer iterar, você pode:Usar um loop (condition) {...}, que repete uma ação enquanto uma condição valer.Usar um loop (condition) {...}, que repete uma ação enquanto uma condição valer.Ou, ainda mais flexível, repeat(...), que repete uma ação para sempre até encontrar um break.Ou, ainda mais flexível, repeat(...), que repete uma ação para sempre até encontrar um break.É uma boa prática usar opção menos flexível possível, para dar menos brechas para erros. Prefira usar o , ou lapply/purrr::map.","code":""},{"path":"subset.html","id":"control-flow---keywords","chapter":"4 Subsetting","heading":"4.7 Control Flow - Keywords","text":"","code":""},{"path":"subset.html","id":"keywords","chapter":"4 Subsetting","heading":"4.7.1 Keywords","text":"keyword next pula para próxima iteração, e break termina o loop/condicional.Como será ordem loop abaixo?","code":"\nfor (i in 1:10) {\n  if (i < 3) next\n  print(i)\n  if (i >= 5) break\n}"},{"path":"subset.html","id":"condition-system","chapter":"4 Subsetting","heading":"4.8 Condition System","text":"","code":""},{"path":"subset.html","id":"conditions","chapter":"4 Subsetting","heading":"4.8.1 Conditions","text":"O sistema de condições serve para funções indicarem ao usuário alguma informação, como existência de erros.Existem três tipos de informação:Erros: muito severos, indicam que nem foi possível terminar execução da funçãoAvisos: médiamente severos, indicam alga provávelmente errado, mas que não impediu execução.Mensagens: pouco severos, normalmente indicam que função realizou alguma correção para o usuário.","code":""},{"path":"subset.html","id":"condition-functions","chapter":"4 Subsetting","heading":"4.8.2 Condition Functions","text":"Dentro da função, chamadas à stop(), warning(), ou message() criam condição. stop(), inclusive, para execução da função.Também existe rlang::abort(), rlang::warn(), rlang::inform().O usuário pode encapsular uma call em funções como try() e tryCatch() para ignorar ou lidar com condições.","code":""},{"path":"subset.html","id":"signaling","chapter":"4 Subsetting","heading":"4.8.3 Signaling","text":"Autores de funções devem aprender quando e como indicar cada tipo de condição. Se tiver curiosidade, veja seção 8.2 AdvR.Considere função de teste pacote varr.","code":"\ntest$category <- function(arg, options, env) {\n  arg_name <- rlang::ensym(arg)\n\n  if (!all(arg %in% options)) {\n    cli_abort(\n      \"{.var {arg_name}} must contain only {.or {options}}\",\n      call = env\n    )\n  }\n}\n\ntest$unused <- function(arg, x, class, env) {\n  arg_name <- ensym(arg)\n\n  if (class(x) == class) {\n    cli_inform(\n      \"{.val {arg_name}} is unused if `x` is of class {class}.\",\n      call = env\n    )\n  }\n}"},{"path":"subset.html","id":"ignoring","chapter":"4 Subsetting","heading":"4.8.4 Ignoring","text":"R, podemos ignorar condições:Ignore erros com try().Ignore avisos com suppressWarnings().Ignore mensagens com suppressMessages().Considere o padrão abaixo.","code":"\nx <- NULL\ntry(x <- call_que_pode_dar_errado())"},{"path":"subset.html","id":"handling","chapter":"4 Subsetting","heading":"4.8.5 Handling","text":"Podemos lidar com condições usando tryCatch() e withCallingHandlers(), que especificam funções para se executar caso de cada tipo de condição:Qual diferença das duas?tryCatch() define exiting handlers, após condição aparecer, função handler relevante é ativada, e seu valor é retornado para onde tryCatch() foi chamado.tryCatch() define exiting handlers, após condição aparecer, função handler relevante é ativada, e seu valor é retornado para onde tryCatch() foi chamado.withCallingHandlers() define calling handlers, após condição, função handler relevante é ativada, e seu valor é retornado para onde call que gerou condição estava.withCallingHandlers() define calling handlers, após condição, função handler relevante é ativada, e seu valor é retornado para onde call que gerou condição estava.Isto é, uma sai da call, outra não. primeira é mais intuitiva para erros, segunda para avisos ou mensagens.","code":"\ntryCatch(\n  error = function(cnd) {\n    # código a ser executado quando ocorrer um erro\n  },\n  warning = function(cnd) {\n    # código a ser executado quando um aviso for sinalizado\n  },\n  message = function(cnd) {\n    # código a ser executado quando uma mensagem for sinalizada\n  },\n  call_rodada_com_handlers\n)"},{"path":"subset.html","id":"complemento-2","chapter":"4 Subsetting","heading":"Complemento","text":"","code":""},{"path":"subset.html","id":"recapitulando-2","chapter":"4 Subsetting","heading":"Recapitulando","text":"","code":""},{"path":"subset.html","id":"subsetting","chapter":"4 Subsetting","heading":"4.8.5.1 Subsetting","text":"Seis ‘insumos’ para selecionar com [:A1. Inteiros positivos: retornam elementos nas posições.A2. Inteiros negativos: retornam todos os elementos menos os das posições.A3. Vetores lógicos: retornam os elementos nas posições onde tem-se TRUE’s.A4. Vetores de texto: retornam os elementos com os nomes escolhidos.A5. Nada: x[] retorna o vetor original.A6. Zero: retorna um vetor de tamanho 0.Reciclagem: para relacionar vetores de tamanhos diferentes, o R multiplica o tamanho menor, se múltiplo maior: x[c(TRUE, FALSE)].Três ‘métodos’ para selecionar com dimensões:M1. Múltiplos vetores: um vetor para cada dimensão.\nM2. Vetor único: como matrizes são vetores, podemos tratá-las como tal.\nM3. Matrizes seletoras: onde cada coluna é uma dimensão, e cada linha um elemento quisto.Com listas e dataframes:Com listas, não temos nenhuma diferença. [ sempre retorna uma lista, mesmo ao selecionar um único elemento.Com dataframes, que são uma ‘lista com cara de matriz’, temos o método normal e o de matriz.O operador [ simplifica dimensão resultado. Veja o argumento drop = TRUE.Para retornar apenas um (único) elemento, usamos os operadores [[...]] ou $....Dois ‘insumos’ para selecionar com [[:L1. Um escalar inteiro: selecionando o elemento pelo índide.\nL2. Um escalar string: selecionando pelo nome.Selecionar elementos que não existem está relacionado comportamentos inconsistentes, vezes retornando erros, NULL, ou NA.[ é mais permissivo, retorna “nada” em vez de um erro.\nConsidere usar purrr::keep_at() ou vctrs::vec_slice.\nConsidere usar purrr::keep_at() ou vctrs::vec_slice.[[ é menos permissivo, retorna erro em vez de nada.\nConsidere usar purrr::pluck() e purrr::chuck().\nConsidere usar purrr::pluck() e purrr::chuck().Todos os operadores de subset podem ser combinados com <-: x[] <- ....","code":""},{"path":"subset.html","id":"control-flow-1","chapter":"4 Subsetting","heading":"4.8.5.2 Control Flow","text":"ferramentas de control flow são aquelas que alteram ordem de execução de um dado código.Choices, com , else, switch().\nE suas versões vetorizadas, ifelse() e dplyr::case_when().\nE suas versões vetorizadas, ifelse() e dplyr::case_when().Loops, com repeat, , e .\nSimilares ao conceito de map, funções como lapply(), purrr::map(), e apply().\nSimilares ao conceito de map, funções como lapply(), purrr::map(), e apply().Também vimos:Operadores e .Ooperador infix.Keywords next e break.","code":""},{"path":"subset.html","id":"condições","chapter":"4 Subsetting","heading":"4.8.5.3 Condições","text":"O sistema de condições serve para funções indicarem ao usuário alguma informação, como existência de erros.Existem três tipos de informação: erros (stop()), avisos (warning()), e mensagens (message()).Podemos ignorar condições:Ignore erros com try().Ignore avisos com suppressWarnings().Ignore mensagens com suppressMessages().E podemos lidar com condições usando tryCatch() e withCallingHandlers(), que especificam funções para se executar caso de cada tipo de condição.tryCatch() define exiting handlers, após condição aparecer, função handler relevante é ativada, e seu valor é retornado para onde tryCatch() foi chamado.withCallingHandlers() define calling handlers, após condição, função handler relevante é ativada, e seu valor é retornado para onde call que gerou condição estava.","code":""},{"path":"subset.html","id":"dicionário-de-funções-2","chapter":"4 Subsetting","heading":"Dicionário de Funções","text":"","code":""},{"path":"subset.html","id":"referências-2","chapter":"4 Subsetting","heading":"Referências","text":"Referência básica: Advanced R (2e) cap. 4 cap. 5.","code":""},{"path":"control-conds.html","id":"control-conds","chapter":"5 Control Flow e Condições","heading":"5 Control Flow e Condições","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"control-conds.html","id":"introdução-4","chapter":"5 Control Flow e Condições","heading":"5.1 Introdução","text":"","code":""},{"path":"control-conds.html","id":"choices","chapter":"5 Control Flow e Condições","heading":"5.2 Choices","text":"","code":""},{"path":"control-conds.html","id":"if-else","chapter":"5 Control Flow e Condições","heading":"5.2.1 If & else","text":"","code":""},{"path":"control-conds.html","id":"and-and-e-or-or-1","chapter":"5 Control Flow e Condições","heading":"5.2.2 And and e or or","text":"","code":""},{"path":"control-conds.html","id":"switch-1","chapter":"5 Control Flow e Condições","heading":"5.2.3 Switch","text":"","code":""},{"path":"control-conds.html","id":"loops","chapter":"5 Control Flow e Condições","heading":"5.3 Loops","text":"","code":""},{"path":"control-conds.html","id":"loops-for-1","chapter":"5 Control Flow e Condições","heading":"5.3.1 Loops For","text":"","code":""},{"path":"control-conds.html","id":"outros-loops-1","chapter":"5 Control Flow e Condições","heading":"5.3.2 Outros loops","text":"","code":""},{"path":"control-conds.html","id":"condições-1","chapter":"5 Control Flow e Condições","heading":"5.4 Condições","text":"","code":""},{"path":"control-conds.html","id":"complemento-3","chapter":"5 Control Flow e Condições","heading":"Complemento","text":"","code":""},{"path":"control-conds.html","id":"recapitulando-3","chapter":"5 Control Flow e Condições","heading":"Recapitulando","text":"","code":""},{"path":"control-conds.html","id":"dicionário-de-funções-3","chapter":"5 Control Flow e Condições","heading":"Dicionário de Funções","text":"","code":""},{"path":"control-conds.html","id":"referências-3","chapter":"5 Control Flow e Condições","heading":"Referências","text":"","code":""},{"path":"control-conds.html","id":"exercícios-2","chapter":"5 Control Flow e Condições","heading":"Exercícios","text":"","code":""},{"path":"funs-envs.html","id":"funs-envs","chapter":"6 Funções e Ambientes","heading":"6 Funções e Ambientes","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"funs-envs.html","id":"introdução-5","chapter":"6 Funções e Ambientes","heading":"6.1 Introdução","text":"Referência básica: Advanced R (2e) cap. 6, cap. 7, cap. 13.Na aula de hoje, aprenderemos alguns dos conceitos mais técnicos curso. Mas, é aula de funções, vocês ja aprenderam objetos, então é isso, acabou.Haverão três aprendizados principais:() o que, detalhe, são funções;(ii) o que são ambientes;(iii) como funções buscam por valores;(iv) o que são funções genéricas, OOP R.","code":""},{"path":"funs-envs.html","id":"fundamentos-das-funções","chapter":"6 Funções e Ambientes","heading":"6.2 Fundamentos das Funções","text":"","code":""},{"path":"funs-envs.html","id":"criação","chapter":"6 Funções e Ambientes","heading":"6.2.1 Criação","text":"Funções R são expressões que salvamos como um objeto, para utilizá-las repetidas vezes, variando seus argumentos.Elas são criadas com seguinte sintaxe:Para acessar o código fonte de uma função, digite seu nome (sem parênteses) console.","code":"\nfun_name <- function(x, y) {x + y}\nfun_name <- \\(x, y) {x + y}"},{"path":"funs-envs.html","id":"funções-de-primeira-classe","chapter":"6 Funções e Ambientes","heading":"6.2.2 Funções de Primeira Classe","text":"Funções de primeira classe\nR, funções são objetos como qualquer outro, e são tratados da mesma forma. Tem seu tipo, podem ser salvas à variáveis ou em listas, podem receber atributos, etc.Exemplo de funções em listas:","code":"\nfuns <- list(\n    halve = function(x) x / 2,\n    double = function(x) x * 2\n)\n\nfuns$double(10) #> 20"},{"path":"funs-envs.html","id":"tipos","chapter":"6 Funções e Ambientes","heading":"6.2.3 Tipos","text":"Funções tem tipo “closure”.únicas exceções existem R base, e são escritas em C em vez de R, por performance. Elas são funções primitivas, e seu tipo é ou “builtin” ou “primitive”.","code":""},{"path":"funs-envs.html","id":"componentes","chapter":"6 Funções e Ambientes","heading":"6.2.4 Componentes","text":"Funções têm três componentes:Seus argumentos (x e y), acessados com formals()Seu corpo (x + y), acessado com body()Seu environment, um objeto que determina onde função deve procurar os valores das variáveis relevantes, acessado com environment(). Mais sobre em breve.funções primitivas não tem os componentes: sum #> .Primitive(\"sum\").Funções closures\nR, funções são closures, porque enclose seus ambientes. O lugar onde buscaram valores necessários é definido na hora da criação.","code":""},{"path":"funs-envs.html","id":"formatos","chapter":"6 Funções e Ambientes","heading":"6.2.5 Formatos","text":"R, “Everything exists object. Everything happens function call”. Já tatuaram?segunda parte slogan fica clara ao saber que operadores e keywords também são funções, apenas com outro formato.Quais são os formatos possíveis?Prefix: o formato “padrão” sum(x, y).Prefix: o formato “padrão” sum(x, y).Infix: função vai meio de seus argumentos, x + y.\nModo prefix: `+`(x, y).\nPara definir use um nome que comece e termine com “%”: `%&%` <- \\(x, y) paste(x, y).\nInfix: função vai meio de seus argumentos, x + y.Modo prefix: `+`(x, y).Para definir use um nome que comece e termine com “%”: `%&%` <- \\(x, y) paste(x, y).Replacement: funções que alterem valores de um objeto: names(df) <- ....\nModo prefix: `names<-`(df, ...).\nVeja como definir.\nReplacement: funções que alterem valores de um objeto: names(df) <- ....Modo prefix: `names<-`(df, ...).Veja como definir.Special: funções muito importantes para o R, cada uma com uma forma própria, como [[, , .\n``(x > 0, x, x * (-1)).\n``(var, seq, action).\n`next`(), e `break`().\nSpecial: funções muito importantes para o R, cada uma com uma forma própria, como [[, , .``(x > 0, x, x * (-1)).``(var, seq, action).`next`(), e `break`().","code":""},{"path":"funs-envs.html","id":"encadeando-funções","chapter":"6 Funções e Ambientes","heading":"6.2.6 Encadeando Funções","text":"Existem três maneiras de combinar funções:Nesting: g(f(x)), f realiza sua operação em x, e o resultado vira argumento para g.\nÉ enxuto para pequenas expressões, mas pode ficar confuso em expressões muito longas.\nÉ enxuto para pequenas expressões, mas pode ficar confuso em expressões muito longas.Objetos intermediários: y <- f(x); z <- g(y).\nBom quando os valores intermediários são importantes, mas desnecessário quando não são.\nBom quando os valores intermediários são importantes, mas desnecessário quando não são.Piping: os operadores |> e magrittr::`%>%` chamam “pipe” (cano). Eles transformam avaliação de “dentro para fora” em “da esquerda pra direita”: f(x) %>% g().\nFacilita leitura de expressões longas, mas só serve quando é apenas um objeto que irá “avançar” ao longo da função.\nIdeal quando funções recebem e retornam mesma classe de objeto.\nFacilita leitura de expressões longas, mas só serve quando é apenas um objeto que irá “avançar” ao longo da função.Ideal quando funções recebem e retornam mesma classe de objeto.","code":""},{"path":"funs-envs.html","id":"resultados","chapter":"6 Funções e Ambientes","heading":"6.2.7 Resultados","text":"Todas funções retornam algo:return() é usado para definir o resultado explicitamente, e encerrar execução da função. Útil em conjunto com & else.Caso contrário, função retorna o valor de sua última linha.invisible() pode ser usado para retornar um valor sem imprimi-lo.Isso mesmo, funções que você achava que só realizavam um efeito colateral (print()), retornam algo invisivelmente – (<- 2) #> [1] 2.","code":""},{"path":"funs-envs.html","id":"resultados---exit-handlers","chapter":"6 Funções e Ambientes","heading":"6.2.8 Resultados - Exit Handlers","text":"Uma função termina sua execução se:Encontrar um return() ou rodar sua última linha.Encontrar um erro (stop()) não handled, ou encontrar avisos e mensagens lidadas por tryCatch().Podemos usar função .exit() para rodar uma expressão quando uma função finalizar, independente motivo.","code":""},{"path":"funs-envs.html","id":"argumentos","chapter":"6 Funções e Ambientes","heading":"6.2.9 Argumentos","text":"Funções podem ter argumentos padrão: f <- \\(x, = 2) x^. Mais sobre capacidades disso à frente.É muito comum usar NULL para um argumento padrão, junto com %||%.Funções podem ter o argumento especial ... pronunciado “dot-dot-dot”. Ele é útil em vários casos:Sua função é um wrapper de outra função – \\(x, ...) <- replicate(rnorm(...), x).Sua função recebe uma função como variável – lapply().Funções genéricas (mais sobre isso futuro).","code":""},{"path":"funs-envs.html","id":"argumentos-em-listas","chapter":"6 Funções e Ambientes","heading":"6.2.10 Argumentos Em Listas","text":"Muitas vezes temos argumentos em uma lista, que queremos passar para uma função. Podemos fazer isso com função .call():Note que podemos passar argumentos nomeados e não nomeados.Similar ao ** python, o pacote rlang oferece um operador !!! de desempacotar/injetar argumentos em uma call de função:Vamos falar mais sobre isso futuro.","code":"\ndo.call(sum, list(1, 4, 6, NA, 5, na.rm = TRUE)) #> 16\nrlang::inject(sum(!!!list(1, 4, 6, NA, 5, na.rm = TRUE))) #> 16"},{"path":"funs-envs.html","id":"pacotes","chapter":"6 Funções e Ambientes","heading":"6.2.11 Pacotes","text":"Um package é um conjunto de funções com um tema/objetivo específico. Eles contém uma documentação explicativa e vezes datasets para exemplos.O CRAN armazena pacotes que passam testes específicos, mas qualquer um pode criar e postar um pacote GitHub. Vide install.packages() e o pacote “devtools”.Após instalar, para carregar funções pacote, use library(pkg_name).Para aprender como criar seu próprio pacote, vide este tutorial MIT e o livro R Packages, 2nd Edition, também de Hadley Wickham.O R base conta com 7 pacotes built-, que estão sempre carregadas R:“base” (fundação R, que inicia todos os outros pacotes).“graphics” e “grDevices” (funções gráficas).“utils” (funções utilitárias).“methods” (funções para OOP).“datasets” (bases de dados para treino).“stats” (funções estatísticas).","code":""},{"path":"funs-envs.html","id":"outros-tópicos","chapter":"6 Funções e Ambientes","heading":"6.2.12 Outros Tópicos","text":"Funções anônimas: note que não precisamos atribuídas um nome à uma função. Muito comum ao passar funções à outras – lapply(mtcars, \\(x) x + 1).Recursividade: funções R podem chamar elas mesmas. Muitas vezes, usar uma função recursiva é similar à usar um loop .","code":"\nrecursive_factorial <- function(x) {\n  if (x == 0) return(1) else return(x * recursive_factorial(x - 1))\n}"},{"path":"funs-envs.html","id":"ambientes","chapter":"6 Funções e Ambientes","heading":"6.3 Ambientes","text":"","code":""},{"path":"funs-envs.html","id":"definição","chapter":"6 Funções e Ambientes","heading":"6.3.1 Definição","text":"AmbientesAmbientes são um tipo de objeto R, que armazenam variáveis, e empoderam o sistema de scoping (.e. como funções buscam por valores).Eles são similares à listas nomeadas, onde:Todos os nomes devem ser únicos.Não existe uma ordem nos elementos.Todo ambiente tem um um “ambiente pai” (como uma lista dentro de outra).São o único tipo de objeto que não é copied modified.Podemos criar um ambiente com rlang::env(). Podemos “printar” os conteúdos de um ambiente com rlang::env_print(). rlang::new_environment() permite escolher o pai.","code":""},{"path":"funs-envs.html","id":"ambientes-importantes","chapter":"6 Funções e Ambientes","heading":"6.3.2 Ambientes Importantes","text":"maioria dos ambientes são criados pelo R. Em ordem de senioridade:Ambiente vazio – chamado como R_EmptyEnv, é o único ambiente que não tem pai, serve basicamente para denotar o começo da ordem.Ambiente vazio – chamado como R_EmptyEnv, é o único ambiente que não tem pai, serve basicamente para denotar o começo da ordem.Ambiente base – o ambiente pacote base. funções definidas nele são utilizadas, inclusive para iniciar o resto R.Ambiente base – o ambiente pacote base. funções definidas nele são utilizadas, inclusive para iniciar o resto R.Ambientes de pacotes – cada pacote armazena funções em seu próprio ambiente. ordem é ordem dos library()s.Ambientes de pacotes – cada pacote armazena funções em seu próprio ambiente. ordem é ordem dos library()s.maioria dos ambientes são criados pelo R. Em ordem de senioridade:Ambiente global – chamado como R_GlobalEnv, é o ambiente onde o usuário define suas variáveis.Ambiente global – chamado como R_GlobalEnv, é o ambiente onde o usuário define suas variáveis.Ambientes de funções – quando uma função executa, ela cria um ambiente temporário para salvar suas variáveis. Mais sobre isso à frente.Ambientes de funções – quando uma função executa, ela cria um ambiente temporário para salvar suas variáveis. Mais sobre isso à frente.","code":""},{"path":"funs-envs.html","id":"outros-tópicos-1","chapter":"6 Funções e Ambientes","heading":"6.3.3 Outros Tópicos","text":"Podemos utilizar o operador <<- “super assignment” para salvar uma variável ambiente pai. Assim como função assign() para salvar uma variável em qualquer ambiente. O uso disso é raro.Ambientes são objetos, como qualquer outro, e seus conteúdos podem ser acessados e alterados por [[ e $.relação entre um nome e seu valor é chamada de bind. Afora relação que vocês ja conhecem de variáveis, podem haver outras duas mais avançadas.Os pacotes, além ambiente que armazena funções, também tem um ambiente especial chamado de “namespace”, que descreve como cada função deve procurar suas variáveis. Mais sobre isso frente.","code":""},{"path":"funs-envs.html","id":"funções-úteis-2","chapter":"6 Funções e Ambientes","heading":"6.3.4 Funções Úteis","text":"Use rlang::env_parent() para achar o pai de um ambiente, e rlang::current_env() para achar o ambiente atual.","code":""},{"path":"funs-envs.html","id":"scoping-e-evaluation","chapter":"6 Funções e Ambientes","heading":"6.4 Scoping e Evaluation","text":"Na aula 1, falamos sobre como o R associa valores à um nome (atribuição), agora, falaremos sobre como o R acha o valor associado à um nome (scoping). R, utilizamos o lexical scoping.Ao encontrar um nome em seu corpo, como uma função procura por seu valor? Quando esse valor é acessado?Adicionalmente, como, especialmente, os argumentos serão avaliados?","code":""},{"path":"funs-envs.html","id":"como","chapter":"6 Funções e Ambientes","heading":"6.4.1 Como","text":"Princípios “como”:Funções procuram nomes em ambientes. Começam de um específico (já te conto qual), se não acham, buscam ambiente pai, e vão subindo até o último ambiente (R_EmptyEnv).Funções procuram nomes em ambientes. Começam de um específico (já te conto qual), se não acham, buscam ambiente pai, e vão subindo até o último ambiente (R_EmptyEnv).Essa lógica é utilizada para procurar todos os nomes, inclusive funções.Essa lógica é utilizada para procurar todos os nomes, inclusive funções.","code":"\ne1 = new_environment(data = list(x = 1), parent = empty_env())\ne2 = new_environment(data = list(), parent = e1)\ne3 = new_environment(data = list(), parent = e2)\n\nf1 <- \\() x\nenvironment(f1) #<environment: R_GlobalEnv>\nenvironment(f1) <- e3\n\nf1()\nenv = new_environment(data = list(`+` = \\(a, b) paste0(a, b)))\n\nf1 <- \\(a, b) a + b\nenvironment(f1) <- env\n\nf1(\"oi\", \"olá\")"},{"path":"funs-envs.html","id":"onde","chapter":"6 Funções e Ambientes","heading":"6.4.2 Onde","text":"Princípios “onde”:Static scope – o ambiente pai primeiro é o ambiente que função carrega. Não se usa o ambiente de onde função foi chamada.Static scope – o ambiente pai primeiro é o ambiente que função carrega. Não se usa o ambiente de onde função foi chamada.Name masking – o primeiro ambiente é criado pela função, onde serão salvos seus argumentos e variáveis definidas em seu corpo. Não se usa o ambiente que função carrega.Name masking – o primeiro ambiente é criado pela função, onde serão salvos seus argumentos e variáveis definidas em seu corpo. Não se usa o ambiente que função carrega.Fresh start – esse ambiente de execução é temporário, função nunca “lembra” nada da última vez que foi chamada.Fresh start – esse ambiente de execução é temporário, função nunca “lembra” nada da última vez que foi chamada.Podemos utilizar o operador <<- para função gerar um efeito colateral ambiente que carrega, “alterando” (em termos práticos) o ponto 3. Isso não costuma ser uma boa prática.","code":"\na <- 1\n\nf1 <- function() a\nf2 <- function() {\n    a <- 2\n    f1()\n}\n\nf2()\ni <- 1\n\nf1 <- function() {\n  i <- i + 1\n  i\n}\n\nf1()\nf1()"},{"path":"funs-envs.html","id":"quando","chapter":"6 Funções e Ambientes","heading":"6.4.3 Quando","text":"Princípios “quando”:Dynamic lookup – funções buscam os valores na hora da chamada, não quando são criadas. Só salvamos o ambiente, não “congelamos” seu conteúdo.Dynamic lookup – funções buscam os valores na hora da chamada, não quando são criadas. Só salvamos o ambiente, não “congelamos” seu conteúdo.Lazy evaluation – argumentos são salvados como uma expressão, que só é avaliada quando acessada.Lazy evaluation – argumentos são salvados como uma expressão, que só é avaliada quando acessada.Lazy evaluation é empoderada por um tipo de dado chamado promessa: uma expressão (que carrega o ambiente onde deve ser avaliada, similar às closures), mas que, uma vez acessada, colapsa e “vira” o valor.","code":"\na <- 1\n\nf1 <- function() a\n\nf1()\n\na <- 2\nf1()\nf <- function(x = 1, y = x * 2, z = a + 2) {\n  a <- 3\n  c(x, y, z)\n}\nmean_unif <- \\(a, b, sim = FALSE, x = runif(10000, a, b)) {\n  if (sim) mean(x) else (a + b) / 2\n}"},{"path":"funs-envs.html","id":"funções-genéricas-oop","chapter":"6 Funções e Ambientes","heading":"6.5 Funções Genéricas (OOP)","text":"","code":""},{"path":"funs-envs.html","id":"funções-genéricas","chapter":"6 Funções e Ambientes","heading":"6.5.1 Funções Genéricas","text":"Vamos falar mais sobre o sistema de OOP R, S3, na aula que vem, mas vou contar o principal conceito de OOP R: funções genéricas.Algumas funções R assumem uma forma, um método, diferente depender da classe seu argumento (polimorfismo). Ex: summary().Os métodos são funções cujo nome junta o nome da genérica e da classe, funname.classname. Note que . não é um caracter especial R, mas é utilizado para denotar métodos.","code":""},{"path":"funs-envs.html","id":"method-dispatch","chapter":"6 Funções e Ambientes","heading":"6.5.2 Method Dispatch","text":"Method dispatch: Essas funções genéricas são apenas um intermediário, que recebem argumentos, descobrem qual é o método adequado, e passam os argumentos diante.Quem faz o method dispatch é função UseMethod(). Ela olha para classe de x, e busca o método mean.classofx.S3, o método “mora” na função, e não na classe!","code":"\nmean\n#> function (x, ...) UseMethod(\"mean\")"},{"path":"funs-envs.html","id":"default-e-herança","chapter":"6 Funções e Ambientes","heading":"6.5.3 Default e Herança","text":"Se não há nenhum método para classe “classofx”, existe pseudo-classe “default”, que é um fallback para todas classes.O R também tem um sistema de herança. Bem simples, classes podem ser vetores:UseMethod() vai procurar por funname.tbl_df, depois funname.tbl, depois, funname.data.frame, e por fim, funname.default. É como se todos os objetos herdassem “default”. Nesse processo, também é utilizada função NextMethod()","code":"\nclass(tibble::as_tibble(mtcars)) #> \"tbl_df\" \"tbl\" \"data.frame\""},{"path":"funs-envs.html","id":"funções-úteis-3","chapter":"6 Funções e Ambientes","heading":"6.5.4 Funções Úteis","text":"Para achar os métodos de uma generic, use sloop::s3_methods_generic().Para achar os métodos de uma classe, use sloop::s3_methods_class().Para ver o código fonte de um método, use sloop::s3_get_method().Para ver o processo de dispatch, use sloop::s3_dispatch().","code":""},{"path":"funs-envs.html","id":"outros-tópicos-em-ambientes","chapter":"6 Funções e Ambientes","heading":"6.6 Outros Tópicos em Ambientes","text":"","code":""},{"path":"funs-envs.html","id":"caller-environment","chapter":"6 Funções e Ambientes","heading":"6.6.1 Caller Environment","text":"Ok, funções carregam seu próprio ambiente, independente de onde foram chamadas. Ainda assim, podemos estar interessados caller environment.Dentro de uma função, podemos acessar o ambiente onde ela foi chamada com rlang::caller_env().Podemos utilizar isso para criar funções que dependam de onde foram chamadas, funções com dynamic scope.Haverá um material explicando o que empodera rlang::caller_env() livro. Saber isso não é súper prático, mas ensina um conceito de programação importante, o de Call Stack (e Call Stack Trees).Apenas note que, para denotar calls, e o fato de que uma é “pai” de outra, existe um conceito similar ao de ambientes, chamado “frame”.","code":""},{"path":"funs-envs.html","id":"ambientes-como-dado","chapter":"6 Funções e Ambientes","heading":"6.6.2 Ambientes como Dado","text":"Na aula 1, comentamos que utilizar copy--modify era uma escolha de design, mas vezes é útil ter um dado que modifies--place.Como ambientes tem essa característica, existe o pacote r6 que implementa uma classe criada em cima dos ambientes. Também é um pacote sobre OOP, e será explicado futuro.","code":""},{"path":"funs-envs.html","id":"complemento-4","chapter":"6 Funções e Ambientes","heading":"Complemento","text":"","code":""},{"path":"funs-envs.html","id":"recapitulando-4","chapter":"6 Funções e Ambientes","heading":"Recapitulando","text":"Funções:São expressões que dependem de argumentos.R, funções são de primeira classe, são objetos como qualquer outroNo R, funções são closures, carregam um ambiente onde deve-se avaliar suas variáveis.Temos também funções primitivas.Têm três componentes, argumentos, corpo, e ambiente.Funções:Podem vir em três formatos, prefix, infix, replacement, e special.Podem ser encadeadas com nesting, objetos intermediários, ou piping.Sempre retornam algo.Encerram ao encontrar sua última linha, um return(), ou em certos contextos de condições.Funções:Podem ter argumentos padrões, que podem depender de outros argumentos.Podem recever varargs ``.Podem receber argumentos em listas via .call() ou rlang::`!!!`.São aglomeradas em pacotes.Podem ser anônimas.Podem ser recursivas.Ambientes:Ambientes são um tipo de objeto R, que armazenam variáveis.Similares à listas, mas com nomes únicos, sem ordem, carregam um ambiente pai, e são modified--place.Temos, em ordem: o ambiente vazio, base, de pacotes, global, de funções.Scoping e Evaluation:Scoping é o processo de encontrar o valor de um nome.Como: procura-se em ambientes, subindo até achar; vale para tudo, inclusive funções.Onde: static scope (o ambiente pai é o que função carrega); name masking (mas o primeiro é criado pela função, com seus argumentos e corpo); fresh start (o ambiente de execução é temporário).Quando: dynamic lookup (só quando acessados); lazy evaluation (o mesmo vale para argumentos, através de promessas).Podemos criar uma função com dynamic scope acessando o ambiente de onde função foi chamada, o rlang::caller_env().Funções Genéricas:Algumas funções R assumem uma forma, um método, diferente depender da classe seu argumento.Os métodos são funções cujo nome junta o nome da genérica e da classe, separados por um ponto ..O método adequado é encontrado processo chamado method dispatch, feito pela função UseMethod().Objetos podem ter sub-classes (herança), e existe pseudo-classe “default”, fallback de todos os objetos.UseMethod() vai procurar por todas classes (e “default”), até achar um método, e dar erro caso não ache nenhum.","code":""},{"path":"funs-envs.html","id":"dicionário-de-funções-4","chapter":"6 Funções e Ambientes","heading":"Dicionário de Funções","text":"","code":""},{"path":"funs-envs.html","id":"referências-4","chapter":"6 Funções e Ambientes","heading":"Referências","text":"Referência básica: Advanced R (2e) cap. 6, cap. 7, cap. 13.","code":""},{"path":"paradigms.html","id":"paradigms","chapter":"7 Paradigmas de Programação","heading":"7 Paradigmas de Programação","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"paradigms.html","id":"introdução-6","chapter":"7 Paradigmas de Programação","heading":"7.1 Introdução","text":"Referência básica: Advanced R (2e) partes “Functional Programming” + documentação pacote “purrr”, “Object-Oriented Programming”, “Metaptrogramming” + “R Language Definition” capítulo 6 e pacote rlang.Na aula de hoje, aprenderemos construtos de mais alto nível. Falaremos último tijolinho, expressões. Por fim, faremos uma revisão.Haverão três aprendizados principais:() O que é, quais são os construtos, e para que usar programação funcional.(ii) O que é, e para que usar programação orientada objetos.(iii) O que são expressões, e como usá-las para metaprogramação.Para os exemplos:","code":"\nlibrary(purrr)\nlibrary(rlang)"},{"path":"paradigms.html","id":"pf-fundamentos","chapter":"7 Paradigmas de Programação","heading":"7.2 PF: Fundamentos","text":"","code":""},{"path":"paradigms.html","id":"programação-funcional","chapter":"7 Paradigmas de Programação","heading":"7.2.1 Programação Funcional","text":"Programação funcional é um termo usado em contextos diferentes, mas geral, se refere à programas onde protagonistas são funções.Linguagen funcional é um conceito técnico de Ciência da Programação, que normalmente se refere à uma linguagem com funções first-class e pures.O primeiro termo vocês já conhecem, o segundo quer dizer funções que:O resultado depende apenas dos inputs (runif()?)Funções apenas retornam um resultado, nenhum efeito colateral (<-?).Ainda assim, linguagens que não são estritamente funcionais, podem tomar decisões de desing que privilegiam um estilo de programação funcional. Um estilo que deriva seus principais construtos através de funções.Quais são os construtos centrados em funções?","code":""},{"path":"paradigms.html","id":"pf-functionals","chapter":"7 Paradigmas de Programação","heading":"7.3 PF: Functionals","text":"","code":""},{"path":"paradigms.html","id":"functionals","chapter":"7 Paradigmas de Programação","heading":"7.3.1 Functionals","text":"dia dia, o construto mais importante serão os functionals. E dentre eles, o map, que vocês já tiveram uma palinha, será o principal.O R base implementa vários functionals, mas, na minha opinião, o pacote purrr e suas funções purrr::map() são melhores.","code":""},{"path":"paradigms.html","id":"map-1","chapter":"7 Paradigmas de Programação","heading":"7.3.2 Map","text":"Um map recebe uma função e um vetor, e aplica em cada um dos elementos dele, retornando os resultados em um novo vetor.Como foi visto, são similares à loops:","code":"\nfunction(x, f, ...) {\n  out <- vector(\"list\", length(x))\n  for (i in seq_along(x)) out[[i]] <- f(x[[i]], ...)\n  out\n}"},{"path":"paradigms.html","id":"map-2","chapter":"7 Paradigmas de Programação","heading":"7.3.3 Map 2","text":"Pense sobre o padrão abaixo:É um map, aplica dois vetores, termo--termo, em uma função.purrr, função que faz isso é purrr::map2().","code":"\nfunction(x, y, f, ...) {\n  out <- vector(\"list\", length(x))\n  for (i in seq_along(x)) out[[i]] <- f(x[[i]], y[[i]], ...)\n  out\n}"},{"path":"paradigms.html","id":"map2","chapter":"7 Paradigmas de Programação","heading":"7.3.4 Map^2","text":"E se quisermos, para cada elemento de um vetor x, aplicar função f à esse elemento, e todos os elementos de y?Isto é, um loop duplo:Note que isso é diferente de um map2, isso seria um “map” dentro de outro “map”:","code":"\nfunction(x, y, f, ...) {\n  out <- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n\n    out[[i]] <- vector(\"list\", length(y))\n    for (j in seq_along(y)) {\n      out[[i]][[j]] <- f(x[[i]], y[[j]], ...)\n    }\n  }\n  out\n}\nmap(x, \\(xi) {\n  map(y, \\(yi) {\n    f(xi, yi)\n  })\n})"},{"path":"paradigms.html","id":"map-p","chapter":"7 Paradigmas de Programação","heading":"7.3.5 Map p","text":"Voltando ao map 2? E se em vez de dois vetores, quero combinar termo--termo três vetores? Quatro? Um número \\(p\\) de vetores?Aí temos purrr::pmap. lógica é mesma, passamos vários vetores, e depois uma função.Temos que map2(x, y, f) é equivalente à pmap(list(x, y), f). Mas, também podemos fazer pmap(list(x, y, z), f), etc.Obs: por uma decisão de design, agrupamos esses vários vetores (de mesmo tamanho) em uma lista.","code":""},{"path":"paradigms.html","id":"mapp","chapter":"7 Paradigmas de Programação","heading":"7.3.6 Map^p","text":"E se quisésse-mos fazer um map, dentro de um map, dentro de um map … arbitrárias vezes? resposta é: não inventa.Sério, seria estranho ter essa necessidade, e provavelmente era melhor usar um loop . Mas só de curiosidade, dá pra escrever um map recursivo, que fixa o primeiro vetor e joga o resto pra dentro de um novo map:","code":"\nrmap <- function(l, f) {\n  if (length(l) > 1) {\n    map(l[[1]], \\(x) rmap(l[-1], \\(...) f(x, ...)))\n  } else {\n    map(l[[1]], f)\n  }  \n}"},{"path":"paradigms.html","id":"atalhos","chapter":"7 Paradigmas de Programação","heading":"7.3.7 Atalhos","text":"Index map: muitas vezes estamos interessados em um caso especial de map2, para qual existe o atalho purrr::imap():Selecionando elementos: outro padrão comum é ter uma lista de listas como list(list(= 1, b = 2), list(= 3, b = 4)) e querer selecionar todos os primeiros elementos de cada sub-lista, ou todos os elementos.Vocês sabem que podem fazer:map(x, ~ .x[[1]]), ou map(x, ~ .x[[\"\"]]).Mas o purrr tem um atalho: map(x, 1), ou map(x, \"\").Sintaxe lambda: O purrr permite utilizar fórmulas para definir funções, uma sintaxe especial rlang: \\(x, y) x + y é equivalente à ~ .x + .y.Argumentos fixos: map() pode receber argumentos extras, via ..., passados para função mapper. Mas, recomendação é sempre criar uma função anônima:Piping: funções purr também funcionam muito bem com piping:","code":"\nmap2(x, names(x), \\(xi, name) {...})\nimap(x, \\(xi, name) {...})\nmap(mtcars, mean, na.rm = TRUE)\nmap(mtcars, ~ mean(.x, na.rm = TRUE))\nmtcars[-1] |>\n  map(~ lm(mtcars$mpg ~ .x)) |>\n  map(coef) |>\n  map(2)\n\nmtcars[-1] |>\n  map(~ coef(lm(mtcars$mpg ~ .x))[[2]])"},{"path":"paradigms.html","id":"escolhendo-o-output","chapter":"7 Paradigmas de Programação","heading":"7.3.8 Escolhendo o Output","text":"Vimos que map e amigos sempre retornam uma lista, e se eu quiser um vetor simplificado? Podemos coagir na mão: map(mtcars, mean) |> unlist().Mas, também existem funções map_*() e amigos:map_dbl(mtcars, mean).purrr::modify() retorna um vetor mesmo tipo input.Lembrando que, para conseguir um vetor simplificado, todos os resultados devem ser mesmo tipo e ter length 1.E se eu não importo com o output, só estou chamando uma função pelos seus efeitos colaterais? Aí existe purrr::walk() e amigos.","code":""},{"path":"paradigms.html","id":"e-amigos","chapter":"7 Paradigmas de Programação","heading":"7.3.9 E Amigos","text":"Alternativas R base:Considere lapply() como substituto de map().Considere vapply() como substituto de map_*() (mais consistente que sapply()).Considere Map() como substituto de pmap(). Não existe uma versão generalizada de vapply(), apenas de sapply(), mapply().apply() é interessante para operar com matrizes ou linhas de um dataframe.","code":""},{"path":"paradigms.html","id":"quando-usar-um-map","chapter":"7 Paradigmas de Programação","heading":"7.3.10 Quando Usar um Map?","text":"Lembre-se escolha entre cada tipo de loop – que inclui maps – é baseada nível de flexibilidade quista.O principal ponto de maps é que suas iterações são independentes! Se você quer atualizar uma variável em todas iterações, deveria estar usando um loop.","code":""},{"path":"paradigms.html","id":"reduce","chapter":"7 Paradigmas de Programação","heading":"7.3.11 Reduce","text":"operação reduce, implementada em purrr::reduce(), recebe um vetor de tamaho \\(n\\) e retorna um escalar, aplicando uma operação repetidamente:Reduce é uma ferramenta útil para genralizar uma função que trabalha com dois inputs (uma função binária) para trabalhar com qualquer número de inputs:sum(x) é equivalente à reduce(x, `+`).Às vezes, é melhor criar uma nova função.","code":"\nreduce(1:4, f)\nf(f(f(1, 2), 3), 4)"},{"path":"paradigms.html","id":"reduce-início-customizado","chapter":"7 Paradigmas de Programação","heading":"7.3.12 Reduce: Início Customizado","text":"reduce() aceita um argumento .init, que é o valor inicial da operação. Se não fornecido, o primeiro elemento de x é usado.Normalmente, queremos um elemento “identidade” da operação que estamos fazendo – \\(0\\) é identidade da soma, \\(1\\) é identidade da multiplicação, etc.","code":""},{"path":"paradigms.html","id":"reduce-2","chapter":"7 Paradigmas de Programação","heading":"7.3.13 Reduce 2","text":"Não quero perder muito tempo com isso, mas também temos versão “2” de reduce:","code":""},{"path":"paradigms.html","id":"reduce-outros","chapter":"7 Paradigmas de Programação","heading":"7.3.14 Reduce: Outros","text":"Também poderíamos estar interessados em criar um “reduce p”, “reduce^2”, etc.Tamém temos purrr::accumulate(), que é como reduce(), mas retorna um vetor mesmo tamanho de x, com os resultados intermediários.","code":"\npurrr::accumulate(1:4, `+`) #> 1  3  6 10"},{"path":"paradigms.html","id":"predicate-functionals","chapter":"7 Paradigmas de Programação","heading":"7.3.15 Predicate Functionals","text":"Temos alguns funcionais relacionados à testes lógicos:(): retorna TRUE se algum elemento de .x satisfaz .p.every(): retorna TRUE se todos os elementos de .x satisfazem .p.none(): retorna TRUE se nenhum elemento de .x satisfaz .p.São similares à (map_lgl(.x, .p)), etc.Temos também detect() e detect_index(), que retornam o primeiro elemento que satisfaz .p e sua posição, respectivamente.E keep() e discard(), que mantém ou descartam os elementos que satisfazem .p.map e modify têm variantes que também aceitam funções de predicado, transformando apenas os elementos que passam uma condição, ou que estão em uma localidade específica: map_if() e map_at.","code":""},{"path":"paradigms.html","id":"outros","chapter":"7 Paradigmas de Programação","heading":"7.3.16 Outros","text":"Vocês talvez não perceberam, mas esta foi primeira aula sobre o tidyverse! Vocês aprenderam o básico pacote purrr.Ele é muito grande, e existem muitas ourtas variações de map e predicates para facilitar sua vida. Foquem que aprender map antes de ir para o resto.Por fim, outras funções são functionals e vocês não sabiam:integrate() encontra área sob curva definida por f.uniroot() encontra onde f atinge zero.optimise() encontra o mínimo/máximo de f.","code":""},{"path":"paradigms.html","id":"pf-function-factories","chapter":"7 Paradigmas de Programação","heading":"7.4 PF: Function Factories","text":"","code":""},{"path":"paradigms.html","id":"function-factories","chapter":"7 Paradigmas de Programação","heading":"7.4.1 Function Factories","text":"Uma function factory é uma função que faz funções.","code":"\npower1 <- function(exp) {\n  function(x) x ^ exp\n}\n\nsquare <- power1(2)\ncube <- power1(3)\nsquare(3) #> 9"},{"path":"paradigms.html","id":"function-factories-envs","chapter":"7 Paradigmas de Programação","heading":"7.4.2 Function Factories’ Envs","text":"Porque funciona? Onde square vai procurar exp?Cuidado com:Porque x é lazily evaluated. Por isso, é bom forcar sua avaliação antes de criar função, com force(x):","code":"\nsquare #> function(x) x ^ exp\nenvironment(square) #> <environment: 0x0000017235c2c3b0>\nenvironment(cube) #> <environment: 0x0000017235150760>\nenvironment(square)$exp #> 2\nenvironment(cube)$exp #> 3\ne <- 2\nsquare <- power1(e)\ne <- 3\nsquare(2) #> 8\npower1 <- function(exp) {\n  force(exp)\n  function(x) x ^ exp\n}"},{"path":"paradigms.html","id":"function-factories-envs-1","chapter":"7 Paradigmas de Programação","heading":"7.4.3 Function Factories’ Envs","text":"Adicionalmente, podemos criar funções “manufaturadas” que alterem seu ambiente de encapsulação – que é único.","code":"\npower1_count <- function(exp) {\n  force(exp)\n  i <- 0\n\n  function(x) {\n    assign(\"i\", i + 1, envir = rlang::env_parent()) #ou i <<- i + 1\n    list(res = x ^ exp, count = i)\n  }\n}"},{"path":"paradigms.html","id":"pf-function-operators","chapter":"7 Paradigmas de Programação","heading":"7.5 PF: Function Operators","text":"","code":""},{"path":"paradigms.html","id":"function-operators","chapter":"7 Paradigmas de Programação","heading":"7.5.1 Function Operators","text":"Uma function operator é uma função que recebe uma ou mais funções como input e retorna uma função como output.Por exemplo, usar Sys.time() para transformar uma função em uma função que também retorna seu tempo de execução.Outros dois exemplos úteis são purrr::safely() e memoise::memoise().Memoise é uma função que guarda o resultado de uma função, para que não seja recalculado.Safely é uma função que captura erros, ao invés de parar execução programa.Safely está purr porque é útil para map e amigos:","code":"\ntimeit <- function(f) {\n  function(...) {\n    start <- Sys.time()\n    res <- f(...)\n    end <- Sys.time()\n    list(res = res, time = end - start)\n  }\n}\n\nsum_time <- timeit(sum)\nsum_time(runif(10000))\nx <- list(1:4, 5:8, \"erro\")\nstr(map(x, safely(sum)))\n#> List of 3\n#>  $ :List of 2\n#>   ..$ result: int 10\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: int 26\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: NULL\n#>   ..$ error :List of 2\n#>   .. ..$ message: chr \"invalid 'type' (character) of argument\"\n#>   .. ..$ call   : language .Primitive(\"sum\")(..., na.rm = na.rm)\n#>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\""},{"path":"paradigms.html","id":"oop","chapter":"7 Paradigmas de Programação","heading":"7.6 OOP","text":"","code":""},{"path":"paradigms.html","id":"definição-1","chapter":"7 Paradigmas de Programação","heading":"7.6.1 Definição","text":"Da wikipédia:Object-oriented programming (OOP) programming paradigm based concept objects, can contain data code: data form attributes, code form methods. OOP, computer programs designed making objects interact one another.Muitas linguagens são multi-paradigma, o próprio R, por exemplo. O que temos, são diferenças de estilo de resolução de problemas: podemos centrar nosso estilo em funções, ou em objetos.","code":""},{"path":"paradigms.html","id":"sistemas-de-oop-no-r","chapter":"7 Paradigmas de Programação","heading":"7.6.2 Sistemas de OOP no R","text":"Vocês já conhecem o principal, S3. Lembrem que ele era diferente python, era um sistema OOP de generic functions. Mas existem outros:S4, que é o S3 mas de uma maneira mais formal e complicada.RC, que é um sistema de OOP mais tradicional.R6, que é o RC mas melhor.Entre outros como R.oo e proto.","code":""},{"path":"paradigms.html","id":"sistemas-de-oop-no-r-1","chapter":"7 Paradigmas de Programação","heading":"7.6.3 Sistemas de OOP no R","text":"S3 é importante de aprender porque é muito utilizado, inclusive R base. Os outros são mais raros. Advanced R:S4 rigorous system forces think carefully program design. ’s particularly well-suited building large systems evolve time receive contributions many programmers.R6 provides standardised way escape R’s copy--modify semantics. particularly important want model objects exist independently R.","code":""},{"path":"paradigms.html","id":"quando-usar-oop","chapter":"7 Paradigmas de Programação","heading":"7.6.4 Quando Usar OOP","text":"O sistema S3 faz parte integral R, e você utilizará ele para:Criar um método de uma classe não suportada por uma função genérica de seu interesse.Criar funções genéricas quando criar código ser compartilhado com outros (pacotes, principalmente).Para além disso, o R não é uma linguagem orientada objetos, se seu problema demanda isso, pode ser melhor usar outra linguagem. Ainda assim:O sistema R6 é útil para criar objetos que existem independentemente R.Muitas aplicações fora da realidade da ciência de dados se dão bem com abordagem de OOP.","code":""},{"path":"paradigms.html","id":"expressões","chapter":"7 Paradigmas de Programação","heading":"7.7 Expressões","text":"","code":""},{"path":"paradigms.html","id":"definição-2","chapter":"7 Paradigmas de Programação","heading":"7.7.1 Definição","text":"Vocês viram sobre o estilo de resolução de problemas que coloca objetos centro, funções centro, e em breve, verão o estilo que coloca expressões centro.Mas antes, vamos estudar esse tipo de objeto.","code":""},{"path":"paradigms.html","id":"tipos-de-expressões","chapter":"7 Paradigmas de Programação","heading":"7.7.2 Tipos de Expressões","text":"Vocês viram que expressões são “código congelado”.Uma expressão tem tipo expression, mas existem “subtipos” despeito da sua natureza/objetivo:Call, ou language, se é uma chamada de função.Symbol, ou name, se é um nome de objeto.Constant, se é um “dado cru” (1).Pairlist, se é uma lista de argumentos – algo vestigial.Os mais importantes são Call e Symbol:Um symbol é uma expressão limitada, que segue regras de nome.Uma call tem uma estrutura específica, é como uma lista com: o nome da função, e cada argumentos (nomeados ou não). Conseguiremos alterar cada componente.","code":""},{"path":"paradigms.html","id":"tipos-baseados-em-expressões","chapter":"7 Paradigmas de Programação","heading":"7.7.3 Tipos Baseados em Expressões","text":"Uma expressão pode ser “detalhada”, unida com outros objetos para se tornar alguns dos objetos:Quosure, se unida com um ambiente onde deve ser avaliada.Closure, se unida com um ambiente e uma lista de argumentos.Promise, se unida com um ambiente e o comportamento de colapsar após ser avaliada.Formula, uma call à função ~ com um ambiente.Obs: quosure e formulas não são tipos de verdade. Quosures são construídos em cima de promises, e formulas em cima de calls.","code":""},{"path":"paradigms.html","id":"ast","chapter":"7 Paradigmas de Programação","heading":"7.7.4 AST","text":"Por último, vou apresentar como visualizamos expressões – e por consequência, scripts: abstract syntax trees.","code":"\nlobstr::ast(f1(f2(a, b), f3(1, f4(2))))\n#> █─f1 \n#> ├─█─f2 \n#> │ ├─a \n#> │ └─b \n#> └─█─f3 \n#>   ├─1 \n#>   └─█─f4 \n#>     └─2\nlobstr::ast(1 + 2 * 3)\n#> █─`+` \n#> ├─1 \n#> └─█─`*` \n#>   ├─2 \n#>   └─3"},{"path":"paradigms.html","id":"metaprogramação-capturando","chapter":"7 Paradigmas de Programação","heading":"7.8 Metaprogramação: Capturando","text":"","code":""},{"path":"paradigms.html","id":"disclaimer","chapter":"7 Paradigmas de Programação","heading":"7.8.1 Disclaimer","text":"Não é muito útil para maioria dos problemas de ciência de dados. Mas é muito útil para criar pacotes, e para resolver problemas mais complexos.Tema difícil, mas útil para fixar alguns conceitos de CC, e está muito bem mastigado.modern popular languages expose level metaprogramming R provides.Não gastem seu cérebro de mais, mas não gastem de menos também.","code":""},{"path":"paradigms.html","id":"definição-3","chapter":"7 Paradigmas de Programação","heading":"7.8.2 Definição","text":"Como dito, pode ser entendido como o estilo que coloca expressões centro.Existem três pilares:Podemos capturar código como expressões (e amigos). Tanto de modo interativo, mas também passando-o para funções.Podemos criar e alterar código programaticamente.Podemos avaliar código em momentos oportunos, e escolhendo o ambiente de avaliação.","code":""},{"path":"paradigms.html","id":"quoting","chapter":"7 Paradigmas de Programação","heading":"7.8.3 1. Quoting","text":"O ato de capturar/congelar código é chamado de quoting, uma vez que é similar à transformar código em uma string. Mas não é mesma coisa.Podemos congelar código com:expression(), que sempre retorna uma expression.bquote() e rlang::expr() retornam uma das “sub-expression”.","code":"\nexpr(10 + 1) #> 10 + 1"},{"path":"paradigms.html","id":"parsing","chapter":"7 Paradigmas de Programação","heading":"7.8.4 1. Parsing","text":"Não é para você se encontrar nessa situação, mas se você tiver um código em uma string, você pode usar parse() ou rlang::parse_expr() para transformar em uma expressão.O inverso de parsing é deparsing, conseguir uma string que geraria uma dada expressão. Use deparse() ou rlang::expr_text().","code":""},{"path":"paradigms.html","id":"enriched-quoting","chapter":"7 Paradigmas de Programação","heading":"7.8.5 1. Enriched Quoting","text":"E se o código que quero congelar veio de um argumento de uma função?Então, eu preciso de uma função mágica, que inspecione promessa, e retorne expressão não avaliada. função mágica é enexpr().’s called “en”-expr() analogy enrich. Enriching someone makes richer; enexpr()ing argument makes expression.exprs() e enexprs() criam listas de expressões. Obs: diferente de um vetor tipo expression.","code":"\nf <- function(x){\n  expr(x)\n}\n\nf(10 + 1) #> ?"},{"path":"paradigms.html","id":"criando-symbols","chapter":"7 Paradigmas de Programação","heading":"7.8.6 1. Criando Symbols","text":"Para ser mais restritivo, e exigir que um código esteja associado apenas um símbolo, use sym(), ensym(), syms(), e ensyms().","code":""},{"path":"paradigms.html","id":"criando-quosures","chapter":"7 Paradigmas de Programação","heading":"7.8.7 1. Criando Quosures","text":"Já falamos que elas existem. Não falei por que elas são úteis, mas calma lá.Ainda assim, como são criadas? Com função quo(). E se eu quiser salvar expressão e o ambiente de uma promessa, em uma quosure? Com enquo().","code":""},{"path":"paradigms.html","id":"metaprogramação-alterando","chapter":"7 Paradigmas de Programação","heading":"7.9 Metaprogramação: Alterando","text":"","code":""},{"path":"paradigms.html","id":"criando-e-modificando-calls","chapter":"7 Paradigmas de Programação","heading":"7.9.1 2. Criando e Modificando Calls","text":"Podemos criar calls com call() e rlang::call2():E se eu quiser alterar um componente específico de uma call? Com [[ ou rlang::call_modify():","code":"\ncall2(\"f\", 1, 2, 3)\n#> f(1, 2, 3)\n\ncall2(\"+\", 1, call2(\"*\", 2, 3))\n#> 1 + 2 * 3\nx <- call2(\"mean\", c(1, 2, NA), na.rm = TRUE)\nx$na.rm <- FALSE\nx #> mean(c(1, 2, NA), na.rm = FALSE)\n\ncall_modify(x, trim = 0.1) #> mean(c(1, 2, NA), na.rm = FALSE, trim = 0.1)"},{"path":"paradigms.html","id":"criando-e-modificando-expressions","chapter":"7 Paradigmas de Programação","heading":"7.9.2 2. Criando e Modificando Expressions","text":"Podemos seletivamente “unquote” e “quote” partes de código, usando o operador rlang !!:Temos também !!!:!! one--one replacement. !!! (called “unquote-splice”, pronounced bang-bang-bang) one--many replacement. takes list expressions inserts location !!!","code":"\nxx <- expr(x + x)\nyy <- expr(y + y)\nexpr(!!xx / !!yy) #> (x + x)/(y + y)\nxs <- exprs(x, x, x)\nexpr(sum(!!!xs)) #> sum(x, x, x)"},{"path":"paradigms.html","id":"criando-e-modificando-functions","chapter":"7 Paradigmas de Programação","heading":"7.9.3 2. Criando e Modificando Functions","text":"Também podemos modificar os componentes de funções com formals(), body(), environment(). E podemos criar funções com rlang::new_function().","code":""},{"path":"paradigms.html","id":"metaprogramação-avaliando","chapter":"7 Paradigmas de Programação","heading":"7.10 Metaprogramação: Avaliando","text":"","code":""},{"path":"paradigms.html","id":"avaliação","chapter":"7 Paradigmas de Programação","heading":"7.10.1 3. Avaliação","text":"Podemos escolher quando e onde (em qual ambiente) avaliar uma expressão, via eval().Especialmente, podemos:Data mask: avaliar expressões contexto de um dataframe – tratando colunas como variáveis.Alterar definição de operadores temporariamente.Podemos usar rlang::exec() para criar uma call igual à call2() e avaliá-la imediatamente.","code":"\neval(expr(x + y), envir = env(x = 1, y = 10)) #> 11\n\neval(expr(mean(mpg)), envir = mtcars) #> 20.09062\n\n`+` <- function(a, b) {paste0(a, b)}\neval(expr(x + y), envir = env(x = 1, y = 10, `+` = `+`)) #> 110"},{"path":"paradigms.html","id":"tidy-evaluation","chapter":"7 Paradigmas de Programação","heading":"7.10.2 3. Tidy Evaluation","text":"Essas ferramentas de avaliação rlang formam o tidy evaluation framework, que é base tidyverse. É uma maneira de avaliar código non-standard.Por isso, não são todas funções que suportam. Use exec(), inject(), list2(), e eval_tidy() para trazer suporte tidy evaluation.eval_tidy() está presente na maior parte das funções tidyverse, e é dessa forma que pegamos uma expressão, avaliamos ela contexto de um dataframe e seu ambiente pai também é definido.Podemos usar pronomes .data$ e .env$ para clarificar de qual dessas duas coisas queremos tirar variáveis.","code":""},{"path":"paradigms.html","id":"outros-pontos","chapter":"7 Paradigmas de Programação","heading":"7.10.3 3. Outros Pontos","text":"É muito comum usar !!! em conjunto com ..., similar à ** python:E para fazer algo como o abaixo, precisamos de uma syntaxe especial para o R não brigar com gente:Para suportar ambos esses comportamentos, funções precisam colocar ... em list2(), aí dizemos que suportam “tidy dots”.","code":"\ndfs <- list(mtcars, mtcars)\ndplyr::bind_rows(!!!dfs)a <- sym(column1)\ntibble(!!a = 1:10) #> erro\ntibble(!!a := 1:10)"},{"path":"paradigms.html","id":"estudo-de-caso","chapter":"7 Paradigmas de Programação","heading":"7.10.4 Estudo de Caso","text":"Como usar isso para resolver problemas?Vamos criar uma função la dplyr::filter(), como filter2(mtcars, cyl == 4).","code":"\nfilter2 <- function(data, condition) {\n  keep <- eval_tidy(enquo(condition), data)\n  data[keep, ]\n}"},{"path":"paradigms.html","id":"estudo-de-caso-1","chapter":"7 Paradigmas de Programação","heading":"7.10.5 Estudo de Caso","text":"Como usar isso para resolver problemas?Vamos criar um wrapper de dplyr::mutate(), que pegue uma coluna e eleve ao quadrado.Acontece que esse é um padrão muito comum, e temos um atalho:","code":"\nmutate_squared <- function(data, col) {\n  col <- ensym(col)\n  dplyr::mutate(data, !!col := !!col ^ 2)\n}\nmutate_squared <- function(data, col) {\n  dplyr::mutate(data, {{col}} := {{col}} ^ 2)\n}"},{"path":"paradigms.html","id":"complemento-5","chapter":"7 Paradigmas de Programação","heading":"Complemento","text":"","code":""},{"path":"paradigms.html","id":"recapitulando-5","chapter":"7 Paradigmas de Programação","heading":"Recapitulando","text":"[fazer]","code":""},{"path":"paradigms.html","id":"dicionário-de-funções-5","chapter":"7 Paradigmas de Programação","heading":"Dicionário de Funções","text":"[fazer]","code":""},{"path":"paradigms.html","id":"referências-5","chapter":"7 Paradigmas de Programação","heading":"Referências","text":"[fazer]","code":""},{"path":"others1.html","id":"others1","chapter":"8 Outros Tópicos","heading":"8 Outros Tópicos","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"others1.html","id":"introdução-7","chapter":"8 Outros Tópicos","heading":"8.1 Introdução","text":"","code":""},{"path":"others1.html","id":"projetos-github-e-addins","chapter":"8 Outros Tópicos","heading":"8.2 Projetos, Github, e Addins","text":"","code":""},{"path":"others1.html","id":"debbuging","chapter":"8 Outros Tópicos","heading":"8.3 Debbuging","text":"","code":""},{"path":"others1.html","id":"gerenciamento-de-memória-e-performance","chapter":"8 Outros Tópicos","heading":"8.4 Gerenciamento de Memória e Performance","text":"","code":""},{"path":"others1.html","id":"organização-de-código-e-boas-práticas","chapter":"8 Outros Tópicos","heading":"8.5 Organização de Código e Boas Práticas","text":"","code":""},{"path":"others1.html","id":"complemento-6","chapter":"8 Outros Tópicos","heading":"Complemento","text":"","code":""},{"path":"others1.html","id":"recapitulando-6","chapter":"8 Outros Tópicos","heading":"Recapitulando","text":"","code":""},{"path":"others1.html","id":"dicionário-de-funções-6","chapter":"8 Outros Tópicos","heading":"Dicionário de Funções","text":"","code":""},{"path":"others1.html","id":"referências-6","chapter":"8 Outros Tópicos","heading":"Referências","text":"","code":""},{"path":"others1.html","id":"exercícios-3","chapter":"8 Outros Tópicos","heading":"Exercícios","text":"","code":""},{"path":"recap1.html","id":"recap1","chapter":"Recapitulando","heading":"Recapitulando","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Aqui, apresentarei o recapitulando da primeira parte, falando dos principais aprendizados sobre como o R funciona, e também relembrando os conceitos aprendidos.","code":""},{"path":"recap1.html","id":"dicionário-de-funções-7","chapter":"Recapitulando","heading":"Dicionário de Funções","text":"","code":""},{"path":"intro2.html","id":"intro2","chapter":"Introdução","heading":"Introdução","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Bem vindo à segunda parte deste livro. Aqui, foco em ensinar o Tidyverse. O Tidyverse é um conjunto de pacotes para o R, que seguem uma mesma filosofia e sintaxe, e disponibilizam ferramentas poderosas para maior parte das tarefas essencias em projetos R.Começo explicando essa filosfia e sintaxe, pois é intuição trazida por elas que fazem esse universo ser tão simples de aprender. seguir, ensino cada um dos pacotes base:Capítulo 9: descrevo os fundamentos e etapas de um projeto de ciência de dados. Também adianto como importar diferentes tipos de arquivos para o R usando o pacote “readr”.Capítulo 10: apresento ferramentas de manipulação de strings em “stringr”, e factors em “forcats”.Capítulo 11: descrevo os fundamentos e operações da manipulação de dados com os pacotes “dplyr” e “tidyr”.Capítulo 12: descrevo os fundamentos da visualização de dados com o pacote “ggplot2”.Capítulo 13: falo sobre aplicações da programação funcional com o pacote “purrr”.Capítulo 14: falo sobre manipulação de datas e séries de tempo com pacotes adicionais, como “lubridate”, e [pacote definir].Capítulo 15: falo sobre outros pacotes adicionais, como o framework “tidymodels”.Recapitulado: seção para retomar os conteúdos aprendidos.","code":""},{"path":"philosophy.html","id":"philosophy","chapter":"9 Filosofia, readr, tibble","heading":"9 Filosofia, readr, tibble","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"philosophy.html","id":"introdução-8","chapter":"9 Filosofia, readr, tibble","heading":"9.1 Introdução","text":"Referências: R4DS, tidyverse packages.Neste capítulo, descrevo os fundamentos e etapas de um projeto de ciência de dados. Também adianto como importar diferentes tipos de arquivos para o R usando o pacote “readr”.Haverão três aprendizados principais:() O que é data science, e os princípios tidyverse.\n(ii) Quais são operações de importing, tidying, e transforming que temos interesse.\n(iii) Como essas operações são implementadas nos pacotes tidyverse.Para os exemplos:","code":"\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)"},{"path":"philosophy.html","id":"ciência-de-dados","chapter":"9 Filosofia, readr, tibble","heading":"9.2 Ciência de Dados","text":"","code":""},{"path":"philosophy.html","id":"a-ciência-de-dados","chapter":"9 Filosofia, readr, tibble","heading":"9.2.1 A Ciência de Dados","text":"Ciência de Dados é um campo gigante, que nasceu via uma demanda de expandir estatística para vias de:“learn data”.“emphasis data preparation presentation rather statistical modeling”.“emphasis prediction rather inference”.Atualmente, o termo não é super bem definido, e o campo tem muita intersecção com outras disciplinas.","code":""},{"path":"philosophy.html","id":"as-etapas-de-um-projeto","chapter":"9 Filosofia, readr, tibble","heading":"9.2.2 As Etapas de um Projeto","text":"Mais interessante que ficar tentando definir disciplina, vamos entendê-la na prática. Um projeto comum, geral, se parece como abaixo:","code":""},{"path":"philosophy.html","id":"etapas-importing","chapter":"9 Filosofia, readr, tibble","heading":"9.2.3 Etapas: Importing","text":"primeira etapa é importação. Alguns comentários:Os dados podem vir de várias fontes, como arquivos locais, bancos de dados, APIs (application programming interface), ou de sites (via web scrapping).Os dados podem estar em vários formatos como CSV, Excel, JSON, entre outros. É interessante ter um conhecimento básico de como cada um funciona.Cada tipo de fonte tem uma maneira diferente de se interagir, e cada formato exige sua própria função.","code":""},{"path":"philosophy.html","id":"etapas-tidy","chapter":"9 Filosofia, readr, tibble","heading":"9.2.4 Etapas: Tidy","text":"próxima etapa é arrumar, tidy, os dados. Vamos falar sobre isso com mais detalhe, mas existe uma noção bem específica que são dados arrumados, tidy data.três próximas etapas existem dentro de um ciclo.","code":""},{"path":"philosophy.html","id":"etapas-transform","chapter":"9 Filosofia, readr, tibble","heading":"9.2.5 Etapas: Transform","text":"Mesmo com dados já arrumados, ainda temos o interesse de transformá-los, para conseguir obter insights novos da mesma base de dados.Visualizar e modelar os dados trará novos insights e novas demandas, de modo que estamos constantemente transformando os dados para criar novas visualizações e modelagens.Import, tidy e transform juntos são chamados de data wrangling.","code":""},{"path":"philosophy.html","id":"etapas-visualize","chapter":"9 Filosofia, readr, tibble","heading":"9.2.6 Etapas: Visualize","text":"Aqui, serei preguiçoso, o texto Hadley Wickham é muito bom:Visualisation fundamentally human activity. good visualisation show things expect, raise new questions data. good visualisation might also hint ’re asking wrong question, need collect different data. Visualisations can surprise , don’t scale particularly well require human interpret .","code":""},{"path":"philosophy.html","id":"etapas-model","chapter":"9 Filosofia, readr, tibble","heading":"9.2.7 Etapas: Model","text":"Um modelo é, em termos simplificados e depender contexto, um conjunto de hipóteses sobre o mundo – sobre o processo gerador dos dados –, acrescido com um método matemático e computacional de estimar esse processo.Models fundamentally mathematical computational tool, generally scale well. (…) every model makes assumptions, nature model question assumptions. means model fundamentally surprise .","code":""},{"path":"philosophy.html","id":"etapas-comunication","chapter":"9 Filosofia, readr, tibble","heading":"9.2.8 Etapas: Comunication","text":"O último passo é comunicação. linguagens de programação provém ferramentas para expor seus resultados. O próprio RMarkdown onde esta aula foi escrita é um exemplo disso. Mas existem muitas outras ferramentas mais avançadas para criar reports, livros, páginas na web, aplicativos, etc.","code":""},{"path":"philosophy.html","id":"programming","chapter":"9 Filosofia, readr, tibble","heading":"9.2.9 Programming","text":"Surrounding tools programming. Programming cross-cutting tool use every part project. don’t need expert programmer data scientist, learning programming pays becoming better programmer allows automate common tasks, solve new problems greater ease.","code":""},{"path":"philosophy.html","id":"tidyverse","chapter":"9 Filosofia, readr, tibble","heading":"9.2.10 Tidyverse","text":"tidyverse opinionated collection R packages designed data science. packages share underlying design philosophy, grammar, data structures.four basic principles tidy API:Reuse existing data structures.Compose simple functions pipe.Embrace functional programming.Design humans.","code":""},{"path":"philosophy.html","id":"pacotes-de-importing","chapter":"9 Filosofia, readr, tibble","heading":"9.3 Pacotes de Importing","text":"","code":""},{"path":"philosophy.html","id":"pacotes-de-importing-1","chapter":"9 Filosofia, readr, tibble","heading":"9.3.1 Pacotes de Importing","text":"O readr existe “provide fast friendly way read rectangular data delimited files”.O tidyverse também tem pacotes secundários para outros tipos de dados (.xlsx, .json, …), recomendo também estudar o readxl mínimo. Muitos deles usam argumentos similares.","code":""},{"path":"philosophy.html","id":"readr","chapter":"9 Filosofia, readr, tibble","heading":"9.3.2 readr","text":"Veja:O tutorial.cheatsheet.Leia documentação de:read_delim().read_fwf().read_table().","code":""},{"path":"philosophy.html","id":"argumentos-importantes","chapter":"9 Filosofia, readr, tibble","heading":"9.3.3 Argumentos Importantes","text":"Lembre-se de quais operações queremos poder fazer.Podemos escolher o que selecionar: skip, n_max, col_select, skip_empty_rows.Também é importante o “como” selecionar (parse):col_types. Veja mais artigo Column types.locale. Veja mais artigo Locale.name_repair.quote, comment, na.trim_ws.","code":""},{"path":"philosophy.html","id":"exemplo-1","chapter":"9 Filosofia, readr, tibble","heading":"9.3.4 Exemplo 1","text":"","code":"\ndata <-\n\"a,b,c,d\n1,2,'A',na\n3,4,'B',4\nfonte:IBGE,,,\"\n\nread_delim(I(data))\n#> # A tibble: 3 × 4\n#>   a              b c     d\n#>   <chr>      <dbl> <chr> <chr>\n#> 1 1              2 'A'   na\n#> 2 3              4 'B'   4\n#> 3 fonte:IBGE    NA NA    NA"},{"path":"philosophy.html","id":"exemplo-2","chapter":"9 Filosofia, readr, tibble","heading":"9.3.5 Exemplo 2","text":"","code":"\ndata <-\n\"a,b,c,d\n1,2,'A',na\n3,4,'B',4\nfonte:IBGE,,,\"\n\nread_delim(I(data),\n    col_types = list(c = col_factor()), #\"nnfn\"\n    col_select = c(b:d),\n    n_max = 2,\n    quote = \"'\", na = \"na\"\n)\n#> # A tibble: 2 × 3\n#>       b c         d\n#>   <dbl> <fct> <dbl>\n#> 1     2 A        NA\n#> 2     4 B         4"},{"path":"philosophy.html","id":"complemento-7","chapter":"9 Filosofia, readr, tibble","heading":"Complemento","text":"","code":""},{"path":"philosophy.html","id":"recapitulando-7","chapter":"9 Filosofia, readr, tibble","heading":"Recapitulando","text":"","code":""},{"path":"philosophy.html","id":"dicionário-de-funções-8","chapter":"9 Filosofia, readr, tibble","heading":"Dicionário de Funções","text":"","code":""},{"path":"philosophy.html","id":"referências-7","chapter":"9 Filosofia, readr, tibble","heading":"Referências","text":"","code":""},{"path":"philosophy.html","id":"exercícios-4","chapter":"9 Filosofia, readr, tibble","heading":"Exercícios","text":"","code":""},{"path":"stringr-forcats.html","id":"stringr-forcats","chapter":"10 stringr e forcats","heading":"10 stringr e forcats","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"stringr-forcats.html","id":"introdução-9","chapter":"10 stringr e forcats","heading":"10.1 Introdução","text":"Neste capítulo, falarei mais sobre strings e factors R. Apresento ferramentas de manipulação nos pacotes “stringr”, “forcats”, e “glue”.","code":""},{"path":"stringr-forcats.html","id":"strings","chapter":"10 stringr e forcats","heading":"10.2 Strings","text":"","code":""},{"path":"stringr-forcats.html","id":"matches","chapter":"10 stringr e forcats","heading":"10.2.1 Matches","text":"","code":""},{"path":"stringr-forcats.html","id":"mutate","chapter":"10 stringr e forcats","heading":"10.2.2 Mutate","text":"","code":""},{"path":"stringr-forcats.html","id":"subset-1","chapter":"10 stringr e forcats","heading":"10.2.3 Subset","text":"","code":""},{"path":"stringr-forcats.html","id":"join-and-split","chapter":"10 stringr e forcats","heading":"10.2.4 Join and Split","text":"","code":""},{"path":"stringr-forcats.html","id":"lengths","chapter":"10 stringr e forcats","heading":"10.2.5 Lengths","text":"","code":""},{"path":"stringr-forcats.html","id":"order","chapter":"10 stringr e forcats","heading":"10.2.6 Order","text":"","code":""},{"path":"stringr-forcats.html","id":"factors-1","chapter":"10 stringr e forcats","heading":"10.3 Factors","text":"","code":""},{"path":"stringr-forcats.html","id":"inspect","chapter":"10 stringr e forcats","heading":"10.3.1 Inspect","text":"","code":""},{"path":"stringr-forcats.html","id":"combine","chapter":"10 stringr e forcats","heading":"10.3.2 Combine","text":"","code":""},{"path":"stringr-forcats.html","id":"reorder","chapter":"10 stringr e forcats","heading":"10.3.3 Reorder","text":"","code":""},{"path":"stringr-forcats.html","id":"revalue","chapter":"10 stringr e forcats","heading":"10.3.4 Revalue","text":"","code":""},{"path":"stringr-forcats.html","id":"relevel","chapter":"10 stringr e forcats","heading":"10.3.5 Relevel","text":"","code":""},{"path":"stringr-forcats.html","id":"complemento-8","chapter":"10 stringr e forcats","heading":"Complemento","text":"","code":""},{"path":"stringr-forcats.html","id":"recapitulando-8","chapter":"10 stringr e forcats","heading":"Recapitulando","text":"","code":""},{"path":"stringr-forcats.html","id":"dicionário-de-funções-9","chapter":"10 stringr e forcats","heading":"Dicionário de Funções","text":"","code":""},{"path":"stringr-forcats.html","id":"referências-8","chapter":"10 stringr e forcats","heading":"Referências","text":"","code":""},{"path":"stringr-forcats.html","id":"exercícios-5","chapter":"10 stringr e forcats","heading":"Exercícios","text":"","code":""},{"path":"tidyr-dplyr.html","id":"tidyr-dplyr","chapter":"11 tidyr e dplyr","heading":"11 tidyr e dplyr","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"tidyr-dplyr.html","id":"introdução-10","chapter":"11 tidyr e dplyr","heading":"11.1 Introdução","text":"Neste capítulo, descreverei os fundamentos e operações da manipulação de dados. Falo como aplicá-las usando os pacotes “dplyr” e “tidyr”.","code":""},{"path":"tidyr-dplyr.html","id":"importing-e-wrangling","chapter":"11 tidyr e dplyr","heading":"11.2 Importing e Wrangling","text":"","code":""},{"path":"tidyr-dplyr.html","id":"importing","chapter":"11 tidyr e dplyr","heading":"11.2.1 Importing","text":"Não tem muito erro, tem que saber como são os formatos de arquivo que existem. Veja o ex 5 da lista 4 trainee.Cada arquivo, depender seu tipo, tem configurações diferentes. Ex: um arquivo CSV pode ser separado por , ou ;, qual planilha quista de um .xlsx. Esse tipo de configuração precisa ser passada para função que lê o arquivo.Também podemos estar interessados em:Pular linhas e colunas.Definir tipos das colunas.Especificar o que define strings (ex ' ou \"), comentários (ex #), e valores NA.","code":""},{"path":"tidyr-dplyr.html","id":"tidy-data","chapter":"11 tidyr e dplyr","heading":"11.2.2 Tidy Data","text":"Antes de falar sobre tidying, vamos falar sobre o que é um dataset tidy.Veja aula 4 trainee.Para ciência de dados, será útil utilizar uma organização específica, chamada de “tidy dataset”. Três regras definem:Cada variável deve ter sua própria coluna.Cada observação deve ter sua própria linha.Cada valor deve ter sua própria célula.","code":""},{"path":"tidyr-dplyr.html","id":"tidy-data-1","chapter":"11 tidyr e dplyr","heading":"11.2.3 Tidy Data","text":"Quais os benefícios?consistência de utilizar uma mesma organização, independente de qual, é muito útil, especialmente porque facilita entender ferramentas que trabalharão com ela.arrumação tidy é intuitiva, e é utilizada de maneira muito natural nas ferramentas, muitaz vezes vetorizadas, de visualização e modelagem.","code":""},{"path":"tidyr-dplyr.html","id":"tidying","chapter":"11 tidyr e dplyr","heading":"11.2.4 Tidying","text":"Agora que já entendemos o que é tidy data, podemos adquirir habilidade de olhar para um dataset e, sabendo onde queremos chegar, elencar quais são alterações serem feitas.Após elencar quais alterações devem ser feitas, é simples fazer ponte de quais manipulações de dados você quer fazer – “subset linhas” e “separar colunas”.Por fim, só falta relembrar como é o código que aplica essa manipulação. Essa é parte mais simples! É só voltar na aula passada, pesquisar na internet, ver chat, ou perguntar para o seu amigo preferido!","code":""},{"path":"tidyr-dplyr.html","id":"tidying-básico","chapter":"11 tidyr e dplyr","heading":"11.2.5 Tidying: Básico","text":"","code":""},{"path":"tidyr-dplyr.html","id":"tidying-nas","chapter":"11 tidyr e dplyr","heading":"11.2.6 Tidying: NAs","text":"","code":""},{"path":"tidyr-dplyr.html","id":"tidying-pivot","chapter":"11 tidyr e dplyr","heading":"11.2.7 Tidying: Pivot","text":"","code":""},{"path":"tidyr-dplyr.html","id":"tidying-pivot-1","chapter":"11 tidyr e dplyr","heading":"11.2.8 Tidying: Pivot","text":"","code":""},{"path":"tidyr-dplyr.html","id":"tidying-merge","chapter":"11 tidyr e dplyr","heading":"11.2.9 Tidying: Merge","text":"","code":""},{"path":"tidyr-dplyr.html","id":"tidying-receita","chapter":"11 tidyr e dplyr","heading":"11.2.10 Tidying: Receita","text":"Qual foi receitinha de bolo que aprendemos? (hmm bolo 😋). Recebemos um dataset, e:Arrumar os dados para o formato data frame.\nTodas colunas são homogêneas?\nRemover linhas “ruins”, converter valores.\n\nTodas colunas são mesmo tamanho?\nRemover linhas “ruins”.\n\nTodas colunas são homogêneas?\nRemover linhas “ruins”, converter valores.\nRemover linhas “ruins”, converter valores.Todas colunas são mesmo tamanho?\nRemover linhas “ruins”.\nRemover linhas “ruins”.","code":""},{"path":"tidyr-dplyr.html","id":"tidying-receita-1","chapter":"11 tidyr e dplyr","heading":"11.2.11 Tidying: Receita","text":"Arrumar os dados para o formato tidy.\nToda coluna é uma variável?\nRemover colunas “ruins”.\nSeparar/unir colunas colunas.\n\nToda linha é uma observação?\nQuais são variáveis que definem uma observação?\nPivot e melt.\n\nToda coluna é uma variável?\nRemover colunas “ruins”.\nSeparar/unir colunas colunas.\nRemover colunas “ruins”.Separar/unir colunas colunas.Toda linha é uma observação?\nQuais são variáveis que definem uma observação?\nPivot e melt.\nQuais são variáveis que definem uma observação?Pivot e melt.","code":""},{"path":"tidyr-dplyr.html","id":"tidying-receita-2","chapter":"11 tidyr e dplyr","heading":"11.2.12 Tidying: Receita","text":"Dados NA.\nTransformar dados “ruins” em NA.\nLidar com dados NA.\nTransformar dados “ruins” em NA.Lidar com dados NA.Tenho mais de um dataset? Deixá-los tidy e então realizaram algum merge.","code":""},{"path":"tidyr-dplyr.html","id":"transforming","chapter":"11 tidyr e dplyr","heading":"11.2.13 Transforming","text":"Após arrumarmos um dataset, ainda aplicaremos transformações com base nas demandas da fase de visualização e modelagem.Manipular linhas.\nSorting.\nSampling.\nFiltrar observações.\nSorting.Sampling.Filtrar observações.","code":""},{"path":"tidyr-dplyr.html","id":"transforming-1","chapter":"11 tidyr e dplyr","heading":"11.2.14 Transforming","text":"Transformar/criar colunas:\nAlterar unidade de uma variável.\nNormalizar variáveis.\nAgrupar categorias de uma variável categórica.\nCorrigir/formatar texto de variáveis string.\nManipular datas.\nCriar novas colunas partir de operações com múltiplas outras.\nCriar uma coluna para ajudar em um plot.\nAlterar unidade de uma variável.Normalizar variáveis.Agrupar categorias de uma variável categórica.Corrigir/formatar texto de variáveis string.Manipular datas.Criar novas colunas partir de operações com múltiplas outras.Criar uma coluna para ajudar em um plot.","code":""},{"path":"tidyr-dplyr.html","id":"tidyr","chapter":"11 tidyr e dplyr","heading":"11.3 tidyr","text":"O tidyr existe “help create tidy data”.Veja:O tutorial.cheatsheet.Aqui, temos caixinhas:Reshape (pivot)Separate/uniteNA handling (+ complete)Outros: lists dataframes (unnest)","code":""},{"path":"tidyr-dplyr.html","id":"separate","chapter":"11 tidyr e dplyr","heading":"11.3.1 Separate","text":"","code":"\ndf <- tibble(id = 1:3, x = c(\"m-123\", \"f-455\", \"f-123\"))\n\ndf %>% separate_wider_delim(x, delim = \"-\", names = c(\"gender\", \"unit\"))\ndf %>% separate_wider_position(x, c(gender = 1, 1, unit = 3))\ndf %>% separate_wider_regex(x, c(gender = \".\", \".\", unit = \"\\\\d+\"))\n#> # A tibble: 3 × 3\n#>      id gender unit \n#>   <int> <chr>  <chr>\n#> 1     1 m      123  \n#> 2     2 f      455  \n#> 3     3 f      123"},{"path":"tidyr-dplyr.html","id":"na-handling-1","chapter":"11 tidyr e dplyr","heading":"11.3.2 NA Handling 1","text":"","code":"\ndf <- tibble(x = c(1, 2, NA), y = c(\"a\", NA, \"b\"))\n\ndf %>% drop_na(x)\n#> # A tibble: 2 × 2\n#>       x y\n#>   <dbl> <chr>\n#> 1     1 a\n#> 2     2 NA\n\ndf %>% replace_na(list(x = 0, y = \"unknown\"))\n#> # A tibble: 3 × 2\n#>       x y\n#>   <dbl> <chr>\n#> 1     1 a\n#> 2     2 unknown\n#> 3     0 b\n\ndf %>% fill(x, y)\n#> # A tibble: 3 × 2\n#>       x y\n#>   <dbl> <chr>\n#> 1     1 a\n#> 2     2 a\n#> 3     2 b"},{"path":"tidyr-dplyr.html","id":"na-handling-2","chapter":"11 tidyr e dplyr","heading":"11.3.3 NA Handling 2","text":"Complete: explicitar valores faltantes","code":"\ndf %>% complete(x, y)\n#> # A tibble: 9 × 2\n#>       x y\n#>   <dbl> <chr>\n#> 1     1 a\n#> 2     1 b\n#> 3     1 NA\n#> 4     2 a\n#> 5     2 b\n#> 6     2 NA\n#> 7    NA a\n#> 8    NA b\n#> 9    NA NA"},{"path":"tidyr-dplyr.html","id":"reshape","chapter":"11 tidyr e dplyr","heading":"11.3.4 Reshape","text":"Veja o artigo Pivoting.Exemplos R.","code":""},{"path":"tidyr-dplyr.html","id":"dplyr","chapter":"11 tidyr e dplyr","heading":"11.4 dplyr","text":"O dplyr é “grammar data manipulation, providing consistent set verbs help solve common data manipulation challenges”.Veja:O tutorial.cheatsheet.Aqui, temos caixinhas:SubsetOperateReorderRenameCombineSummarizeE tudo isso com groups","code":""},{"path":"tidyr-dplyr.html","id":"subset---linhas","chapter":"11 tidyr e dplyr","heading":"11.4.1 Subset - Linhas","text":"filter():Casos especiais:","code":"\nstarwars %>% filter(mass > mean(mass, na.rm = TRUE))\nstarwars %>% filter(n() %in% 1:10)\nstarwars %>% slice(1:10)\nstarwars %>% filter(!duplicated(mass))\nstarwars %>% distinct(mass, .keep_all = TRUE)"},{"path":"tidyr-dplyr.html","id":"subset---colunas","chapter":"11 tidyr e dplyr","heading":"11.4.2 Subset - Colunas","text":"select():Permite usar vários selection helpers:","code":"\nstarwars %>% select(homeworld, height, mass)\nstarwars %>% select(name:mass)\nstarwars %>% select(!(name:mass))\niris %>% select(starts_with(\"Petal\") & ends_with(\"Width\"))"},{"path":"tidyr-dplyr.html","id":"operate","chapter":"11 tidyr e dplyr","heading":"11.4.3 Operate","text":"mutate():rows_*():","code":"\nstarwars %>%\n  mutate(\n    mass2 = mass * 2,\n    mass2_squared = mass2 ^ 2\n  )\ndata <- tibble(a = 1:3, b = letters[1:3], c = 0.5 + 0:2)\nrows_insert(data, tibble(a = 4, b = \"z\"))\n#> # A tibble: 4 × 3\n#>       a b         c\n#>   <int> <chr> <dbl>\n#> 1     1 a       0.5\n#> 2     2 b       1.5\n#> 3     3 NA      2.5\n#> 4     4 z      NA "},{"path":"tidyr-dplyr.html","id":"reorder-1","chapter":"11 tidyr e dplyr","heading":"11.4.4 Reorder","text":"arrange():select() funciona! Mas também temos relocate():","code":"\nby_cyl %>% arrange(wt)\nby_cyl %>% arrange(desc(wt))\nmtcars %>% relocate(vs:gear, .before = cyl)"},{"path":"tidyr-dplyr.html","id":"rename","chapter":"11 tidyr e dplyr","heading":"11.4.5 Rename","text":"filosofia tidyverse é não utilizar rownames (“metadata data”). Portanto, temos funções para renomear colunas, rename() e rename_with():","code":"\nrename(iris, petal_length = Petal.Length)\nrename_with(iris, toupper)"},{"path":"tidyr-dplyr.html","id":"summarize","chapter":"11 tidyr e dplyr","heading":"11.4.6 Summarize","text":"summarise(), resumir toda informação em uma linha:reframe() mais raro, mais de uma linha de resumo:","code":"\nmtcars %>% summarise(mean = mean(disp), n = n())\n#>       mean  n\n#> 1 230.7219 32\nmtcars %>% reframe(mean = quantile(disp, c(0.25, 0.75)), n = n())\n#>      mean  n\n#> 1 120.825 32\n#> 2 326.000 32"},{"path":"tidyr-dplyr.html","id":"combine-1","chapter":"11 tidyr e dplyr","heading":"11.4.7 Combine","text":"cbind() une colunas de dois dataframes com “mesmas” linhas. rbind une linhas de dois dataframes com “mesmas” colunas.bind_cols() e bind_rows() são versões dplyr, e unem qualquer quantidade de dataframes.E se linhas não forem mesmas? Precisamos de um merge/join: inner_join(), left_join(), right_join(), full_join().","code":""},{"path":"tidyr-dplyr.html","id":"across","chapter":"11 tidyr e dplyr","heading":"11.4.8 Across","text":"Como visto em select(), temos uma série de tidyverse selection helpers que podem ser utilizados para selecionar colunas.Esses mesmos seletores podem ser utilizados em outros verbos, via across():","code":"\nmtcars %>% filter(if_all(mpg:cyl, ~ .x > mean(.x)))\nmtcars %>% mutate(across(everything(), as.character()))\nmtcars %>% mutate(across(where(~ sum(.x) > 100), ~ .x - 100))"},{"path":"tidyr-dplyr.html","id":"groups","chapter":"11 tidyr e dplyr","heading":"11.4.9 Groups","text":"Um grupo pra cada linha: rowwise().","code":"\nmtcars %>%\n    split(.$cyl) %>%\n    purrr:::map_dfr(~ c(cyl = unique(.x$cyl), disp = mean(.x$disp)))\nmtcars %>%\n    group_by(cyl) %>%\n    summarise(mean = mean(disp))"},{"path":"tidyr-dplyr.html","id":"eval_tidy","chapter":"11 tidyr e dplyr","heading":"11.4.10 eval_tidy","text":"Lembre de e rlang::eval_tidy:","code":"\nmtcars %>%\n    with(cyl + disp)"},{"path":"tidyr-dplyr.html","id":"complemento-9","chapter":"11 tidyr e dplyr","heading":"Complemento","text":"","code":""},{"path":"tidyr-dplyr.html","id":"recapitulando-9","chapter":"11 tidyr e dplyr","heading":"Recapitulando","text":"","code":""},{"path":"tidyr-dplyr.html","id":"dicionário-de-funções-10","chapter":"11 tidyr e dplyr","heading":"Dicionário de Funções","text":"","code":""},{"path":"tidyr-dplyr.html","id":"referências-9","chapter":"11 tidyr e dplyr","heading":"Referências","text":"","code":""},{"path":"tidyr-dplyr.html","id":"exercícios-6","chapter":"11 tidyr e dplyr","heading":"Exercícios","text":"","code":""},{"path":"ggplot.html","id":"ggplot","chapter":"12 ggplot2","heading":"12 ggplot2","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"ggplot.html","id":"introdução-11","chapter":"12 ggplot2","heading":"12.1 Introdução","text":"Neste capítulo, descreverei os fundamentos da visualização de dados. Falo como aplicá-la usando o pacote “ggplot2”.","code":""},{"path":"ggplot.html","id":"visualização","chapter":"12 ggplot2","heading":"12.2 Visualização","text":"","code":""},{"path":"ggplot.html","id":"layers","chapter":"12 ggplot2","heading":"12.3 Layers","text":"","code":""},{"path":"ggplot.html","id":"scales","chapter":"12 ggplot2","heading":"12.4 Scales","text":"","code":""},{"path":"ggplot.html","id":"grammar","chapter":"12 ggplot2","heading":"12.5 Grammar","text":"","code":""},{"path":"ggplot.html","id":"others","chapter":"12 ggplot2","heading":"12.6 Others","text":"","code":""},{"path":"ggplot.html","id":"complemento-10","chapter":"12 ggplot2","heading":"Complemento","text":"","code":""},{"path":"ggplot.html","id":"recapitulando-10","chapter":"12 ggplot2","heading":"Recapitulando","text":"","code":""},{"path":"ggplot.html","id":"dicionário-de-funções-11","chapter":"12 ggplot2","heading":"Dicionário de Funções","text":"","code":""},{"path":"ggplot.html","id":"referências-10","chapter":"12 ggplot2","heading":"Referências","text":"","code":""},{"path":"ggplot.html","id":"exercícios-7","chapter":"12 ggplot2","heading":"Exercícios","text":"","code":""},{"path":"purrr.html","id":"purrr","chapter":"13 purrr","heading":"13 purrr","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"purrr.html","id":"introdução-12","chapter":"13 purrr","heading":"13.1 Introdução","text":"Neste capítulo, falarei sobre aplicações da programação funcional com o pacote “purrr”.","code":""},{"path":"purrr.html","id":"map-3","chapter":"13 purrr","heading":"13.2 Map","text":"","code":""},{"path":"purrr.html","id":"map-1-1","chapter":"13 purrr","heading":"13.2.1 Map 1","text":"","code":""},{"path":"purrr.html","id":"map-2-1","chapter":"13 purrr","heading":"13.2.2 Map 2","text":"","code":""},{"path":"purrr.html","id":"map-p-1","chapter":"13 purrr","heading":"13.2.3 Map p","text":"","code":""},{"path":"purrr.html","id":"others-1","chapter":"13 purrr","heading":"13.3 Others","text":"","code":""},{"path":"purrr.html","id":"modify","chapter":"13 purrr","heading":"13.3.1 Modify","text":"","code":""},{"path":"purrr.html","id":"reduce-1","chapter":"13 purrr","heading":"13.3.2 Reduce","text":"","code":""},{"path":"purrr.html","id":"predicates","chapter":"13 purrr","heading":"13.3.3 Predicates","text":"","code":""},{"path":"purrr.html","id":"pluck","chapter":"13 purrr","heading":"13.3.4 Pluck","text":"","code":""},{"path":"purrr.html","id":"reshape-1","chapter":"13 purrr","heading":"13.3.5 Reshape","text":"","code":""},{"path":"purrr.html","id":"concatenate","chapter":"13 purrr","heading":"13.3.6 Concatenate","text":"","code":""},{"path":"purrr.html","id":"complemento-11","chapter":"13 purrr","heading":"Complemento","text":"","code":""},{"path":"purrr.html","id":"recapitulando-11","chapter":"13 purrr","heading":"Recapitulando","text":"","code":""},{"path":"purrr.html","id":"dicionário-de-funções-12","chapter":"13 purrr","heading":"Dicionário de Funções","text":"","code":""},{"path":"purrr.html","id":"referências-11","chapter":"13 purrr","heading":"Referências","text":"","code":""},{"path":"purrr.html","id":"exercícios-8","chapter":"13 purrr","heading":"Exercícios","text":"","code":""},{"path":"time-series.html","id":"time-series","chapter":"14 Datas e Séries de Tempo","heading":"14 Datas e Séries de Tempo","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"time-series.html","id":"introdução-13","chapter":"14 Datas e Séries de Tempo","heading":"14.1 Introdução","text":"Neste capítulo, falarei sobre manipulação de datas e séries de tempo com o pacote “lubridate”, e [pacote definir].","code":""},{"path":"time-series.html","id":"dates","chapter":"14 Datas e Séries de Tempo","heading":"14.2 Dates","text":"","code":""},{"path":"time-series.html","id":"parsing-1","chapter":"14 Datas e Séries de Tempo","heading":"14.2.1 Parsing","text":"","code":""},{"path":"time-series.html","id":"mutate-1","chapter":"14 Datas e Séries de Tempo","heading":"14.2.2 Mutate","text":"","code":""},{"path":"time-series.html","id":"time-zones","chapter":"14 Datas e Séries de Tempo","heading":"14.2.3 Time Zones","text":"","code":""},{"path":"time-series.html","id":"math","chapter":"14 Datas e Séries de Tempo","heading":"14.2.4 Math","text":"","code":""},{"path":"time-series.html","id":"periods-durations-e-intervals","chapter":"14 Datas e Séries de Tempo","heading":"14.2.5 Periods, Durations, e Intervals","text":"","code":""},{"path":"time-series.html","id":"time-series-1","chapter":"14 Datas e Séries de Tempo","heading":"14.3 Time Series","text":"","code":""},{"path":"time-series.html","id":"complemento-12","chapter":"14 Datas e Séries de Tempo","heading":"Complemento","text":"","code":""},{"path":"time-series.html","id":"recapitulando-12","chapter":"14 Datas e Séries de Tempo","heading":"Recapitulando","text":"","code":""},{"path":"time-series.html","id":"dicionário-de-funções-13","chapter":"14 Datas e Séries de Tempo","heading":"Dicionário de Funções","text":"","code":""},{"path":"time-series.html","id":"referências-12","chapter":"14 Datas e Séries de Tempo","heading":"Referências","text":"","code":""},{"path":"time-series.html","id":"exercícios-9","chapter":"14 Datas e Séries de Tempo","heading":"Exercícios","text":"","code":""},{"path":"others2.html","id":"others2","chapter":"15 Outros","heading":"15 Outros","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"others2.html","id":"introdução-14","chapter":"15 Outros","heading":"15.1 Introdução","text":"Neste capítulo, falo sobre outros pacotes adicionais, como o framework “tidymodels”.","code":""},{"path":"others2.html","id":"complemento-13","chapter":"15 Outros","heading":"Complemento","text":"","code":""},{"path":"others2.html","id":"recapitulando-13","chapter":"15 Outros","heading":"Recapitulando","text":"","code":""},{"path":"others2.html","id":"dicionário-de-funções-14","chapter":"15 Outros","heading":"Dicionário de Funções","text":"","code":""},{"path":"others2.html","id":"referências-13","chapter":"15 Outros","heading":"Referências","text":"","code":""},{"path":"others2.html","id":"exercícios-10","chapter":"15 Outros","heading":"Exercícios","text":"","code":""},{"path":"recap2.html","id":"recap2","chapter":"Recapitulando","heading":"Recapitulando","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Aqui, apresentarei o recapitulando da segunda parte, falando dos fundamentos tidyverse e cada uma de suas ferramentas.","code":""},{"path":"recap2.html","id":"dicionário-de-funções-15","chapter":"Recapitulando","heading":"Dicionário de Funções","text":"","code":""},{"path":"intro3.html","id":"intro3","chapter":"Introdução","heading":"Introdução","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Bem vindo à segunda parte deste livro. Aqui, foco em ensinar sobre o que é ciência de dados, e o formato de tidy data. Ensino também o processo de obter esse formato: importar, arrumar, manipular, e unir bases de dados. Por fim, vamos descobrir como habilidades de visualização de dados para explorá-los, obtendo intuições para etapa da modelagem.Os capítulos estão organizados por etapas de um projeto de ciência de dados:Capítulo 16: descrevo os fundamentos e etapas de um projeto de ciência de dados e o que é tidy data.Capítulo 17: descrevo como importar e arrumar dados.Capítulo 18: descrevo outras manipulações que dados já arrumados podem exigir.Capítulo 19: descrevo unir (merge) várias bases de dados em uma só.Recapitulado: seção para retomar os conteúdos aprendidos.","code":""},{"path":"ds.html","id":"ds","chapter":"16 Ciência de Dados","heading":"16 Ciência de Dados","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"ds.html","id":"introdução-15","chapter":"16 Ciência de Dados","heading":"16.1 Introdução","text":"Neste capítulo, descreverei os fundamentos e etapas de um projeto de ciência de dados, e como é o formato de tidy data.","code":""},{"path":"ds.html","id":"ciência-de-dados-1","chapter":"16 Ciência de Dados","heading":"16.2 Ciência de Dados","text":"","code":""},{"path":"ds.html","id":"introdução-16","chapter":"16 Ciência de Dados","heading":"16.2.1 Introdução","text":"","code":""},{"path":"ds.html","id":"preparar","chapter":"16 Ciência de Dados","heading":"16.2.2 Preparar","text":"","code":""},{"path":"ds.html","id":"entender-e-explorar","chapter":"16 Ciência de Dados","heading":"16.2.3 Entender e Explorar","text":"","code":""},{"path":"ds.html","id":"comunicar-e-executar","chapter":"16 Ciência de Dados","heading":"16.2.4 Comunicar e Executar","text":"","code":""},{"path":"ds.html","id":"complemento-14","chapter":"16 Ciência de Dados","heading":"Complemento","text":"","code":""},{"path":"ds.html","id":"recapitulando-14","chapter":"16 Ciência de Dados","heading":"Recapitulando","text":"","code":""},{"path":"ds.html","id":"dicionário-de-funções-16","chapter":"16 Ciência de Dados","heading":"Dicionário de Funções","text":"","code":""},{"path":"ds.html","id":"referências-14","chapter":"16 Ciência de Dados","heading":"Referências","text":"","code":""},{"path":"ds.html","id":"exercícios-11","chapter":"16 Ciência de Dados","heading":"Exercícios","text":"","code":""},{"path":"import-tidy.html","id":"import-tidy","chapter":"17 Importar e Arrumar","heading":"17 Importar e Arrumar","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"import-tidy.html","id":"introdução-17","chapter":"17 Importar e Arrumar","heading":"17.1 Introdução","text":"Neste capítulo, descreverei como importar diferentes tipos de arquivos para o R usando o pacote “readr”. Também descreverei como obter o formato “arrumado” de dados, utilizando os pacotes tidyr e dplyr.","code":""},{"path":"import-tidy.html","id":"complemento-15","chapter":"17 Importar e Arrumar","heading":"Complemento","text":"","code":""},{"path":"import-tidy.html","id":"recapitulando-15","chapter":"17 Importar e Arrumar","heading":"Recapitulando","text":"","code":""},{"path":"import-tidy.html","id":"dicionário-de-funções-17","chapter":"17 Importar e Arrumar","heading":"Dicionário de Funções","text":"","code":""},{"path":"import-tidy.html","id":"referências-15","chapter":"17 Importar e Arrumar","heading":"Referências","text":"","code":""},{"path":"import-tidy.html","id":"exercícios-12","chapter":"17 Importar e Arrumar","heading":"Exercícios","text":"","code":""},{"path":"manipulate.html","id":"manipulate","chapter":"18 Manipular","heading":"18 Manipular","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"manipulate.html","id":"introdução-18","chapter":"18 Manipular","heading":"18.1 Introdução","text":"Neste capítulo, descreverei alterações que podemos querer fazer em um dataset já arrumado.","code":""},{"path":"manipulate.html","id":"complemento-16","chapter":"18 Manipular","heading":"Complemento","text":"","code":""},{"path":"manipulate.html","id":"recapitulando-16","chapter":"18 Manipular","heading":"Recapitulando","text":"","code":""},{"path":"manipulate.html","id":"dicionário-de-funções-18","chapter":"18 Manipular","heading":"Dicionário de Funções","text":"","code":""},{"path":"manipulate.html","id":"referências-16","chapter":"18 Manipular","heading":"Referências","text":"","code":""},{"path":"manipulate.html","id":"exercícios-13","chapter":"18 Manipular","heading":"Exercícios","text":"","code":""},{"path":"unite.html","id":"unite","chapter":"19 Unir","heading":"19 Unir","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"unite.html","id":"introdução-19","chapter":"19 Unir","heading":"19.1 Introdução","text":"Neste capítulo, descreverei como unir bases de dados em uma.","code":""},{"path":"unite.html","id":"complemento-17","chapter":"19 Unir","heading":"Complemento","text":"","code":""},{"path":"unite.html","id":"recapitulando-17","chapter":"19 Unir","heading":"Recapitulando","text":"","code":""},{"path":"unite.html","id":"dicionário-de-funções-19","chapter":"19 Unir","heading":"Dicionário de Funções","text":"","code":""},{"path":"unite.html","id":"referências-17","chapter":"19 Unir","heading":"Referências","text":"","code":""},{"path":"unite.html","id":"exercícios-14","chapter":"19 Unir","heading":"Exercícios","text":"","code":""},{"path":"recap3.html","id":"recap3","chapter":"Recapitulando","heading":"Recapitulando","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Aqui, apresentarei o recapitulando da terceira parte, falando dos fundamentos da ciência de dados e suas etapas iniciais.","code":""},{"path":"recap3.html","id":"dicionário-de-funções-20","chapter":"Recapitulando","heading":"Dicionário de Funções","text":"","code":""},{"path":"visualize.html","id":"visualize","chapter":"20 Visualizar","heading":"20 Visualizar","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"visualize.html","id":"introdução-20","chapter":"20 Visualizar","heading":"20.1 Introdução","text":"Neste capítulo, apresentarei como aplicar habilidades de manipulação e visualização de dados, para explorar e obter informações contidas em datasets.","code":""},{"path":"visualize.html","id":"visualizações-úteis","chapter":"20 Visualizar","heading":"20.2 Visualizações Úteis","text":"","code":""},{"path":"visualize.html","id":"métricas-úteis","chapter":"20 Visualizar","heading":"20.3 Métricas Úteis","text":"","code":""},{"path":"visualize.html","id":"gráficos-úteis","chapter":"20 Visualizar","heading":"20.4 Gráficos Úteis","text":"","code":""},{"path":"visualize.html","id":"complemento-18","chapter":"20 Visualizar","heading":"Complemento","text":"","code":""},{"path":"visualize.html","id":"recapitulando-18","chapter":"20 Visualizar","heading":"Recapitulando","text":"","code":""},{"path":"visualize.html","id":"dicionário-de-funções-21","chapter":"20 Visualizar","heading":"Dicionário de Funções","text":"","code":""},{"path":"visualize.html","id":"referências-18","chapter":"20 Visualizar","heading":"Referências","text":"","code":""},{"path":"visualize.html","id":"exercícios-15","chapter":"20 Visualizar","heading":"Exercícios","text":"","code":""},{"path":"intro4.html","id":"intro4","chapter":"Introdução","heading":"Introdução","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Bem vindo à quarta e última parte deste livro. Aqui, irei ensinar mais uma etapa de projetos de ciência de dados, modelagem.Agora sim, o estilo livro é bem mais mostrar capacidades R através de exemplos, que o estudo teórico das outras seções.Os temas são:Capítulo 20: descrevo os fundamentos da visualização de dados, e como explorar dados para adquirir intuições.Capítulo 21: apresento como resolver problemas comuns em probabilidade e estatística, o assunto central R.Capítulo 22: apresento como realizar análises de regressões, com base nos vários modelos comuns inclusos R.Capítulo 23: complementar à regressões, apresento rapidamente alguns frameworks para modelos mais complexos de machine learning.Capítulo 24: para servir de referência, listo outras aplicações de possível interesse, especialmente aquelas com relação aos conceitos deste livro.Recapitulado: seção para retomar os conteúdos aprendidos.","code":""},{"path":"stats-prob.html","id":"stats-prob","chapter":"21 Probabilidade e Estatística","heading":"21 Probabilidade e Estatística","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"stats-prob.html","id":"introdução-21","chapter":"21 Probabilidade e Estatística","heading":"21.1 Introdução","text":"Neste capítulo, apresentarei como resolver problemas comuns em probabilidade e estatística, o assunto central R.","code":""},{"path":"stats-prob.html","id":"probability","chapter":"21 Probabilidade e Estatística","heading":"21.2 Probability","text":"","code":""},{"path":"stats-prob.html","id":"random-numbers","chapter":"21 Probabilidade e Estatística","heading":"21.2.1 Random Numbers","text":"","code":""},{"path":"stats-prob.html","id":"useful-measures","chapter":"21 Probabilidade e Estatística","heading":"21.2.2 Useful Measures","text":"","code":""},{"path":"stats-prob.html","id":"statistics","chapter":"21 Probabilidade e Estatística","heading":"21.3 Statistics","text":"","code":""},{"path":"stats-prob.html","id":"useful-measures-1","chapter":"21 Probabilidade e Estatística","heading":"21.3.1 Useful Measures","text":"","code":""},{"path":"stats-prob.html","id":"hypothesis-testing","chapter":"21 Probabilidade e Estatística","heading":"21.3.2 Hypothesis Testing","text":"","code":""},{"path":"stats-prob.html","id":"complemento-19","chapter":"21 Probabilidade e Estatística","heading":"Complemento","text":"","code":""},{"path":"stats-prob.html","id":"recapitulando-19","chapter":"21 Probabilidade e Estatística","heading":"Recapitulando","text":"","code":""},{"path":"stats-prob.html","id":"dicionário-de-funções-22","chapter":"21 Probabilidade e Estatística","heading":"Dicionário de Funções","text":"","code":""},{"path":"stats-prob.html","id":"referências-19","chapter":"21 Probabilidade e Estatística","heading":"Referências","text":"","code":""},{"path":"stats-prob.html","id":"exercícios-16","chapter":"21 Probabilidade e Estatística","heading":"Exercícios","text":"","code":""},{"path":"regression.html","id":"regression","chapter":"22 Regressão","heading":"22 Regressão","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"regression.html","id":"introdução-22","chapter":"22 Regressão","heading":"22.1 Introdução","text":"Neste capítulo, apresentarei como realizar análises de regressões, com base nos vários modelos comuns inclusos R.","code":""},{"path":"regression.html","id":"fundamentals","chapter":"22 Regressão","heading":"22.2 Fundamentals","text":"","code":""},{"path":"regression.html","id":"data","chapter":"22 Regressão","heading":"22.2.1 Data","text":"","code":""},{"path":"regression.html","id":"formulas","chapter":"22 Regressão","heading":"22.2.2 Formulas","text":"","code":""},{"path":"regression.html","id":"fitting","chapter":"22 Regressão","heading":"22.2.3 Fitting","text":"","code":""},{"path":"regression.html","id":"visualizing","chapter":"22 Regressão","heading":"22.2.4 Visualizing","text":"","code":""},{"path":"regression.html","id":"testing","chapter":"22 Regressão","heading":"22.2.5 Testing","text":"","code":""},{"path":"regression.html","id":"correcting","chapter":"22 Regressão","heading":"22.2.6 Correcting","text":"","code":""},{"path":"regression.html","id":"linear-models","chapter":"22 Regressão","heading":"22.3 Linear Models","text":"","code":""},{"path":"regression.html","id":"non-linear-models","chapter":"22 Regressão","heading":"22.4 Non-Linear Models","text":"","code":""},{"path":"regression.html","id":"time-series-models","chapter":"22 Regressão","heading":"22.5 Time-Series Models","text":"","code":""},{"path":"regression.html","id":"complemento-20","chapter":"22 Regressão","heading":"Complemento","text":"","code":""},{"path":"regression.html","id":"recapitulando-20","chapter":"22 Regressão","heading":"Recapitulando","text":"","code":""},{"path":"regression.html","id":"dicionário-de-funções-23","chapter":"22 Regressão","heading":"Dicionário de Funções","text":"","code":""},{"path":"regression.html","id":"referências-20","chapter":"22 Regressão","heading":"Referências","text":"","code":""},{"path":"regression.html","id":"exercícios-17","chapter":"22 Regressão","heading":"Exercícios","text":"","code":""},{"path":"ml.html","id":"ml","chapter":"23 Aprendizado de Máquina","heading":"23 Aprendizado de Máquina","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"ml.html","id":"introdução-23","chapter":"23 Aprendizado de Máquina","heading":"23.1 Introdução","text":"Neste capítulo, apresentarei rapidamente alguns frameworks para modelos mais complexos de machine learning.","code":""},{"path":"ml.html","id":"fundamentals-1","chapter":"23 Aprendizado de Máquina","heading":"23.2 Fundamentals","text":"","code":""},{"path":"ml.html","id":"ml-in-built-in-r","chapter":"23 Aprendizado de Máquina","heading":"23.3 ML in Built-In R","text":"","code":""},{"path":"ml.html","id":"ml-in-external-packages","chapter":"23 Aprendizado de Máquina","heading":"23.4 ML in External Packages","text":"","code":""},{"path":"ml.html","id":"complemento-21","chapter":"23 Aprendizado de Máquina","heading":"Complemento","text":"","code":""},{"path":"ml.html","id":"recapitulando-21","chapter":"23 Aprendizado de Máquina","heading":"Recapitulando","text":"","code":""},{"path":"ml.html","id":"dicionário-de-funções-24","chapter":"23 Aprendizado de Máquina","heading":"Dicionário de Funções","text":"","code":""},{"path":"ml.html","id":"referências-21","chapter":"23 Aprendizado de Máquina","heading":"Referências","text":"","code":""},{"path":"ml.html","id":"exercícios-18","chapter":"23 Aprendizado de Máquina","heading":"Exercícios","text":"","code":""},{"path":"others4.html","id":"others4","chapter":"24 Outras Aplicações","heading":"24 Outras Aplicações","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"others4.html","id":"introdução-24","chapter":"24 Outras Aplicações","heading":"24.1 Introdução","text":"Neste capítulo, listarei outras aplicações de possível interesse, especialmente aquelas com relação aos conceitos deste livro.","code":""},{"path":"others4.html","id":"comunicação-com-rmarkdown-stargazer-broom-e-shiny.","chapter":"24 Outras Aplicações","heading":"24.2 Comunicação com RMarkdown, stargazer, broom, e Shiny.","text":"","code":""},{"path":"others4.html","id":"pacotes-1","chapter":"24 Outras Aplicações","heading":"24.3 Pacotes","text":"","code":""},{"path":"others4.html","id":"bioestatística-estatística-geoespacial-e-econometria.","chapter":"24 Outras Aplicações","heading":"24.4 Bioestatística, Estatística geoespacial, e Econometria.","text":"","code":""},{"path":"others4.html","id":"complemento-22","chapter":"24 Outras Aplicações","heading":"Complemento","text":"","code":""},{"path":"others4.html","id":"recapitulando-22","chapter":"24 Outras Aplicações","heading":"Recapitulando","text":"","code":""},{"path":"others4.html","id":"dicionário-de-funções-25","chapter":"24 Outras Aplicações","heading":"Dicionário de Funções","text":"","code":""},{"path":"others4.html","id":"referências-22","chapter":"24 Outras Aplicações","heading":"Referências","text":"","code":""},{"path":"others4.html","id":"exercícios-19","chapter":"24 Outras Aplicações","heading":"Exercícios","text":"","code":""},{"path":"recap4.html","id":"recap4","chapter":"Recapitulando","heading":"Recapitulando","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Aqui, apresentarei o recapitulando da quarta parte, falando dos fundamentos da modelagem e aplicações importantes.","code":""},{"path":"recap4.html","id":"dicionário-de-funções-26","chapter":"Recapitulando","heading":"Dicionário de Funções","text":"","code":""},{"path":"dict.html","id":"dict","chapter":"Dicionário de funções","heading":"Dicionário de funções","text":"Abaixo segue lista de funções vistas neste livro.","code":""},{"path":"refs.html","id":"refs","chapter":"Referências","heading":"Referências","text":"Abaixo seguem principais referências deste livro. Elas estão separadas entre que foram utilizadas para compor o conteúdo, e que foram citadas como sugestões de leitura.","code":""},{"path":"refs.html","id":"referências-23","chapter":"Referências","heading":"25.1 Referências","text":"","code":""},{"path":"refs.html","id":"sugestões-de-leitura","chapter":"Referências","heading":"25.2 Sugestões de Leitura","text":"","code":""}]
