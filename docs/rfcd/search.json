[{"path":"index.html","id":"bem-vindo","chapter":"Bem Vindo!","heading":"Bem Vindo!","text":"Este livro tem o objetivo de ensinar linguagem R. O material tem duas especificidades principais:É um livro para níveis diversos de experiência – é introdutório, mas expõe conceitos avançados e com profundidade.Tem uma abordagem mista – primeiro focando na teoria, fundamentos, e funcionamento da linguagem, mas depois apresentando temas aplicados.Abaixo explico motivação para esse estilo, bem como para quem ele pode ser útil.este livro está em construção. O material aqui presente ainda é um rascunho, o estilo livro pode vir sofrer mudanças drásticas. Adicionalmente, precisão dos conceitos não está 100% garantida.\nmomento, o início livro, até o capítulo 3, está relativamente em ordem.","code":""},{"path":"index.html","id":"por-que-este-livro","chapter":"Bem Vindo!","heading":"Por que Este Livro?","text":"Existem diferentes estilos de aprendizagem, alguns preferem “aprender fazendo”, outros preferem “aprender estudando”. Este livro é, em sua maior parte, signatário segundo. Porém, mesmo se esse não seu estilo preferido, argumento que ele combina com o estudo de R.R é uma linguagem única, para o bem e para o mal:Ela contém muitas exceções, particularidades, e heranças de outros tempos. Elas são causas comuns de erros e dificuldades de compreensão. Aprender regra, teoria, o contexto geral, facilita muito aprender lidar com exceções da maneira menos dolorosa possível.Ela contém ferramentas poderosas e incomuns. especialização em estatística motiva existência de construtos nada óbvios, mas muito úteis. Existe uma variedade de estilos (funcionais, orientado ao objeto, metalinguísticos) igualmente importantes, mas difíceis de alcançar sem um estudo mais teórico.Essas especificidades são exploradas na primeira metade livro, “Fundamentos”. ideia é que o leitor fique confiante de saber “como o R funciona”, e não apenas “saber escrever códigos”, mas sem investir tempo nas complexidades não-essenciais. Adicionalmente, introduzo o tidyverse, que dispõe ferramentas poderosas e acessíveis, graças à sua filosofia e sintaxe intuitiva.Mas claro que o conhecimento aplicado também é quisto (deixemos o estudo puramente teórico para os nerds da ciência da computação). Portanto, na segunda metade livro, “Ciência de Dados”, foco em aplicar o conhecimento recém adquirido para aprender algumas das tarefas mais comuns em projetos R: arrumação, manipulação, visualização, e modelagem de dados. Aqui, os conhecimentos da primeira metade permitem um aprendizado mais rápido e profundo.Antes de seguir adiante, uma palava motivacional: vezes uma pessoa passa mais tempo estudando um assunto que deveria, e quanto mais fundo vai, mais difícil é parar de estudar. Esse é o meu caso, mas gostaria de ter companhia nessa situação (ninguém é de ferro). Foi com isso em mente que montei esse material, para dar oportunidade leitor fazer o mesmo, “se afundar R”, da forma mais eficiente possível. Espero que goste!","code":""},{"path":"index.html","id":"organização-do-livro","chapter":"Bem Vindo!","heading":"Organização do Livro","text":"O livro é dividido em quatro partes: “- Fundamentos: R Base”, “II - Fundamentos: Tidyverse”, “III - Ciência de Dados: Processar e Visualizar”, e “IV - Ciência de Dados: Modelar”.bases desse material estão descritas na seção 1.3, já adianto o disclaimer: boa parte conteúdo deste livro é uma curadoria, adaptação, e tradução dos materiais abaixo.Parte - “R Language Definition”1, “R Internals”2 e “Advanced R” (2e)3.Parte II - Documentação tidyverse4 e ggplot25, “Data Manipulation R”6, e “R Programming Data Science”7.Partes III e IV - “R Data Science” (2e)8 e “R Cookbook” (2e)9.","code":""},{"path":"index.html","id":"introdução","chapter":"Bem Vindo!","heading":"Introdução","text":"Para começar, exponho alguns temas iniciais, como: história da linguagem, suas características gerais, porque aprender R; literatura sobre R, e referências deste livro.Também preparo o leitor para iniciar sua jornada, explicando o estilo e didática livro, bem como mostrando instalação e interface RStudio (de uma maneira bastante preguiçosa).","code":""},{"path":"index.html","id":"parte-i---fundamentos-r-base","chapter":"Bem Vindo!","heading":"Parte I - Fundamentos: R base","text":"Os conceitos basilares R costumam ser ensinados rapidamente, para dar prioridade na manipulação de dados e aplicações. Esse curso não fará isso, iremos passar com bastante calma por essa dimensão, tanto porque existem menos tutoriais que fazem isso, mas principalmente, porque aprender sobre como o R funciona com detalhe gera uma série de benefícios:Permite aprender fontes comuns de erros e como evitá-las.Facilitará o entendimento dos conceitos que empoderam o tidyverse e diversas aplicações possíveis.Permite escrever códigos mais elegantes e, principalmente, mais eficientes.Permite entender códigos mais complexos.Essa abordagem é algo como “ter aulas formais de uma língua”, em oposição “ensino para turismo”. utilidade desse enfoque depende de seu objetivo.","code":""},{"path":"index.html","id":"parte-ii---fundamentos-tidyverse","chapter":"Bem Vindo!","heading":"Parte II - Fundamentos: Tidyverse","text":"O tidyverse é um conjunto incrível de extensões ao R, com uma filosofia e sintaxe unificada e intuitiva. Ele apresenta ferramentas poderosas para maior parte das tarefas essenciais em projetos R.Nessa parte, explicarei seus fundamentos, relacionando com os conceitos da Parte , e darei rápidos tutoriais sobre ferramentas nele contidas. Todas serão imediatamente aplicadas na parte seguinte.","code":""},{"path":"index.html","id":"parte-iii---ciência-de-dados-processar","chapter":"Bem Vindo!","heading":"Parte III - Ciência de Dados: Processar","text":"Aqui começa segunda metade livro. Inicio respondendo “o que é ciência de dados?”, e em qual formato queremos esse tal de “dados”. partir daí, o objetivo é aprender obter, arrumar, manipular, e unir dados, de modo alcançar esse formato quisto.Além da formatação, aprenderemos manipular dados como uma ferramenta de exploração.Em termos simplistas, parte III é parte II aplicada (menos visualização).","code":""},{"path":"index.html","id":"parte-iv---ciência-de-dados-explorar","chapter":"Bem Vindo!","heading":"Parte IV - Ciência de Dados: Explorar","text":"última parte livro foca em como descrever dados com base em visualizações e modelos.Iremos aplicar ferramentas de visualização da parte II para criar gráficos que ajudem explorar e entender relações presentes nos dados.Irei explicar o que é um modelo, e apresentar algumas estratégias e frameworks disponíveis. Ao fim, listo referências para outras aplicações de possível interesse.","code":""},{"path":"index.html","id":"treinamento","chapter":"Bem Vindo!","heading":"Treinamento","text":"Contarei mais sobre mim na seção abaixo, mas antes, uma auto-divulgação (que nunca fez mal ninguém).Eu aplico aulas personalizadas de R para qualquer tipo de grupo/indivíduo. aulas podem incluir o conteúdo deste livro e/ou focar em temas aplicados específicos, bem como conter tópicos teóricos de áreas de meu conhecimento – estatística, economia, finanças, matemática, entre outros.Se tiver interesse, mande um email! Sou bastante aberto para conversar e criar projetos em conjunto.","code":""},{"path":"index.html","id":"sobre-o-autor","chapter":"Bem Vindo!","heading":"Sobre o Autor","text":"Meu nome é Ricardo Semião e Castro, sou mestrando em economia na FGV-EESP, e sou fã de R. Se tiver algum comentário sobre este material, por favor mande em meu email ricardo.semiao@outlook.com. Minhas redes são:Site pessoal.Github.Linkedin.StackOverflow.Twitter.","code":""},{"path":"index.html","id":"licença","chapter":"Bem Vindo!","heading":"Licença","text":"Esse material, como um todo, está licenciado pela Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.","code":""},{"path":"introduction.html","id":"introduction","chapter":"1 Introdução","heading":"1 Introdução","text":"","code":""},{"path":"introduction.html","id":"história","chapter":"1 Introdução","heading":"1.1 História","text":"R é “uma linguagem de programação e um ambiente para computação estatística e gráfica”10. Ambiente sentido que é um “sistema totalmente planejado e coerente”, não uma ferramenta específica e inflexível. É uma linguagem especializada, com ferramentas poderosas e acessíveis para projetos de campos como estatística e ciência de dados. Ao mesmo tempo, é facilmente incrementável, com centenas de extensões para mais diversas áreas.O R foi criado em 1993 por Ross Ihaka e Robert Gentleman da Universidade de Auckland, Nova Zelândia, com o apoio de John Chambers Bell Laboratories. Sucedeu linguagem S, e junto com inicial dos autores, o nome R foi cunhado. Não, infelizmente, não é R de “Ricardo”.Existem várias entidades associadas ao desenvolvimento da linguagem:O Comprehensive R Archive Network (CRAN) foi criado em 1997 por Kurt Hornik e Fritz Leisch para armazenar o código fonte, documentação, e pacotes R.O R Core Team foi formado em 1997 para desenvolver linguagem.linguagem como projeto e homepage oficial é o R Project. Também existe homepage das versões em desenvolvimento R.R Foundation foi fundada em 2003 para guiar o R Project.O RStudio, agora Posit foi fundado para expandir qualidade projeto, lançando um ambiente de desenvolvimento integrado em 2011, e oferecendo soluções para empresas.O R Journal e R Blog.","code":""},{"path":"introduction.html","id":"características-da-linguagem-e-porque-r","chapter":"1 Introdução","heading":"1.2 Características da Linguagem, e “Porque R?”","text":"O R é uma linguagem bem específica. Abaixo cito algumas de suas características, e porque elas podem motivar seu estudo.R está disponível como código aberto, com sua licença GNU General Public License. Adicionalmente, é acessível para maioria das máquinas/sistemas operacionais. Isso faz com que projetos R sejam acessíveis e facilmente replicados por outros.R está disponível como código aberto, com sua licença GNU General Public License. Adicionalmente, é acessível para maioria das máquinas/sistemas operacionais. Isso faz com que projetos R sejam acessíveis e facilmente replicados por outros.R é uma linguagem popular, ficou na posição 21 TIOBE Index em fev/2024. Especialmente, ele conta com uma comunidade muito ativa e amigável, na #rstats Twitter, StackOverflow, Posit Community, e pessoalmente.R é uma linguagem popular, ficou na posição 21 TIOBE Index em fev/2024. Especialmente, ele conta com uma comunidade muito ativa e amigável, na #rstats Twitter, StackOverflow, Posit Community, e pessoalmente.Um produto dessa popularidade é quantidade massiva de extensões, para toda sorte de tarefa.\nExistem múltiplas abordagens para manipulação de dados, modelagem, e criação de visualizações.\nPoderosas ferramentas para comunicação, o RMarkdown (que foi utilizado para construir esse livro), e o Shiny, utilizado para construir Apps.\nFerramentas na fronteira de pesquisa, uma vez que pesquisadores costumam criar pacotes R para acompanhar suas inovações.\nUm produto dessa popularidade é quantidade massiva de extensões, para toda sorte de tarefa.Existem múltiplas abordagens para manipulação de dados, modelagem, e criação de visualizações.Poderosas ferramentas para comunicação, o RMarkdown (que foi utilizado para construir esse livro), e o Shiny, utilizado para construir Apps.Ferramentas na fronteira de pesquisa, uma vez que pesquisadores costumam criar pacotes R para acompanhar suas inovações.Ocupa um espaço muito interessante na paisagem de softwares:\nÉ uma linguagem de programação verdadeira, permitindo soluções para problemas mais complexos, e dando mais flexibilidade ao usuário, quando comparado com outros softwares estatísticos não programáticos como o SAS, SPSS, Stata, Eviews, e GRETL.\nMas é especializado, interpretada, e high-level, facilitando seu uso, e apresentando uma cuva de aprendizado mais rápida que linguagens mais complexas/generalistas como C.\nespecialização em estatística faz com que ferramentas muito necessárias para análise de dados sejam de fácil acesso, como data frames e vetorização. O usuário não precisa aprender extensões para realizar projetos em ciência de dados.\nOcupa um espaço muito interessante na paisagem de softwares:É uma linguagem de programação verdadeira, permitindo soluções para problemas mais complexos, e dando mais flexibilidade ao usuário, quando comparado com outros softwares estatísticos não programáticos como o SAS, SPSS, Stata, Eviews, e GRETL.Mas é especializado, interpretada, e high-level, facilitando seu uso, e apresentando uma cuva de aprendizado mais rápida que linguagens mais complexas/generalistas como C.especialização em estatística faz com que ferramentas muito necessárias para análise de dados sejam de fácil acesso, como data frames e vetorização. O usuário não precisa aprender extensões para realizar projetos em ciência de dados.Algumas características mais técnicas:\nSua sintaxe é similar à C e Python, mas sua semântica é de uma linguagem funcional, mais similar à Lisp e APL. Veremos que o estilo funcional é muito útil para projetos de ciência de dados.\nDito isso, o R é uma linguagem com múltiplos paradigmas: tem capacidades incomuns de metaprogramação, permitindo códigos elegantes e sucintos; provê programação orientada ao objeto de forma limitada, mas de maneira útil e simples.\nO R usa código em C, C++, e Fortran para executar tarefas computacionalmente intensivas. Isso é algo que o usuário também pode explorar.\nAlgumas características mais técnicas:Sua sintaxe é similar à C e Python, mas sua semântica é de uma linguagem funcional, mais similar à Lisp e APL. Veremos que o estilo funcional é muito útil para projetos de ciência de dados.Dito isso, o R é uma linguagem com múltiplos paradigmas: tem capacidades incomuns de metaprogramação, permitindo códigos elegantes e sucintos; provê programação orientada ao objeto de forma limitada, mas de maneira útil e simples.O R usa código em C, C++, e Fortran para executar tarefas computacionalmente intensivas. Isso é algo que o usuário também pode explorar.Porém, nem tudo são flores. Muitas dessas características tem prós e contras, e execução dessas ideias conta com heranças obsoletas e inconsistências. Neste livro, deixarei claro os pontos negativos mais importantes, e ensino evitá-los.","code":""},{"path":"introduction.html","id":"biblio","chapter":"1 Introdução","heading":"1.3 Literatura sobre R","text":"literatura base pode ser encontrada CRAN. Ela é composta de, principalmente:O código fonte.O manual “R Language Definition”, que descreve linguagem em si.O manual “R Internals”, que descreve estruturas internas R, e fundação código em C.documentação de ajuda para o R base e extensões padrões.documentação de ajuda para extensões externas11.Nenhuma dessas é exatamente didática, mas existe uma vasta bibliografia de livros para R, tanto para ensinar linguagem geral, quanto para toda sorte de aplicações.Abaixo apresento bibliografia principal deste livro. Na seção de introdução de cada parte, descreverei melhor sugestões de leitura, e como elas complementam o material.Bibliografia base da parte : “R Language Definition”12, “R Internals”13 e “Advanced R” (2e)14.Outras documentações utilizadas: código fonte15 e documentação das extensões básicas16.Outros livros utilizados: “Working R”17, e “Forgot Teach R”18.Sugestões de leitura: “Hands Programming R”19, e “Introduction R”20.Bibliografia base da parte II: documentação tidyverse21, “ggplot2: Elegant Graphics Data Analysis” (3e)22.Outros livros utilizados: “Data Manipulation R”23, e “R Programming Data Science”24.Sugestões de leitura: “Modern R tidyverse”25, e “STAT 545”26.Bibliografia base das partes III e IV: “R Data Science”27, e “R Cookbook” (2e)28.Sugestões de leitura: “ModernDive R Tidyverse”29, “Everything need Exploratory Data Analysis & Visualization”30, “Introduction Data Exploration Analysis R”31, “Big Book R”Existem muitos outros livros e tutoriais dedicados aplicações específicas. Algumas listas (incompletas) podem ser encontradas arquivo CRAN.","code":""},{"path":"introduction.html","id":"estilo-do-livro","chapter":"1 Introdução","heading":"1.4 Estilo do Livro","text":"Antes de prosseguir, quero expor de antemão o estilo e organização dos capítulos.Este livro tem muito cobrir, e tem um andamento acelerado. Para facilitar ao máximo vida leitor, o estilo dos capítulos foi definido para ajudar direcionar atenção para o que é mais importante, e menos atenção para o extra. Abaixo apresento alguns dos construtos utilizados para tal.Pequenos excertos de código são apresentados na linha 1 + 1, e blocos de código como abaixo.Nos exemplos deste livro, um comentário formato #> ... indica o resultado esperado da declaração que o precede.Palavras em negrito normalmente indicam conceitos que serão definidos. Após sua apresentação, os conceitos costumam deixar de aparecer em negrito.Palavras em itálico costumam denotar um termo com significado específico contexto relevante.‘Nome’ resultado\nResultados importantes são expostos neste tipo de bloco. Note que nem todos os resultados serão simples de entender imediatamente, mas são expostos momento em que é relevante para o estudo da linguagem.vezes é importante apresentar um exemplo para esclarecer um conceito. Tendo colocar exemplos apenas quando necessário, de modo que é importante entendê-los. Em contrapartida, não há muitos exemplos “complementares”. É natural que essa baixa frequência torne difícil compreensão de alguns temas. Mas para isso existem os exercícios.nesse bloco explicito pontos que o leitor deve prestar atenção. Na maioria dos casos, apresento causas comuns de erros.observações deste tipo costumam ser sobre organização livro ou outros esclarecimentos menos importantes.nesse tipo de bloco apresento referências que tratam tema relevante com mais calma, ou trazem tópicos adicionais para o leitor que queira expandir seus conhecimentos.Itens desse tipo costumam trazer curiosidades menos importantes.Ao final de cada capítulo existe uma seção de “Complemento”. Nele, há:Uma recapitulação dos conceitos apresentados.Uma lista de funções apresentadas capítulo.Uma seção de referências, inclusive com links para conceitos deixados de lado capítulo, para o leitor que quiser ir além.Uma lista de exercícios, que normalmente também apresenta novos conceitos/funções.","code":"\nx <- 1 + 1\nx * 2 #> 4"},{"path":"introduction.html","id":"instalação-interface-e-ferramentas","chapter":"1 Introdução","heading":"1.5 Instalação, Interface, e Ferramentas","text":"Antes de começar o aprendizado, é preciso instalar linguagem (R), e se familiarizar com interface editor de código oficial (RStudio).Veja como instalar neste tutorial curso “R Para Jornalistas”. PS: coincidentemente, maneira que jornalistas instalam o R serve para qualquer outra profissão também.Existem vários tutoriais online explicando interface, como o da Datacamp (veja até “Write R Scripts RStudio”), e o video “RStudio Total Beginner”. Eu gosto bastante capítulo “Getting know RStudio” meu amigo Bruno Rodrigues32.Além disso, existem três configurações mais comuns de serem alteradas: alterar onde os arquivos são salvos por padrão; impedir que os dados da última sessão R sejam recarregados quando você voltar; e alterar aparência – afinal, você só se torna um programador após passar 3h escolhendo o tema perfeito. Elas podem ser encontradas em [barra de menu] > Tools > Global Options, nas abas General e Appearance.vide capítulo “3 - Using RStudio”33, e 3 - “Navigating Software”34, para mais informações sobre interface.Até o momento, eu fui preguiçoso e não trouxe esse material para o livro. Ainda assim, veja referências com calma, não deixe confusões com o software atrapalharem seu aprendizado.Última coisa, eu juro. O R provê alguns comandos para procurar por ajuda. função vignette() abre uma lista de artigos de ajuda das extensões R. Adicionalmente, se você quer saber informações sobre uma função chamada acaba_pelo_amor_de_deus, os códigos abaixo abrem suas documentações de ajuda.Agora sim, vamos começar. Boa sorte!","code":"\n?acaba_pelo_amor_de_deus\nhelp(\"acaba_pelo_amor_de_deus\")"},{"path":"intro1.html","id":"intro1","chapter":"Introdução","heading":"Introdução","text":"Bem vindo à primeira parte deste livro, onde estudaremos os conceitos na base R. Partirei zero absoluto, de modo que é possível que o leitor tenha algum nível de familiaridade com os temas, mas idealmente, não na profundidade aqui abordada.Nessa parte mais “teórica”, é difícil de traçar o limite nível de complexidade ideal. Por conta disso, muitos conceitos tiveram de ser introduzidos rapidamente. Mas não se assuste, muitas vezes, meu objetivo maior é passar uma intuição geral de como o R funciona, e dar um primeiro contato com os temas mais complexos. Tento ao máximo deixar claro onde gastar seu cérebro e onde nem tanto.Meu foco é mostrar lógica R, “sintaxe e semântica” da linguagem. “gramática” ou “vocabulário”, isto é, funções, truques, e aplicações específicas, serão ensinadas de passagem e via exercícios. Mas final, ideia é ter apresentado maioria das funções comumente relevantes, construindo uma lista de referência para futuras consultas.Os capítulos dessa seção estão organizados da seguinte maneira:Capítulo 2: aqui aprenderemos, principalmente, estrutura de um programa em R, e os tijolinhos que compõe. Outros temas mais concretos serão sintaxe básica, variáveis, e operadores básicos.Capítulo 3: veremos como organização de tipos de dados R é elegantemente simples, incluindo complexidade através da existência de metadados. principal conclusão será entender relação entre os diferentes tipos, uma vez que esse conhecimento torna mais fácil pensar como operações são aplicadas cada tipo de dado.Capítulo 4: nessa altura campeonato, capaz que você esteja cansado de ver apenas teoria, esse capítulo é o mais “gramatical” de todos. Aprenderemos o que é operação de selecionar e alterar partes de uma variável. Aqui, já fica claro o benefício de entender organização dos tipos de dados.Capítulo 5: aprenderemos controlar o fluxo de um programa, isto é, como fazer um programa tomar decisões e repetir operações. Aprenderemos também lidar com erros e avisos.Capítulo 6: em oposição ao capítulo 3, agora é hora de dar atenção aos sentimentos R. Estávamos utilizando-, mas não explicamos o que são funções. Esse é o capítulo mais desafiador, mas boa parte da dificuldade pode ser deixada de lado, com perdas reduzidas ao leitor.Capítulo 7: aqui, aprenderemos sobre os paradigmas/estilos de programação funcional, orientada ao objeto, e meta, especificamente sobre sua abordagem R. programação funcional é uma ferramenta com ligação direta nos projetos de ciência de dados; Entender o básico de POO R é importante para entender o uso de … funções35; Metaprogramação é um assunto útil em si mesmo, mas especialmente importante para entender bases tidyverse na parte II.Capítulo 8: por fim, temos algum outros tópicos úteis, mas não essenciais para o seguimento livro. Aqui, aprenderemos sobre algumas ferramentas de melhoria de vida que o RStudio provê, e alguns temas avançados sobre gerenciamento de memória, performance, e organização.Recapitulado: não só em cada capítulo, mas cada parte deste livro, existe uma seção para retomar os conteúdos, especialmente o que será mais útil para próxima parte.","code":""},{"path":"syntax-vars.html","id":"syntax-vars","chapter":"2 Sintaxe e Variáveis","heading":"2 Sintaxe e Variáveis","text":"","code":""},{"path":"syntax-vars.html","id":"introdução-1","chapter":"2 Sintaxe e Variáveis","heading":"2.1 Introdução","text":"Neste capítulo, vamos aprender, principalmente, estrutura de um programa em R, e os tijolinhos que compõe.Haverão dois aprendizados principais: () estrutura pode ser entendida como de um texto instrucional; (ii) temos apenas dois tijolos, objetos e funções. Esses tópicos principais são bastante teóricos/abstratos, mas serão úteis futuro, e seu entendimento gera habilidade de generalizar esses conceitos para outras linguagens de programação.Aprenderemos também tópicos mais concretos: () sintaxe básica da linguagem; (ii) como definir e como funcionam variáveis; (iii) funções (operadores) básicas da linguagem.","code":""},{"path":"syntax-vars.html","id":"sintaxe","chapter":"2 Sintaxe e Variáveis","heading":"2.2 Sintaxe","text":"Em termos simplistas, um script é um arquivo de texto com instruções serem executadas por um computador.Um script é um texto instrucional como qualquer outro, escrito em um tipo de linguagem especial, “de programação”, mas é um texto. Similar à receita de bolo de cenoura da minha vó, ou o roteiro da peça escolar onde interpretei, com maestria, árvore #3.Como em qualquer linguagem, temos um vocabulário à disposição, um conjunto de palavras (ou tokens) existentes, organizadas em categorias como substantivos, verbos, etc. Nós combinamos palavras em frases (ou statements) para descrever instruções. Por fim, podemos opcionalmente organizar o texto em parágrafos (ou blocks), conjuntos de frases que devem ser lidas juntas, para definir estrutura e facilitar o entendimento texto.Ok, receita da minha vó não tinha parágrafos, metáfora não é perfeita, paciência.seguir, vamos descrever com mais calma esses conceitos de tokens, statements e blocks.","code":""},{"path":"syntax-vars.html","id":"palavras","chapter":"2 Sintaxe e Variáveis","heading":"2.2.1 Palavras","text":"VocabulárioQuais tipos de palavras/tokens, temos disponíveis na linguagem R?Substantivos, os objetos: dados/valores, que podem carregar também metadados/atributos.\nCada dado/valor tem um tipo36.\nPodem ser associados à um nome. O conjunto nome-valor (e potencialmente atributos), é chamado de variável.\nCada dado/valor tem um tipo36.Podem ser associados à um nome. O conjunto nome-valor (e potencialmente atributos), é chamado de variável.Verbos, funções: definem operações à serem realizadas usando objetos.\nOperadores, símbolos como + e >, são um tipo de função especial, que apresentam uma sintaxe mais enxuta.\nOperadores, símbolos como + e >, são um tipo de função especial, que apresentam uma sintaxe mais enxuta.Note que descrevemos tudo que há na linguagem em apenas dois conceitos, objetos e funções. Em outras palavras:“[R,] everything exists object; everything happens function call.” — John Chambers.É essa simplicidade que, na minha opinião, torna aprender “teoria” sobre o R tão interessante:Veremos que ter esse tipo de conhecimento sobre linguagem facilitará muito o entendimento de temas futuros.Estaremos adquirindo habilidade de aprender o funcionamento de linguagens de programação geral, usando um exemplo (R) simples.Mas vamos sair da abstração. Como escrevemos essas palavras em um texto de R?Valores:\nStrings: utilize aspas duplas \" ou aspas simples': \"Hello World!\", 'Hello World!'37.\nNúmeros: simplesmente escreva-os: 1. Use um ponto . como o separador decimal 0.01.\nBooleanos: escreva palavras especiais TRUE e FALSE.\nStrings: utilize aspas duplas \" ou aspas simples': \"Hello World!\", 'Hello World!'37.Números: simplesmente escreva-os: 1. Use um ponto . como o separador decimal 0.01.Booleanos: escreva palavras especiais TRUE e FALSE.Variáveis: o operador <- associa o nome à esquerda ao valor à direita: <- 1. Não se preocupe muito com isso por agora.Funções: escreva o nome da função, e os argumentos que ela receberá entre parênteses sum(1, 1). Não se preocupe muito com elas por agora.\nOperadores: são imputados como 1 + 1.\nParênteses podem ser utilizados em operações múltiplas: (1+1)/2.\nOperadores: são imputados como 1 + 1.Parênteses podem ser utilizados em operações múltiplas: (1+1)/2.Comentários: texto que não será avaliado como código. Use o símbolo #, que torna tudo após dele, na mesma linha, um comentário.","code":""},{"path":"syntax-vars.html","id":"frases","chapter":"2 Sintaxe e Variáveis","heading":"2.2.2 Frases","text":"Como dito, frases R serão combinações de tokens. Qualquer combinação.cada linha código abaixo é uma frase:Algumas frases são apenas um valor (1), o nome de uma variável (), chamada de uma função (sum(1, 1){r}), ou combinação dessas coisas.E quanto um código como 1 +? Bom, esse código não é sintaticamente correto. Normalmente, chamamos de statement (declaração) apenas frases sintaticamente corretas, e eu irei passar usar essa nomenclatura em diante.","code":"\n1\n1 + 1\na <- 1\na #retorna o valor da variável \"a\"\nsum(1, 1)\nsum(1, 1) + a"},{"path":"syntax-vars.html","id":"parágrafos","chapter":"2 Sintaxe e Variáveis","heading":"2.2.3 Parágrafos","text":"Um mesmo texto pode ser organizado de várias maneiras diferentes, e isso é verdade para um script também. Como delimitamos declarações?Por padrão, uma declaração acaba na quebra de linha.\nSe declaração terminar inacabada (como exemplo 1 +), o R ignora quebra de linha, e tenta completar declaração com linha seguinte.\nUm ponto e vírgula pode ser usado para delimitar uma declarações explicitamente: 1 + 1; 2 + 2. Mas seu uso não é uma comum nem recomendável.\nSe declaração terminar inacabada (como exemplo 1 +), o R ignora quebra de linha, e tenta completar declaração com linha seguinte.Um ponto e vírgula pode ser usado para delimitar uma declarações explicitamente: 1 + 1; 2 + 2. Mas seu uso não é uma comum nem recomendável.Várias declarações podem ser agregadas em grupos ou blocks usando chaves {}.veja alguns exemplos de declarações:um grupo de declarações é uma declaração em si. chaves são uma função, que combina várias declarações em uma só.Nada disso deve fazer muito sentido em termos práticos ainda, tudo bem, apenas é preciso já ir se acostumando com estrutura geral de um programa.Antes de avançar, vou mentir um pouco e dar duas definições, mas que serão melhor detalhadas futuro.ExpressãoÉ uma declaração não avaliada, “congelada”, que o R não rodou.FunçãoÉ uma expressão, que depende de variáveis, possivelmente associada à um nome. Utilizar esse nome, indicando os valores das variáveis envolvidas (entre parênteses ()), avalia declaração, retornando seu resultado.Com essa definição em mente, na nossa analogia começo capítulo, funções são “parágrafos nomeáveis”.","code":"\na #é uma declaração\n1 #é uma declaração\n{1} #equivalente à declaração anterior\n\n1 + 1 #é uma declaração, uma operação \"+\" sobre dois \"1\"'s\n\n{\n  1 + 1\n  2 + 2\n} #é um grupo de declarações\n1 + 1; 2 + 2 #equivalente à declaração anterior\nliar <- {x + y} #meramente ilustrativo, a sintaxe real é mais complexa\nliar(x = 1, y = 2) #> 3\nliar(1, 2) #equivalente à declaração anterior"},{"path":"syntax-vars.html","id":"variáveis","chapter":"2 Sintaxe e Variáveis","heading":"2.3 Variáveis","text":"variáveis merecem mais da nossa atenção. Mas não é para elas se acharem demais, valores/atributos e funções terão seus próprios capítulos.","code":""},{"path":"syntax-vars.html","id":"definindo-variáveis","chapter":"2 Sintaxe e Variáveis","heading":"2.3.1 Definindo Variáveis","text":"Para definir variáveis, escrevemos seu nome, = ou <-, e declaração que definirá seu valor: x = 1 + 1, x <- 1 + 1. Também podemos usar função assign(): assign(\"x\", 1).Ao rodar algo como x <- 1, o valor 1 é salvo na memória computador, e associado ao nome x. Como dito anteriormente, variável é o conjunto valor-nome.","code":""},{"path":"syntax-vars.html","id":"copy-on-modify","chapter":"2 Sintaxe e Variáveis","heading":"2.3.2 Copy on Modify","text":"Com base que aprendeu, o que acontece ao rodar y <- x? resposta não é nada óbvia:y pode ser um novo nome, associado ao mesmo objeto – mesma posição na memória computador – que x.y pode ser um novo nome, associado um novo objeto – nova posição na memória computador – que x, mas carregando mesma informação.Em ambos os casos acima o que acontece com x quando modificamos y, e vice versa?note que, mesmo se o objeto seguir sendo o mesmo (caso 1.), temos dois pares diferentes de nome-objeto, portanto, duas variáveis diferentes.R, o que acontece é o caso 1. Além disso, se y alterado, x não é (e vice versa). O que ocorre é que uma nova posição na memória é criada para armazenar informação novo y (ao ao menos parte dela). Esse processo, de apenas “separar”/“copiar” objetos quando modificados, é chamado de copy--modify.Diferentes tipos de valores terão diferentes relações com esse processo, mas vou poupá-los disso. O importante é saber que, na maioria dos casos, alterar y não altera x e vice versa, independente da complexidade objeto.veja, por exemplo, como é esse comportamento quando tratamos de listas, em,38 seção 2.3.3.Em outras palavras:Copy--modifyNo R, um mesmo objeto pode ter ser referenciado mais de um nome, gerando várias variáveis. Modificar alguma delas não modifica o objeto original, e sim copia-o, criando um novo objeto. Isso é, os objetos são copiados-após-mudanças.Existem duas exceções: objetos com apenas uma referência/um nome, e ambientes39. Esses são alterados “na hora”/“lugar”, ou modify--place.este tema é complexo, e foi bastante simplificado. Vide,40 seções “2.3 - Copy--modify” e “2.5 - Modify--place”. Os exemplos utilizando função tracemem() são especialmente úteis.","code":""},{"path":"syntax-vars.html","id":"outras-características","chapter":"2 Sintaxe e Variáveis","heading":"2.3.3 Outras Características","text":"Note que = e <- são muito similares, mas = serve para mais coisas que somente definição de variáveis, como indicar argumentos em uma função. Portanto, <- funciona como “definidor” em mais contextos, e é uma má prática utilizar = como definidor.Ambos podem definir várias variáveis de uma vez: x = y = 3, x <- y <- 3, x = y <- 3.Podemos usar também -> da esquerda pra direita: 3 -> x.Existe um terceiro operador <<-, que será discutido capítulo 6.","code":""},{"path":"syntax-vars.html","id":"regras-de-nomenclatura","chapter":"2 Sintaxe e Variáveis","heading":"2.3.4 Regras de Nomenclatura","text":"Nem toda combinação de caracteres pode ser um nome de variável. principais regras são:Nomes podem conter letras, números, “.” e “_“.São case-sensitive.Podem começar apenas com letras ou “.”.Não podem ser palavras reservadas como “TRUE”.Nomes não sintáticos podem ser definidos, se escritos usando crases (backticks): `_x` <- 1. Você provavelmente encontrará isso ao importar dados que não foram criados R.em muitos momentos, o R converte nomes não sintáticos utilizando função make.names(). Você aprenderá sobre ela nos exercícios. É muito importante estar atento à esse comportamento, uma vez que é causa comum de erros.\nVocê verá que isso é um tema comum: o R tenta facilitar muitas tarefas, fazendo coisas por você. Isso por um lado é o que o torna fácil de sair trabalhando, mas é causa de inconsistências.","code":""},{"path":"syntax-vars.html","id":"operadores","chapter":"2 Sintaxe e Variáveis","heading":"2.4 Operadores","text":"princípio, deixaria os detalhes sobre operadores para os exercícios, mas fiquei com medo deles se sentirem excluídos.Abaixo estão os operadores relevantes para o momento, suas descrições, e seu uso. Clique nos links dos operadores para abrir suas páginas de ajuda.Tabela 2.1: Principais operadores R.na coluna de “Uso”, “logi” se refere qualquer valor que se comporte como um valor booleano, “num” qualquer valor que se comporte como número, “expr” à qualquer statement, e “x”/“y” à valores mais genéricos, ou à nomes de variáveis.Agora vou apresentar ordem de precedência da aplicação dos operadores. Associatividade se refere à como são resolvidos “empates”, “direita pra esquerda” significa que o operador mais à direita é analisado antes. Tudo ficará mais claro exemplo que segue.Tabela 2.2: Precedência dos operadores R.linhas com um “(*)” apresentam operadores que ainda não foram apresentados.para deixar mais claro, na declaração (3+6)/(1+2)/5^4 o seguinte ocorre:() são analisados primeiro, porque tem precedência (estão acima na tabela).\nComo é da direita pra esquerda, primeiro (1+2) vira 3, e depois, (3+6) vira 9.\nComo é da direita pra esquerda, primeiro (1+2) vira 3, e depois, (3+6) vira 9.^ é analisado seguir, logo, 5^4 vira 625./ é analisado seguir.\nComo é da esquerda pra direita, primeiro 9/3 vira 3, e depois 3/625 vira 0.0048.\nComo é da esquerda pra direita, primeiro 9/3 vira 3, e depois 3/625 vira 0.0048.Vide,41 capítulo “6 - Basic Operations” para mais detalhes e exemplos. Cuidado, alguns conceitos utilizados lá não foram vistos ainda.","code":""},{"path":"syntax-vars.html","id":"complemento","chapter":"2 Sintaxe e Variáveis","heading":"Complemento","text":"","code":""},{"path":"syntax-vars.html","id":"recapitulando","chapter":"2 Sintaxe e Variáveis","heading":"Recapitulando","text":"","code":""},{"path":"syntax-vars.html","id":"sintaxe-1","chapter":"2 Sintaxe e Variáveis","heading":"Sintaxe","text":"Neste capítulo, vimos estrutura geral de um script:Temos palavras/tokens, frases/statements/declarações, e parágrafos/blocks.R, tudo que existe é um objeto, e tudo que acontece é uma chamada de função.\nObjetos serão o tema próximo capítulo, e funções, capítulo @(funs-envs).\nVimos como imputar cada tipo de token.\nObjetos serão o tema próximo capítulo, e funções, capítulo @(funs-envs).Vimos como imputar cada tipo de token.declarações são combinações de tokens.\nCostumam ser delimitadas por quebras de linha.\nCostumam ser delimitadas por quebras de linha.Declarações podem ser organizadas em parágrafos vias chaves.Scripts são sequências de declarações.Vimos definições inciais para dois conceitos importantes:Uma expressão é uma declaração ainda não avaliada.Uma função é uma expressão, que depende de variáveis, associada à um nome.\nFunções podem ser entendidas como “parágrafos nomeáveis”.\nFunções podem ser entendidas como “parágrafos nomeáveis”.","code":""},{"path":"syntax-vars.html","id":"variáveis-1","chapter":"2 Sintaxe e Variáveis","heading":"Variáveis","text":"Também demos uma atenção extra ao conceito de variável:Variáveis são um objeto com um nome associado.Aprendemos os operadores que definem variáveis = e <-, e porque <- é preferível.Vimos características como x <- y <- 3 e regras de nomenclatura.Bem como alguns conceitos mais técnicos e avançados:dinâmica da memória R é pautada pelo conceito de copy--modify. R, um mesmo objeto pode ter ser referenciado mais de um nome. Modificar algum deles não modifica o objeto original, e sim copia-o, criando um novo objeto. Isso é, os objetos são copiados-após-mudanças.\nexceções são objetos com apenas uma referência, e ambientes, que usam modify--place (são modificados “lugar”).\nexceções são objetos com apenas uma referência, e ambientes, que usam modify--place (são modificados “lugar”).","code":""},{"path":"syntax-vars.html","id":"operadores-1","chapter":"2 Sintaxe e Variáveis","heading":"Operadores","text":"Por fim, apresentamos os operadores básicos, seu uso, e ordem de preferência. Foi dito que operadores são funções, apenas com sintaxe diferente.","code":""},{"path":"syntax-vars.html","id":"dicionário-de-funções","chapter":"2 Sintaxe e Variáveis","heading":"Dicionário de Funções","text":"Abaixo segue lista de funções vistas neste capítulo.","code":""},{"path":"syntax-vars.html","id":"referências","chapter":"2 Sintaxe e Variáveis","heading":"Referências","text":"referências principais deste capítulo são:“Advanced R” capítulo “2 - Names Values”, excluindo seções 2.4 e 2.6.“R Language” seções “2.1.3 - Language Objects” e “2.1.3 - Expression Objects”.“R Introduction” seções “2.1 - Vectors Assignment” e “2.2 - Vector Arithmetic”.“R Internals” seção “1.1 - SEXPs”.“R Help” os documentos de ajuda das funções aqui expostas.para outros temas não contidos aqui, mas fortemente relacionados com esse capítulo, vide42 seções “2.4 - Object Size” e “2.6 - Unbinding Garbage Collector”.","code":""},{"path":"syntax-vars.html","id":"exercícios","chapter":"2 Sintaxe e Variáveis","heading":"Exercícios","text":"os exercícios usam variáveis de mesmo nome. Garanta que você está utilizando definições corretas.","code":""},{"path":"syntax-vars.html","id":"variáveis-2","chapter":"2 Sintaxe e Variáveis","heading":"Variáveis","text":"Explique diferença entre 1 e cada uma das variáveis abaixo.Foi comentado que objetos mais complexos têm comportamentos diferentes com relação ao processo de definição , mas todos seguem uma característica geral. Com base nisso, o que você espera que ocorra com b após terceira linha código abaixo?você verá função list() próximo capítulo, mas saiba que ela cria uma lista, uma coleção, dos elementos que são passados como argumentos.Leia página de ajuda da função make.names() para aprender regras completas de definição de nomes, sobre como o R converte nomes não sintáticos. Preveja qual será o resultado das chamadas abaixo.","code":"\n1\na <- 1\nb <- a\nc <- a + 1\nd <- b\ne <- 1\na <- 1\nb <- list(a, a)\na <- a + 1\nmake.names(\"\")\nmake.names(\"@\")\nmake.names(\"TRUE\")\nmake.names(\"`TRUE`\")"},{"path":"syntax-vars.html","id":"operadores-2","chapter":"2 Sintaxe e Variáveis","heading":"Operadores","text":"Parta de um número qualquer x, por exemplo, x <- 5. Use os ensinados operadores para criar:Uma frase que retorne TRUE se x múltiplo de 2.Uma frase que retorne TRUE se x não múltiplo nem de 3, nem de 5.Uma frase que retorne TRUE se parte inteira da divisão de x por 4 é igual 2, ou se seu quadrado maior ou igual à 10.Liste ordem das ações executadas cálculo da expressão abaixo:","code":"\nx <- FALSE | !5.2 %% 2 * 7 * 4 - -3 <= 100 & TRUE"},{"path":"data-attrs.html","id":"data-attrs","chapter":"3 Tipos de Valores e Atributos","heading":"3 Tipos de Valores e Atributos","text":"","code":""},{"path":"data-attrs.html","id":"introdução-2","chapter":"3 Tipos de Valores e Atributos","heading":"3.1 Introdução","text":"Como vimos capítulo passado, tudo que existe R é um objeto. Eles são compostos de valores/dados e (potencialmente) atributos/metadados.Haverão dois aprendizados principais: () temos duas famílias de tipos, todos os valores “dia--dia” são vetores, e outra contém os poucos tipos internos R; (ii) diferença entre vetores atômicos e genéricos; (iii) atributos são metadados, que alteram interação dos objetos com funções, mas não suas características básicas. Especialmente o último ponto é muito útil para não precisar decorar funções para cada classe.Aprenderemos também tópicos mais concretos: () quais são os tipos de vetores atômicos; (ii) valores NA; (iii) coerção de tipos; (iv) como criar e combinar vetores; (v) o básico dos atributos nome e dimensão, bem como das classes mais comuns R.","code":""},{"path":"data-attrs.html","id":"famílias-de-valores","chapter":"3 Tipos de Valores e Atributos","heading":"3.2 Famílias de Valores","text":"Na descrição dos tipos de valores, o R também apresenta uma simplicidade muito interessante! Existem duas famílias de tipos de valores: os vetores, e os nodes.Os nodes são os tipos internos R. Os principais estão abaixo, e não existem muitos outros:Funções (closures), ambientes, promessas – serem estudadas capítulo 6.Expressões, símbolos, e chamadas de funções – serem estudadas capítulo 7.NULL, o objeto que denota ausência de valor – ser explicado neste capítulo.Os vetores são os tipos de valores que estamos mais acostumados lidar. Eles são divididos em dois: temos seis tipos de vetores atômicos, e um tipo de vetores genéricos (mais conhecidos como listas). Cada um será explicado em sua própria seção.","code":""},{"path":"data-attrs.html","id":"vetores-atômicos","chapter":"3 Tipos de Valores e Atributos","heading":"3.3 Vetores Atômicos","text":"","code":""},{"path":"data-attrs.html","id":"tipos-de-vetores-atômicos","chapter":"3 Tipos de Valores e Atributos","heading":"3.3.1 Tipos de Vetores Atômicos","text":"Os vetores atômicos são unidade básica de dados R. Eles podem ser de seis tipos, mas quatro são os principais:Logical são os dados booleanos, podem ser TRUE ou FALSE. Podem ser abreviados para T e F 43.Characters são os dados de texto (strings).Integers são números inteiros, e são escritos com um “L” fim: 12L.Doubles são os números decimais, podem ser escritos na forma decimal 1.245, científica 1.23e4, ou hexadecimal 0xadfe.\nValores especiais: Inf, -Inf, e NaN (“number”, usado em indefinições matemáticas).\nValores especiais: Inf, -Inf, e NaN (“number”, usado em indefinições matemáticas).Adicionalmente, existe raw, para dados em binário; e complex, para números complexos. Por fim, existe NULL que, como dito, não é um vetor, mas pode ser entendido como “ausência de dado”/“vetor de tamanho zero”.","code":""},{"path":"data-attrs.html","id":"definição-vetores-atômicos-e-escalares","chapter":"3 Tipos de Valores e Atributos","heading":"3.3.2 Definição: Vetores Atômicos e Escalares","text":"Podemos criar coleções como (1, 2, 3, 4, 5)44 de várias formas, mas note o resultado abaixo.Vetores Atômicos e EscalaresUm valor “sozinho”, ex: 3, é chamado de escalar.Um vetor atômico é uma coleção de escalares de um mesmo tipo.Um escalar é uma “coleção de tamanho um”, e portanto, todo escalar é um vetor atômico, não existe diferenciação real entre os dois.os componentes de uma coleção são chamados de “elementos”.","code":""},{"path":"data-attrs.html","id":"combinando-vetores","chapter":"3 Tipos de Valores e Atributos","heading":"3.3.3 Combinando Vetores","text":"função c() combina (daí o nome) vetores em um mais longo. Ela serve com atômicos ou genéricos, mas por enquanto, vamos usá-la com atômicos: c(TRUE, FALSE), c(1, 3.5, 1.23e4).Quando usada com vetores atômicos, c() coage os inputs escalares mesmo tipo, resultando em um outro atomic vector.\nExiste uma ordem de prioridade: se houver um character, tudo vira character, fora isso, tudo vira double, depois, integer, e por fim, logical. Veja o exemplo abaixo.\nFunções que pedem argumentos de um mesmo tipo normalmente os coagem caso eles sejam diferentes, e isso é causa comum de erros.Note duas coerções diferentes abaixo:","code":"\nc(1, 2, \"a\", \"b\") #> c(\"1\" \"2\" \"a\" \"b\")\nc(c(1, 2), c(3, 4)) #> c(1, 2, 3, 4)"},{"path":"data-attrs.html","id":"funções-úteis","chapter":"3 Tipos de Valores e Atributos","heading":"3.3.4 Funções Úteis","text":"palavra “tipo” (de um vetor) não é só sentido intuitivo, é esse o termo utilizado na documentação R. Podemos utilizar função typeof() para descobrir o tipo de um objeto.Para testar se um objeto é de um tipo específico, existem funções .logical(), .integer(), .double(), e .character(). Existem também .vector(), .atomic(), e .numeric(), mas são imprevisíveis.Na seção de atributos, vamos ver como podemos criar classes em cima dos tipos básicos. Essa complexidade torna os testes de tipo menos confiáveis em alguns contextos, por isso, recomendo usar variações rlang::is_logical() e cia. pacote rlang45, que tem uma relação mais confiável de 1-pra-1 com typeof().Podemos transformar o tipo de um vetor com .logical(), .integer(), .double(), ou .character().função length() retorna o tamanho, o número de elementos, de um vetor. Ela tem algumas peculiaridades, mas por enquanto, vamos deixar isso de lado.","code":""},{"path":"data-attrs.html","id":"valores-na","chapter":"3 Tipos de Valores e Atributos","heading":"3.3.5 Valores NA","text":"Todos os tipos explicados assumem um valor especial, o “valor desconhecido”: NA, “non aplicable”.Operações que dependam de um valor desconhecido, intuitivamente, também retonram um valor que não se conhece: 1 + NA #> NA; NA == NA #> NA. Para checar se um valor é NA, use .na().Por trás dos panos, existe um NA diferente para cada tipo de vetor atômico (NA_integer_, etc.). Isso acontece por conta das leis de coerção. Um valor desconhecido numérico pode ser coagido para um valor desconhecido de texto.","code":""},{"path":"data-attrs.html","id":"listas","chapter":"3 Tipos de Valores e Atributos","heading":"3.4 Listas","text":"","code":""},{"path":"data-attrs.html","id":"definição-listas","chapter":"3 Tipos de Valores e Atributos","heading":"3.4.1 Definição: Listas","text":"Vimos que vetores atômicos não aceitam elementos de tipos diferentes, nem elementos não-escalares, de length maior que 1. Porém, o R permite coleções diferentes, como (1, \"\", (1, 2, 3), TRUE, 1)46.ListasUma lista é uma coleção de vetores.\nNote definição mais flexível que de vetor atômico, por isso, listas também são chamadas de vetores genéricos.\nNote definição mais flexível que de vetor atômico, por isso, listas também são chamadas de vetores genéricos.Uma lista também faz parte da família vetor, portanto listas podem conter outras listasListas tem seu próprio tipo, list.Para criar uma lista, usamos função list().Note que lista list(1) não é um escalar, mas sim uma lista que contém um escalar. Esta é uma diferença importante, e será relevante capítulo 4.tema de “Gerenciamento de memória” falaremos sobre como, por trás dos panos, listas são apenas referências aos objetos, de modo que list(x, x) ocupa bem menos que o dobro espaço de list(x)","code":""},{"path":"data-attrs.html","id":"combinando-listas","chapter":"3 Tipos de Valores e Atributos","heading":"3.4.2 Combinando Listas","text":"Como listas podem conter outros vetores de tamanhos variados, inclusive outras listas, podem ter formatos súper complexos.Adicionalmente, há diferentes maneiras de combiná-las. função list() cria uma lista envolta dos inputs, enquanto função c() (quando usada com alguma lista), concatena listas. Vejamos alguns exemplos.Veja o código e representação visual de cada vetor ao lado.Outra manipulação de listas comum é “diminuição de complexidade/hierarquia”, como por exemplo:Transformar list(1, list(2, 3)) em list(1, 2, 3).Transformar list(1, 2, 3) em c(1, 2, 3).Ou, os dois ao mesmo tempo: list(1, list(2, 3)) em c(1, 2, 3).Para isso, podemos usar função unlist(), que por padrão, remove todas camadas de hierarquia de uma lista (caso 3). Para o caso 1, podemos usar o argumento recursive = FALSE47. funções purrr::list_flatten() e purrr::list_c() são opções mais consistentes, com menos resultados inesperados. primeira funciona para o caso 1, e segunda, para o caso 2.função c() pode ser utilizada para, ao mesmo tempo que combina, simplificar complexidade de listas, via o argumento recursive = FALSE. Esse comportamento pode ser útil, mas é confuso e inesperado, prefira ser explícito com primeiro combinar, e depois simplificar.","code":"\nv1 <- c(1, 2, 3)\n\nv2 <- list(1, 2, 3)\n\nv3 <- list(1, c(2, 3))\n\nv4 <- list(1, list(2, 3))\n\nv5 <- list(1, list(c(2, 3)))\n\nv6 <- c(list(1, 2), 3)"},{"path":"data-attrs.html","id":"atributos","chapter":"3 Tipos de Valores e Atributos","heading":"3.5 Atributos","text":"Os vetores podem carregar mais informações que apenas os valores de seus elementos, eles podem carregar metadados/atributos, dados sobre o vetor e seus elementos em si.Praticamente todos os objetos R podem carregar atributos, mas é raro isso ser útil. Vamos focar em vetores.Pode-se criar atributos livremente, mas alguns são mais comunmente encontrados na natureza:names, um vetor character, que nomeia cada elemento de um vetor.dim (diminutivo de dimensions), um vetor de inteiros, que reorganiza vetores em matrizes e arrays (em termos simplistas, “matrizes multidimensionais”).class, um vetor character, que indica classe de um vetor, um outro sistema de “tipagem” de objetos, construído em cima dos tipos.Atributos não afetam “essência” de um vetor, seu dado ou seu tipo, mas podem afetar como ele interage com funções. Abaixo, vamos estudar cada um dos atributos acima.","code":""},{"path":"data-attrs.html","id":"nomes","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.1 Nomes","text":"Nomear um vetor o torna mais compreensível. Adicionalmente, fica mais fácil de fazer referências à seus elementos, veremos isso capítulo 4.Podemos nomear um vetor de várias formas:x <- c(= 1, b = 2, c = 3)48.names(x) <- c(\"\", \"b\", \"c\").x <- setNames(x, c(\"\", \"b\", \"c\")). Considere também função purrr::set_names().Podemos remover nomes com:names(x) <- NULL49.x <- setNames(x, NULL).x <- unname(x).É fácil ver como estrutura básica fica inalterada. Tente transpor essa ideia para os outros atributos mais complexos seguir.","code":""},{"path":"data-attrs.html","id":"dimensões","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.2 Dimensões","text":"Muitas vezes, nossos dados tem uma lógica de organização como de uma matriz, com linhas e colunas. Algumas vezes, precisamos até de matrizes multi-dimensionais.","code":""},{"path":"data-attrs.html","id":"criação-de-matrizes-e-arrays","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.2.1 Criação de Matrizes e Arrays","text":"Um vetor com o atributo dimensão é um vetor que deve ser interpretado como matriz:Ou como array:Ambos podem ser criados diretamente, com funções matrix() – matrix(m1, nrow = 2, ncol = 3) – e array() – array(a1, c(2, 3, 2)).Note que utilizei vetores atômicos nos exemplos, mas listas também podem ter dimensões. Iremos explorar isso nos exercíciosNote que podemos ter matrizes com apenas uma linha ou uma coluna, ou arrays com apenas uma dimensão50. Eles são diferentes de vetores, e vão interagir diferentemente com funções (ex: matemática de matrizes). função str() retorna uma descrição mais detalhada de um objeto, abuse-.","code":"\nm1 <- c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE)\ndim(m1) <- c(2, 3)\nm1\n\n#>       [,1] [,2]  [,3]\n#> [1,]  TRUE TRUE FALSE\n#> [2,] FALSE TRUE  TRUE\na1 <- c(1:8)\ndim(a1) <- c(2, 2, 2)\na1\n\n#> , , 1\n#>\n#>      [,1] [,2]\n#> [1,]    1    3\n#> [2,]    2    4\n#>\n#> , , 2\n#>\n#>      [,1] [,2]\n#> [1,]    5    7\n#> [2,]    6    8"},{"path":"data-attrs.html","id":"funções-úteis-1","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.2.2 Funções Úteis","text":"Como atributos não alteram estrutura básica, funções para vetores tem generalizações para matrizes e arrays:Tabela 3.1:  Funções para Vetores, Matrizes e Arrays.Note que adicionar dimensões gerou algumas possibilidades:Um tamanho e um atributo de nome para cada dimensão.Maneiras diferentes de combinar vetores: por linhas, por colunas, ou por outras dimensões.Operação de transposição: com t() e aperm().Mais diferenças surgirão capítulo 4, onde veremos como acessar elementos de vetores com e sem dimensões.Entender que matrizes e arrays são, em sua base, vetores atômicos, será muito útil para prever como funções vão agir sobre eles.","code":""},{"path":"data-attrs.html","id":"classes","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.3 Classes","text":"Outro atributo importante é class, que permite criação de vetores diferenciados, criados em cima dos tipos básicos. Esse atributo empodera o sistema de programação orientada ao objeto S3. Nele, funções agem diferentemente depender da classe argumento que estão recebendo.Classes podem ser criadas livremente. Abaixo vão algumas muito presentes R:factor são utilizados para dados que podem assumir categorias pré definidas. São construídos em cima de integers.Date, POSIXct, e difftime são para datas. São construídos em cima de doubles.data.frame e tibble são para tabelas de dados. São construídos em cima de lists.Novamente, entender que classes são construídas em cima dos tipos será muito útil para prever como funções vão agir sobre eles.","code":""},{"path":"data-attrs.html","id":"factors","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.3.1 Factors","text":"Factors tem o atributo class como \"factor\", e um atributo levels que define os valores/categorias possíveis.Cuidado, factors comumente geram erros: parecem strings, mas não são. Aplicar manipulações de texto à eles costuma dar errado. Deve-se manipular seus níveis, ou transformar o factor em texto antes. Adicionalmente, vide também stringsAsFactors = sigh.Também existem os ordered factors, onde indicamos uma ordem para os levels, e costumam ser usados em funções de modelagem e visualização. Vide ordered().","code":"\nfactor(c(\"m\", \"f\", \"f\", \"m\"), levels = c(\"m\", \"f\", \"o\"))\n#> [1] m f f m\n#> Levels: m f o"},{"path":"data-attrs.html","id":"datas","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.3.2 Datas","text":"Dates: são um double com o atributo class \"Date\". Por trás dos panos são o número de dias entre 01/01/1970 e data em questão. Para criar, use função .Date().Date-times: são um double com o atributo class \"POSIXct\"51. Por trás dos panos são o número de segundos entre 01/01/1970 e hora em questão. Para criar, use função .POSIXct().Durations: são um double com o atributo class \"difftime\", que conta distância entre duas datas. Têm o atributo \"units\" que indica como o valor deve ser interpretado. Para criar, use função .difftime().Esses tipos de vetores são bem complexos, existem muitas complexidades como fusos horários, conversão de formatos, e operações matemáticas. Vou deixar para explicar como manipular esse tipo de dado capítulo 14.","code":""},{"path":"data-attrs.html","id":"data-frames","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.3.3 Data Frames","text":"Um dataframe é uma representação de uma tabela de dados. Basicamente, uma é uma lista nomeada de vetores, normalmente atômicos, todos de mesmo tamanho. Isto é, similar :Como sempre, ter isso em mente ajudará muito transpor o conhecimento sobre listas para dataframes.Data frames são criados com função data.frame(). Eles tem os atributos names (nomes das “colunas”), row.names (nomes das “linhas”), e class \"data.frame\".Um data frame tem nrow() linhas, e ncol()/length() colunas. Também existem funções .data.frame() e .data.frame().Uma coluna de um data frame pode também ser uma matriz/array (se o número de linhas coincidir), ou uma lista (se o número de elementos coincidir)52. O uso disso é raro.","code":"\nlist(\n  coluna1 = c(1, 2, 3),\n  coluna2 = c(\"c\", \"b\", \"d\"),\n  coluna3 = c(TRUE, FALSE, NA)\n)"},{"path":"data-attrs.html","id":"tibbles","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.3.4 Tibbles","text":"Um Tibble é um sucessor dataframe, trazido pelo pacote tibble.Tibbles tem classe c(\"data.frame\", \"tbl_df\"). São “preguiçosos e grosseiros: fazem menos e reclamam mais”:Não geram vetores maiores partir de vetores menores (data.frame(x = 1:4, y = 1:2)).Não mudam nomes não sintáticos.Não aceitam rownames, vindo da filosofia que “metadata data”.Um subset de um tibble sempre é um tibble. Mais sobre isso capítulo 4.Não tem matching parcial nos nomes de colunas53.Permitem referenciar colunas na hora da criação – tibble(x = 1:4, y = 2*x).Tem uma melhor visualização console.","code":""},{"path":"data-attrs.html","id":"matrices-and-arrays","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.3.5 Matrices and Arrays","text":"Lembre-se, são classes que fazem os objetos interagirem diferentemente com funções. Apenas ter um atributo de dimensão não faria com que, por exemplo, matrizes fossem representadas diferentemente por print(). Com isso em mente, faz sentido que matrizes e arrays tenham suas próprias classes, \"matrix\" e \"array\".","code":""},{"path":"data-attrs.html","id":"funções-úteis-2","chapter":"3 Tipos de Valores e Atributos","heading":"3.5.4 Funções Úteis","text":"Algumas funções relacionadas à atributos:atributes() retorna uma lista com os atributos de x.attr(x, \"attr\") retorna o valor atributo \"attr\". Pode ser utilizada para alterar atributos também.\nAtributos importantes têm funções próprias (names(), dim(), class()).\nunclass() remove classe de x, retornando-o ao tipo base.\nAtributos importantes têm funções próprias (names(), dim(), class()).unclass() remove classe de x, retornando-o ao tipo base.structure(x, \"attr\" = \"algo\") adiciona o atributo \"attr\" em xstr() retorna uma visualização da estrutura de x.","code":""},{"path":"data-attrs.html","id":"complemento-1","chapter":"3 Tipos de Valores e Atributos","heading":"Complemento","text":"","code":""},{"path":"data-attrs.html","id":"recapitulando-1","chapter":"3 Tipos de Valores e Atributos","heading":"Recapitulando","text":"","code":""},{"path":"data-attrs.html","id":"tipos-de-valores","chapter":"3 Tipos de Valores e Atributos","heading":"Tipos de Valores","text":"Existem duas famílias de tipos, os vetores e os nodes. Veja figura 3.1.\nTodos os valores “dia--dia” são vetores. Nodes são os tipos internos R, e serão estudados futuro.\nTodos os valores “dia--dia” são vetores. Nodes são os tipos internos R, e serão estudados futuro.Vetores atômicos são coleções de escalares de um mesmo tipo. Listas (vetores genéricos) são coleções de vetores.Existem seis tipos básicos, especialmente: logical, character, integer e double. Listas tem tipo list.Valores especiais: NA, Inf, -Inf, e NaN. NULL é um objeto especial, que indica ausência de valor.\nFigura 3.1: Descrição dos tipos de dados.\n","code":""},{"path":"data-attrs.html","id":"manipulações-básicas","chapter":"3 Tipos de Valores e Atributos","heading":"Manipulações Básicas","text":"Combinamos qualquer vetor com c(). Para listas, temos também list(). c() coage os inputs para um mesmo tipo.Vimos funções .* (e rlang::is_*) e .* para testar e coagir tipos.Vimos diminuição de complexidade de listas com unlist(), purrr::list_flatten(), e purrr::list_c().","code":""},{"path":"data-attrs.html","id":"atributos-1","chapter":"3 Tipos de Valores e Atributos","heading":"Atributos","text":"Atributos são metadados, que alteram interação dos objetos com funções, mas não suas características básicas.Atributos comuns são names, dim, e class.Classes criam um segundo sistema de tipagem, em cima dos tipos básicos. Classes comuns são factor, Date, POSIXct, data.frame, e tibble.Vimos como visualizar e alterar os atributos de um objeto.","code":""},{"path":"data-attrs.html","id":"dicionário-de-funções-1","chapter":"3 Tipos de Valores e Atributos","heading":"Dicionário de Funções","text":"Abaixo segue lista de funções vistas neste capítulo.","code":""},{"path":"data-attrs.html","id":"referências-1","chapter":"3 Tipos de Valores e Atributos","heading":"Referências","text":"referências principais deste capítulo são:“Advanced R” capítulo “3 - Vectors”.“R Language” seções “2.1.1 - Vectors”, “2.1.2 - Lists”, “2.1.6 - NULL”, “2.2 - Attributes”, e “2.3 - Special compound objects”.“R Introduction” capítulos “2 6”.“R Internals” seção “1.3 - Attributes”.“R Help” os documentos de ajuda das funções aqui expostas.","code":""},{"path":"data-attrs.html","id":"exercícios-1","chapter":"3 Tipos de Valores e Atributos","heading":"Exercícios","text":"Em construção.","code":""},{"path":"subset.html","id":"subset","chapter":"4 Subsetting","heading":"4 Subsetting","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"subset.html","id":"introdução-3","chapter":"4 Subsetting","heading":"4.1 Introdução","text":"","code":""},{"path":"subset.html","id":"operador","chapter":"4 Subsetting","heading":"4.2 Operador [","text":"","code":""},{"path":"subset.html","id":"operador-e","chapter":"4 Subsetting","heading":"4.3 Operador [[ e $","text":"","code":""},{"path":"subset.html","id":"atribuição","chapter":"4 Subsetting","heading":"4.4 Atribuição","text":"","code":""},{"path":"subset.html","id":"complemento-2","chapter":"4 Subsetting","heading":"Complemento","text":"","code":""},{"path":"subset.html","id":"recapitulando-2","chapter":"4 Subsetting","heading":"Recapitulando","text":"","code":""},{"path":"subset.html","id":"dicionário-de-funções-2","chapter":"4 Subsetting","heading":"Dicionário de Funções","text":"","code":""},{"path":"subset.html","id":"referências-2","chapter":"4 Subsetting","heading":"Referências","text":"","code":""},{"path":"subset.html","id":"exercícios-2","chapter":"4 Subsetting","heading":"Exercícios","text":"","code":""},{"path":"control-conds.html","id":"control-conds","chapter":"5 Control Flow e Condições","heading":"5 Control Flow e Condições","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"control-conds.html","id":"introdução-4","chapter":"5 Control Flow e Condições","heading":"5.1 Introdução","text":"","code":""},{"path":"control-conds.html","id":"choices","chapter":"5 Control Flow e Condições","heading":"5.2 Choices","text":"","code":""},{"path":"control-conds.html","id":"if-else","chapter":"5 Control Flow e Condições","heading":"5.2.1 If & else","text":"","code":""},{"path":"control-conds.html","id":"and-and-e-or-or","chapter":"5 Control Flow e Condições","heading":"5.2.2 And and e or or","text":"","code":""},{"path":"control-conds.html","id":"switch","chapter":"5 Control Flow e Condições","heading":"5.2.3 Switch","text":"","code":""},{"path":"control-conds.html","id":"loops","chapter":"5 Control Flow e Condições","heading":"5.3 Loops","text":"","code":""},{"path":"control-conds.html","id":"loops-for","chapter":"5 Control Flow e Condições","heading":"5.3.1 Loops For","text":"","code":""},{"path":"control-conds.html","id":"outros-loops","chapter":"5 Control Flow e Condições","heading":"5.3.2 Outros loops","text":"","code":""},{"path":"control-conds.html","id":"condições","chapter":"5 Control Flow e Condições","heading":"5.4 Condições","text":"","code":""},{"path":"control-conds.html","id":"complemento-3","chapter":"5 Control Flow e Condições","heading":"Complemento","text":"","code":""},{"path":"control-conds.html","id":"recapitulando-3","chapter":"5 Control Flow e Condições","heading":"Recapitulando","text":"","code":""},{"path":"control-conds.html","id":"dicionário-de-funções-3","chapter":"5 Control Flow e Condições","heading":"Dicionário de Funções","text":"","code":""},{"path":"control-conds.html","id":"referências-3","chapter":"5 Control Flow e Condições","heading":"Referências","text":"","code":""},{"path":"control-conds.html","id":"exercícios-3","chapter":"5 Control Flow e Condições","heading":"Exercícios","text":"","code":""},{"path":"funs-envs.html","id":"funs-envs","chapter":"6 Funções e Ambientes","heading":"6 Funções e Ambientes","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"funs-envs.html","id":"introdução-5","chapter":"6 Funções e Ambientes","heading":"6.1 Introdução","text":"","code":""},{"path":"funs-envs.html","id":"fundamentos","chapter":"6 Funções e Ambientes","heading":"6.2 Fundamentos","text":"","code":""},{"path":"funs-envs.html","id":"introdução-6","chapter":"6 Funções e Ambientes","heading":"6.2.1 Introdução","text":"","code":""},{"path":"funs-envs.html","id":"formatos-e-combinações","chapter":"6 Funções e Ambientes","heading":"6.2.2 Formatos e combinações","text":"","code":""},{"path":"funs-envs.html","id":"ambientes","chapter":"6 Funções e Ambientes","heading":"6.3 Ambientes","text":"","code":""},{"path":"funs-envs.html","id":"scoping-e-evaluation","chapter":"6 Funções e Ambientes","heading":"6.4 Scoping e Evaluation","text":"","code":""},{"path":"funs-envs.html","id":"scoping","chapter":"6 Funções e Ambientes","heading":"6.4.1 Scoping","text":"","code":""},{"path":"funs-envs.html","id":"lazy-evaluation","chapter":"6 Funções e Ambientes","heading":"6.4.2 Lazy evaluation","text":"","code":""},{"path":"funs-envs.html","id":"conceitos-adicionais","chapter":"6 Funções e Ambientes","heading":"6.5 Conceitos Adicionais","text":"","code":""},{"path":"funs-envs.html","id":"dot-dot-dot","chapter":"6 Funções e Ambientes","heading":"6.5.1 Dot dot dot","text":"","code":""},{"path":"funs-envs.html","id":"resultados","chapter":"6 Funções e Ambientes","heading":"6.5.2 Resultados","text":"","code":""},{"path":"funs-envs.html","id":"exit-handlers","chapter":"6 Funções e Ambientes","heading":"6.5.3 Exit Handlers","text":"","code":""},{"path":"funs-envs.html","id":"pacotes","chapter":"6 Funções e Ambientes","heading":"6.5.4 Pacotes","text":"","code":""},{"path":"funs-envs.html","id":"complemento-4","chapter":"6 Funções e Ambientes","heading":"Complemento","text":"","code":""},{"path":"funs-envs.html","id":"recapitulando-4","chapter":"6 Funções e Ambientes","heading":"Recapitulando","text":"","code":""},{"path":"funs-envs.html","id":"dicionário-de-funções-4","chapter":"6 Funções e Ambientes","heading":"Dicionário de Funções","text":"","code":""},{"path":"funs-envs.html","id":"referências-4","chapter":"6 Funções e Ambientes","heading":"Referências","text":"","code":""},{"path":"funs-envs.html","id":"exercícios-4","chapter":"6 Funções e Ambientes","heading":"Exercícios","text":"","code":""},{"path":"paradigms.html","id":"paradigms","chapter":"7 Paradigmas de Programação","heading":"7 Paradigmas de Programação","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"paradigms.html","id":"introdução-7","chapter":"7 Paradigmas de Programação","heading":"7.1 Introdução","text":"","code":""},{"path":"paradigms.html","id":"programação-funcional","chapter":"7 Paradigmas de Programação","heading":"7.2 Programação Funcional","text":"","code":""},{"path":"paradigms.html","id":"programação-orientada-ao-objeto","chapter":"7 Paradigmas de Programação","heading":"7.3 Programação Orientada ao Objeto","text":"","code":""},{"path":"paradigms.html","id":"sistemas-de-oop","chapter":"7 Paradigmas de Programação","heading":"7.3.1 Sistemas de OOP","text":"","code":""},{"path":"paradigms.html","id":"sistemas-de-oop-1","chapter":"7 Paradigmas de Programação","heading":"7.3.2 Sistemas de OOP","text":"","code":""},{"path":"paradigms.html","id":"funções-genéricas","chapter":"7 Paradigmas de Programação","heading":"7.3.3 Funções genéricas","text":"","code":""},{"path":"paradigms.html","id":"metaprogramação","chapter":"7 Paradigmas de Programação","heading":"7.4 Metaprogramação","text":"","code":""},{"path":"paradigms.html","id":"complemento-5","chapter":"7 Paradigmas de Programação","heading":"Complemento","text":"","code":""},{"path":"paradigms.html","id":"recapitulando-5","chapter":"7 Paradigmas de Programação","heading":"Recapitulando","text":"","code":""},{"path":"paradigms.html","id":"dicionário-de-funções-5","chapter":"7 Paradigmas de Programação","heading":"Dicionário de Funções","text":"","code":""},{"path":"paradigms.html","id":"referências-5","chapter":"7 Paradigmas de Programação","heading":"Referências","text":"","code":""},{"path":"paradigms.html","id":"exercícios-5","chapter":"7 Paradigmas de Programação","heading":"Exercícios","text":"","code":""},{"path":"others1.html","id":"others1","chapter":"8 Outros Tópicos","heading":"8 Outros Tópicos","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"others1.html","id":"introdução-8","chapter":"8 Outros Tópicos","heading":"8.1 Introdução","text":"","code":""},{"path":"others1.html","id":"projetos-github-e-addins","chapter":"8 Outros Tópicos","heading":"8.2 Projetos, Github, e Addins","text":"","code":""},{"path":"others1.html","id":"debbuging","chapter":"8 Outros Tópicos","heading":"8.3 Debbuging","text":"","code":""},{"path":"others1.html","id":"gerenciamento-de-memória-e-performance","chapter":"8 Outros Tópicos","heading":"8.4 Gerenciamento de Memória e Performance","text":"","code":""},{"path":"others1.html","id":"organização-de-código-e-boas-práticas","chapter":"8 Outros Tópicos","heading":"8.5 Organização de Código e Boas Práticas","text":"","code":""},{"path":"others1.html","id":"complemento-6","chapter":"8 Outros Tópicos","heading":"Complemento","text":"","code":""},{"path":"others1.html","id":"recapitulando-6","chapter":"8 Outros Tópicos","heading":"Recapitulando","text":"","code":""},{"path":"others1.html","id":"dicionário-de-funções-6","chapter":"8 Outros Tópicos","heading":"Dicionário de Funções","text":"","code":""},{"path":"others1.html","id":"referências-6","chapter":"8 Outros Tópicos","heading":"Referências","text":"","code":""},{"path":"others1.html","id":"exercícios-6","chapter":"8 Outros Tópicos","heading":"Exercícios","text":"","code":""},{"path":"recap1.html","id":"recap1","chapter":"Recapitulando","heading":"Recapitulando","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Aqui, apresentarei o recapitulando da primeira parte, falando dos principais aprendizados sobre como o R funciona, e também relembrando os conceitos aprendidos.","code":""},{"path":"recap1.html","id":"dicionário-de-funções-7","chapter":"Recapitulando","heading":"Dicionário de Funções","text":"","code":""},{"path":"intro2.html","id":"intro2","chapter":"Introdução","heading":"Introdução","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Bem vindo à segunda parte deste livro. Aqui, foco em ensinar o Tidyverse. O Tidyverse é um conjunto de pacotes para o R, que seguem uma mesma filosofia e sintaxe, e disponibilizam ferramentas poderosas para maior parte das tarefas essencias em projetos R.Começo explicando essa filosfia e sintaxe, pois é intuição trazida por elas que fazem esse universo ser tão simples de aprender. seguir, ensino cada um dos pacotes base:Capítulo 9: descrevo os fundamentos e etapas de um projeto de ciência de dados. Também adianto como importar diferentes tipos de arquivos para o R usando o pacote “readr”.Capítulo 10: apresento ferramentas de manipulação de strings em “stringr”, e factors em “forcats”.Capítulo 11: descrevo os fundamentos e operações da manipulação de dados com os pacotes “dplyr” e “tidyr”.Capítulo 12: descrevo os fundamentos da visualização de dados com o pacote “ggplot2”.Capítulo 13: falo sobre aplicações da programação funcional com o pacote “purrr”.Capítulo 14: falo sobre manipulação de datas e séries de tempo com pacotes adicionais, como “lubridate”, e [pacote definir].Capítulo 15: falo sobre outros pacotes adicionais, como o framework “tidymodels”.Recapitulado: seção para retomar os conteúdos aprendidos.","code":""},{"path":"philosophy.html","id":"philosophy","chapter":"9 Filosofia, readr, tibble","heading":"9 Filosofia, readr, tibble","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"philosophy.html","id":"introdução-9","chapter":"9 Filosofia, readr, tibble","heading":"9.1 Introdução","text":"Neste capítulo, descrevo os fundamentos e etapas de um projeto de ciência de dados. Também adianto como importar diferentes tipos de arquivos para o R usando o pacote “readr”.","code":""},{"path":"philosophy.html","id":"complemento-7","chapter":"9 Filosofia, readr, tibble","heading":"Complemento","text":"","code":""},{"path":"philosophy.html","id":"recapitulando-7","chapter":"9 Filosofia, readr, tibble","heading":"Recapitulando","text":"","code":""},{"path":"philosophy.html","id":"dicionário-de-funções-8","chapter":"9 Filosofia, readr, tibble","heading":"Dicionário de Funções","text":"","code":""},{"path":"philosophy.html","id":"referências-7","chapter":"9 Filosofia, readr, tibble","heading":"Referências","text":"","code":""},{"path":"philosophy.html","id":"exercícios-7","chapter":"9 Filosofia, readr, tibble","heading":"Exercícios","text":"","code":""},{"path":"stringr-forcats.html","id":"stringr-forcats","chapter":"10 stringr e forcats","heading":"10 stringr e forcats","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"stringr-forcats.html","id":"introdução-10","chapter":"10 stringr e forcats","heading":"10.1 Introdução","text":"Neste capítulo, falarei mais sobre strings e factors R. Apresento ferramentas de manipulação nos pacotes “stringr”, “forcats”, e “glue”.","code":""},{"path":"stringr-forcats.html","id":"strings","chapter":"10 stringr e forcats","heading":"10.2 Strings","text":"","code":""},{"path":"stringr-forcats.html","id":"matches","chapter":"10 stringr e forcats","heading":"10.2.1 Matches","text":"","code":""},{"path":"stringr-forcats.html","id":"mutate","chapter":"10 stringr e forcats","heading":"10.2.2 Mutate","text":"","code":""},{"path":"stringr-forcats.html","id":"subset-1","chapter":"10 stringr e forcats","heading":"10.2.3 Subset","text":"","code":""},{"path":"stringr-forcats.html","id":"join-and-split","chapter":"10 stringr e forcats","heading":"10.2.4 Join and Split","text":"","code":""},{"path":"stringr-forcats.html","id":"lengths","chapter":"10 stringr e forcats","heading":"10.2.5 Lengths","text":"","code":""},{"path":"stringr-forcats.html","id":"order","chapter":"10 stringr e forcats","heading":"10.2.6 Order","text":"","code":""},{"path":"stringr-forcats.html","id":"factors-1","chapter":"10 stringr e forcats","heading":"10.3 Factors","text":"","code":""},{"path":"stringr-forcats.html","id":"inspect","chapter":"10 stringr e forcats","heading":"10.3.1 Inspect","text":"","code":""},{"path":"stringr-forcats.html","id":"combine","chapter":"10 stringr e forcats","heading":"10.3.2 Combine","text":"","code":""},{"path":"stringr-forcats.html","id":"reorder","chapter":"10 stringr e forcats","heading":"10.3.3 Reorder","text":"","code":""},{"path":"stringr-forcats.html","id":"revalue","chapter":"10 stringr e forcats","heading":"10.3.4 Revalue","text":"","code":""},{"path":"stringr-forcats.html","id":"relevel","chapter":"10 stringr e forcats","heading":"10.3.5 Relevel","text":"","code":""},{"path":"stringr-forcats.html","id":"complemento-8","chapter":"10 stringr e forcats","heading":"Complemento","text":"","code":""},{"path":"stringr-forcats.html","id":"recapitulando-8","chapter":"10 stringr e forcats","heading":"Recapitulando","text":"","code":""},{"path":"stringr-forcats.html","id":"dicionário-de-funções-9","chapter":"10 stringr e forcats","heading":"Dicionário de Funções","text":"","code":""},{"path":"stringr-forcats.html","id":"referências-8","chapter":"10 stringr e forcats","heading":"Referências","text":"","code":""},{"path":"stringr-forcats.html","id":"exercícios-8","chapter":"10 stringr e forcats","heading":"Exercícios","text":"","code":""},{"path":"tidyr-dplyr.html","id":"tidyr-dplyr","chapter":"11 tidyr e dplyr","heading":"11 tidyr e dplyr","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"tidyr-dplyr.html","id":"introdução-11","chapter":"11 tidyr e dplyr","heading":"11.1 Introdução","text":"Neste capítulo, descreverei os fundamentos e operações da manipulação de dados. Falo como aplicá-las usando os pacotes “dplyr” e “tidyr”.","code":""},{"path":"tidyr-dplyr.html","id":"operações-de-manipulação","chapter":"11 tidyr e dplyr","heading":"11.2 Operações de Manipulação","text":"","code":""},{"path":"tidyr-dplyr.html","id":"operações-em-observações","chapter":"11 tidyr e dplyr","heading":"11.2.1 Operações em Observações","text":"","code":""},{"path":"tidyr-dplyr.html","id":"operações-em-variáveis","chapter":"11 tidyr e dplyr","heading":"11.2.2 Operações em Variáveis","text":"","code":""},{"path":"tidyr-dplyr.html","id":"operações-em-células","chapter":"11 tidyr e dplyr","heading":"11.2.3 Operações em Células","text":"","code":""},{"path":"tidyr-dplyr.html","id":"operações-em-grupos","chapter":"11 tidyr e dplyr","heading":"11.2.4 Operações em Grupos","text":"","code":""},{"path":"tidyr-dplyr.html","id":"operações-de-união","chapter":"11 tidyr e dplyr","heading":"11.3 Operações de União","text":"","code":""},{"path":"tidyr-dplyr.html","id":"operações-de-remodelação","chapter":"11 tidyr e dplyr","heading":"11.4 Operações de Remodelação","text":"","code":""},{"path":"tidyr-dplyr.html","id":"complemento-9","chapter":"11 tidyr e dplyr","heading":"Complemento","text":"","code":""},{"path":"tidyr-dplyr.html","id":"recapitulando-9","chapter":"11 tidyr e dplyr","heading":"Recapitulando","text":"","code":""},{"path":"tidyr-dplyr.html","id":"dicionário-de-funções-10","chapter":"11 tidyr e dplyr","heading":"Dicionário de Funções","text":"","code":""},{"path":"tidyr-dplyr.html","id":"referências-9","chapter":"11 tidyr e dplyr","heading":"Referências","text":"","code":""},{"path":"tidyr-dplyr.html","id":"exercícios-9","chapter":"11 tidyr e dplyr","heading":"Exercícios","text":"","code":""},{"path":"ggplot.html","id":"ggplot","chapter":"12 ggplot2","heading":"12 ggplot2","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"ggplot.html","id":"introdução-12","chapter":"12 ggplot2","heading":"12.1 Introdução","text":"Neste capítulo, descreverei os fundamentos da visualização de dados. Falo como aplicá-la usando o pacote “ggplot2”.","code":""},{"path":"ggplot.html","id":"visualização","chapter":"12 ggplot2","heading":"12.2 Visualização","text":"","code":""},{"path":"ggplot.html","id":"layers","chapter":"12 ggplot2","heading":"12.3 Layers","text":"","code":""},{"path":"ggplot.html","id":"scales","chapter":"12 ggplot2","heading":"12.4 Scales","text":"","code":""},{"path":"ggplot.html","id":"grammar","chapter":"12 ggplot2","heading":"12.5 Grammar","text":"","code":""},{"path":"ggplot.html","id":"others","chapter":"12 ggplot2","heading":"12.6 Others","text":"","code":""},{"path":"ggplot.html","id":"complemento-10","chapter":"12 ggplot2","heading":"Complemento","text":"","code":""},{"path":"ggplot.html","id":"recapitulando-10","chapter":"12 ggplot2","heading":"Recapitulando","text":"","code":""},{"path":"ggplot.html","id":"dicionário-de-funções-11","chapter":"12 ggplot2","heading":"Dicionário de Funções","text":"","code":""},{"path":"ggplot.html","id":"referências-10","chapter":"12 ggplot2","heading":"Referências","text":"","code":""},{"path":"ggplot.html","id":"exercícios-10","chapter":"12 ggplot2","heading":"Exercícios","text":"","code":""},{"path":"purrr.html","id":"purrr","chapter":"13 purrr","heading":"13 purrr","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"purrr.html","id":"introdução-13","chapter":"13 purrr","heading":"13.1 Introdução","text":"Neste capítulo, falarei sobre aplicações da programação funcional com o pacote “purrr”.","code":""},{"path":"purrr.html","id":"map","chapter":"13 purrr","heading":"13.2 Map","text":"","code":""},{"path":"purrr.html","id":"map-1","chapter":"13 purrr","heading":"13.2.1 Map 1","text":"","code":""},{"path":"purrr.html","id":"map-2","chapter":"13 purrr","heading":"13.2.2 Map 2","text":"","code":""},{"path":"purrr.html","id":"map-p","chapter":"13 purrr","heading":"13.2.3 Map p","text":"","code":""},{"path":"purrr.html","id":"others-1","chapter":"13 purrr","heading":"13.3 Others","text":"","code":""},{"path":"purrr.html","id":"modify","chapter":"13 purrr","heading":"13.3.1 Modify","text":"","code":""},{"path":"purrr.html","id":"reduce","chapter":"13 purrr","heading":"13.3.2 Reduce","text":"","code":""},{"path":"purrr.html","id":"predicates","chapter":"13 purrr","heading":"13.3.3 Predicates","text":"","code":""},{"path":"purrr.html","id":"pluck","chapter":"13 purrr","heading":"13.3.4 Pluck","text":"","code":""},{"path":"purrr.html","id":"reshape","chapter":"13 purrr","heading":"13.3.5 Reshape","text":"","code":""},{"path":"purrr.html","id":"concatenate","chapter":"13 purrr","heading":"13.3.6 Concatenate","text":"","code":""},{"path":"purrr.html","id":"complemento-11","chapter":"13 purrr","heading":"Complemento","text":"","code":""},{"path":"purrr.html","id":"recapitulando-11","chapter":"13 purrr","heading":"Recapitulando","text":"","code":""},{"path":"purrr.html","id":"dicionário-de-funções-12","chapter":"13 purrr","heading":"Dicionário de Funções","text":"","code":""},{"path":"purrr.html","id":"referências-11","chapter":"13 purrr","heading":"Referências","text":"","code":""},{"path":"purrr.html","id":"exercícios-11","chapter":"13 purrr","heading":"Exercícios","text":"","code":""},{"path":"time-series.html","id":"time-series","chapter":"14 Datas e Séries de Tempo","heading":"14 Datas e Séries de Tempo","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"time-series.html","id":"introdução-14","chapter":"14 Datas e Séries de Tempo","heading":"14.1 Introdução","text":"Neste capítulo, falarei sobre manipulação de datas e séries de tempo com o pacote “lubridate”, e [pacote definir].","code":""},{"path":"time-series.html","id":"dates","chapter":"14 Datas e Séries de Tempo","heading":"14.2 Dates","text":"","code":""},{"path":"time-series.html","id":"parsing","chapter":"14 Datas e Séries de Tempo","heading":"14.2.1 Parsing","text":"","code":""},{"path":"time-series.html","id":"mutate-1","chapter":"14 Datas e Séries de Tempo","heading":"14.2.2 Mutate","text":"","code":""},{"path":"time-series.html","id":"time-zones","chapter":"14 Datas e Séries de Tempo","heading":"14.2.3 Time Zones","text":"","code":""},{"path":"time-series.html","id":"math","chapter":"14 Datas e Séries de Tempo","heading":"14.2.4 Math","text":"","code":""},{"path":"time-series.html","id":"periods-durations-e-intervals","chapter":"14 Datas e Séries de Tempo","heading":"14.2.5 Periods, Durations, e Intervals","text":"","code":""},{"path":"time-series.html","id":"time-series-1","chapter":"14 Datas e Séries de Tempo","heading":"14.3 Time Series","text":"","code":""},{"path":"time-series.html","id":"complemento-12","chapter":"14 Datas e Séries de Tempo","heading":"Complemento","text":"","code":""},{"path":"time-series.html","id":"recapitulando-12","chapter":"14 Datas e Séries de Tempo","heading":"Recapitulando","text":"","code":""},{"path":"time-series.html","id":"dicionário-de-funções-13","chapter":"14 Datas e Séries de Tempo","heading":"Dicionário de Funções","text":"","code":""},{"path":"time-series.html","id":"referências-12","chapter":"14 Datas e Séries de Tempo","heading":"Referências","text":"","code":""},{"path":"time-series.html","id":"exercícios-12","chapter":"14 Datas e Séries de Tempo","heading":"Exercícios","text":"","code":""},{"path":"others2.html","id":"others2","chapter":"15 Outros","heading":"15 Outros","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"others2.html","id":"introdução-15","chapter":"15 Outros","heading":"15.1 Introdução","text":"Neste capítulo, falo sobre outros pacotes adicionais, como o framework “tidymodels”.","code":""},{"path":"others2.html","id":"complemento-13","chapter":"15 Outros","heading":"Complemento","text":"","code":""},{"path":"others2.html","id":"recapitulando-13","chapter":"15 Outros","heading":"Recapitulando","text":"","code":""},{"path":"others2.html","id":"dicionário-de-funções-14","chapter":"15 Outros","heading":"Dicionário de Funções","text":"","code":""},{"path":"others2.html","id":"referências-13","chapter":"15 Outros","heading":"Referências","text":"","code":""},{"path":"others2.html","id":"exercícios-13","chapter":"15 Outros","heading":"Exercícios","text":"","code":""},{"path":"recap2.html","id":"recap2","chapter":"Recapitulando","heading":"Recapitulando","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Aqui, apresentarei o recapitulando da segunda parte, falando dos fundamentos tidyverse e cada uma de suas ferramentas.","code":""},{"path":"recap2.html","id":"dicionário-de-funções-15","chapter":"Recapitulando","heading":"Dicionário de Funções","text":"","code":""},{"path":"intro3.html","id":"intro3","chapter":"Introdução","heading":"Introdução","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Bem vindo à segunda parte deste livro. Aqui, foco em ensinar sobre o que é ciência de dados, e o formato de tidy data. Ensino também o processo de obter esse formato: importar, arrumar, manipular, e unir bases de dados. Por fim, vamos descobrir como habilidades de visualização de dados para explorá-los, obtendo intuições para etapa da modelagem.Os capítulos estão organizados por etapas de um projeto de ciência de dados:Capítulo 16: descrevo os fundamentos e etapas de um projeto de ciência de dados e o que é tidy data.Capítulo 17: descrevo como importar e arrumar dados.Capítulo 18: descrevo outras manipulações que dados já arrumados podem exigir.Capítulo 19: descrevo unir (merge) várias bases de dados em uma só.Recapitulado: seção para retomar os conteúdos aprendidos.","code":""},{"path":"ds.html","id":"ds","chapter":"16 Ciência de Dados","heading":"16 Ciência de Dados","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"ds.html","id":"introdução-16","chapter":"16 Ciência de Dados","heading":"16.1 Introdução","text":"Neste capítulo, descreverei os fundamentos e etapas de um projeto de ciência de dados, e como é o formato de tidy data.","code":""},{"path":"ds.html","id":"ciência-de-dados","chapter":"16 Ciência de Dados","heading":"16.2 Ciência de Dados","text":"","code":""},{"path":"ds.html","id":"introdução-17","chapter":"16 Ciência de Dados","heading":"16.2.1 Introdução","text":"","code":""},{"path":"ds.html","id":"preparar","chapter":"16 Ciência de Dados","heading":"16.2.2 Preparar","text":"","code":""},{"path":"ds.html","id":"entender-e-explorar","chapter":"16 Ciência de Dados","heading":"16.2.3 Entender e Explorar","text":"","code":""},{"path":"ds.html","id":"comunicar-e-executar","chapter":"16 Ciência de Dados","heading":"16.2.4 Comunicar e Executar","text":"","code":""},{"path":"ds.html","id":"complemento-14","chapter":"16 Ciência de Dados","heading":"Complemento","text":"","code":""},{"path":"ds.html","id":"recapitulando-14","chapter":"16 Ciência de Dados","heading":"Recapitulando","text":"","code":""},{"path":"ds.html","id":"dicionário-de-funções-16","chapter":"16 Ciência de Dados","heading":"Dicionário de Funções","text":"","code":""},{"path":"ds.html","id":"referências-14","chapter":"16 Ciência de Dados","heading":"Referências","text":"","code":""},{"path":"ds.html","id":"exercícios-14","chapter":"16 Ciência de Dados","heading":"Exercícios","text":"","code":""},{"path":"import-tidy.html","id":"import-tidy","chapter":"17 Importar e Arrumar","heading":"17 Importar e Arrumar","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"import-tidy.html","id":"introdução-18","chapter":"17 Importar e Arrumar","heading":"17.1 Introdução","text":"Neste capítulo, descreverei como importar diferentes tipos de arquivos para o R usando o pacote “readr”. Também descreverei como obter o formato “arrumado” de dados, utilizando os pacotes tidyr e dplyr.","code":""},{"path":"import-tidy.html","id":"complemento-15","chapter":"17 Importar e Arrumar","heading":"Complemento","text":"","code":""},{"path":"import-tidy.html","id":"recapitulando-15","chapter":"17 Importar e Arrumar","heading":"Recapitulando","text":"","code":""},{"path":"import-tidy.html","id":"dicionário-de-funções-17","chapter":"17 Importar e Arrumar","heading":"Dicionário de Funções","text":"","code":""},{"path":"import-tidy.html","id":"referências-15","chapter":"17 Importar e Arrumar","heading":"Referências","text":"","code":""},{"path":"import-tidy.html","id":"exercícios-15","chapter":"17 Importar e Arrumar","heading":"Exercícios","text":"","code":""},{"path":"manipulate.html","id":"manipulate","chapter":"18 Manipular","heading":"18 Manipular","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"manipulate.html","id":"introdução-19","chapter":"18 Manipular","heading":"18.1 Introdução","text":"Neste capítulo, descreverei alterações que podemos querer fazer em um dataset já arrumado.","code":""},{"path":"manipulate.html","id":"complemento-16","chapter":"18 Manipular","heading":"Complemento","text":"","code":""},{"path":"manipulate.html","id":"recapitulando-16","chapter":"18 Manipular","heading":"Recapitulando","text":"","code":""},{"path":"manipulate.html","id":"dicionário-de-funções-18","chapter":"18 Manipular","heading":"Dicionário de Funções","text":"","code":""},{"path":"manipulate.html","id":"referências-16","chapter":"18 Manipular","heading":"Referências","text":"","code":""},{"path":"manipulate.html","id":"exercícios-16","chapter":"18 Manipular","heading":"Exercícios","text":"","code":""},{"path":"unite.html","id":"unite","chapter":"19 Unir","heading":"19 Unir","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"unite.html","id":"introdução-20","chapter":"19 Unir","heading":"19.1 Introdução","text":"Neste capítulo, descreverei como unir bases de dados em uma.","code":""},{"path":"unite.html","id":"complemento-17","chapter":"19 Unir","heading":"Complemento","text":"","code":""},{"path":"unite.html","id":"recapitulando-17","chapter":"19 Unir","heading":"Recapitulando","text":"","code":""},{"path":"unite.html","id":"dicionário-de-funções-19","chapter":"19 Unir","heading":"Dicionário de Funções","text":"","code":""},{"path":"unite.html","id":"referências-17","chapter":"19 Unir","heading":"Referências","text":"","code":""},{"path":"unite.html","id":"exercícios-17","chapter":"19 Unir","heading":"Exercícios","text":"","code":""},{"path":"recap3.html","id":"recap3","chapter":"Recapitulando","heading":"Recapitulando","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Aqui, apresentarei o recapitulando da terceira parte, falando dos fundamentos da ciência de dados e suas etapas iniciais.","code":""},{"path":"recap3.html","id":"dicionário-de-funções-20","chapter":"Recapitulando","heading":"Dicionário de Funções","text":"","code":""},{"path":"visualize.html","id":"visualize","chapter":"20 Visualizar","heading":"20 Visualizar","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"visualize.html","id":"introdução-21","chapter":"20 Visualizar","heading":"20.1 Introdução","text":"Neste capítulo, apresentarei como aplicar habilidades de manipulação e visualização de dados, para explorar e obter informações contidas em datasets.","code":""},{"path":"visualize.html","id":"visualizações-úteis","chapter":"20 Visualizar","heading":"20.2 Visualizações Úteis","text":"","code":""},{"path":"visualize.html","id":"métricas-úteis","chapter":"20 Visualizar","heading":"20.3 Métricas Úteis","text":"","code":""},{"path":"visualize.html","id":"gráficos-úteis","chapter":"20 Visualizar","heading":"20.4 Gráficos Úteis","text":"","code":""},{"path":"visualize.html","id":"complemento-18","chapter":"20 Visualizar","heading":"Complemento","text":"","code":""},{"path":"visualize.html","id":"recapitulando-18","chapter":"20 Visualizar","heading":"Recapitulando","text":"","code":""},{"path":"visualize.html","id":"dicionário-de-funções-21","chapter":"20 Visualizar","heading":"Dicionário de Funções","text":"","code":""},{"path":"visualize.html","id":"referências-18","chapter":"20 Visualizar","heading":"Referências","text":"","code":""},{"path":"visualize.html","id":"exercícios-18","chapter":"20 Visualizar","heading":"Exercícios","text":"","code":""},{"path":"intro4.html","id":"intro4","chapter":"Introdução","heading":"Introdução","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Bem vindo à quarta e última parte deste livro. Aqui, irei ensinar mais uma etapa de projetos de ciência de dados, modelagem.Agora sim, o estilo livro é bem mais mostrar capacidades R através de exemplos, que o estudo teórico das outras seções.Os temas são:Capítulo 20: descrevo os fundamentos da visualização de dados, e como explorar dados para adquirir intuições.Capítulo 21: apresento como resolver problemas comuns em probabilidade e estatística, o assunto central R.Capítulo 22: apresento como realizar análises de regressões, com base nos vários modelos comuns inclusos R.Capítulo 23: complementar à regressões, apresento rapidamente alguns frameworks para modelos mais complexos de machine learning.Capítulo 24: para servir de referência, listo outras aplicações de possível interesse, especialmente aquelas com relação aos conceitos deste livro.Recapitulado: seção para retomar os conteúdos aprendidos.","code":""},{"path":"stats-prob.html","id":"stats-prob","chapter":"21 Probabilidade e Estatística","heading":"21 Probabilidade e Estatística","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"stats-prob.html","id":"introdução-22","chapter":"21 Probabilidade e Estatística","heading":"21.1 Introdução","text":"Neste capítulo, apresentarei como resolver problemas comuns em probabilidade e estatística, o assunto central R.","code":""},{"path":"stats-prob.html","id":"probability","chapter":"21 Probabilidade e Estatística","heading":"21.2 Probability","text":"","code":""},{"path":"stats-prob.html","id":"random-numbers","chapter":"21 Probabilidade e Estatística","heading":"21.2.1 Random Numbers","text":"","code":""},{"path":"stats-prob.html","id":"useful-measures","chapter":"21 Probabilidade e Estatística","heading":"21.2.2 Useful Measures","text":"","code":""},{"path":"stats-prob.html","id":"statistics","chapter":"21 Probabilidade e Estatística","heading":"21.3 Statistics","text":"","code":""},{"path":"stats-prob.html","id":"useful-measures-1","chapter":"21 Probabilidade e Estatística","heading":"21.3.1 Useful Measures","text":"","code":""},{"path":"stats-prob.html","id":"hypothesis-testing","chapter":"21 Probabilidade e Estatística","heading":"21.3.2 Hypothesis Testing","text":"","code":""},{"path":"stats-prob.html","id":"complemento-19","chapter":"21 Probabilidade e Estatística","heading":"Complemento","text":"","code":""},{"path":"stats-prob.html","id":"recapitulando-19","chapter":"21 Probabilidade e Estatística","heading":"Recapitulando","text":"","code":""},{"path":"stats-prob.html","id":"dicionário-de-funções-22","chapter":"21 Probabilidade e Estatística","heading":"Dicionário de Funções","text":"","code":""},{"path":"stats-prob.html","id":"referências-19","chapter":"21 Probabilidade e Estatística","heading":"Referências","text":"","code":""},{"path":"stats-prob.html","id":"exercícios-19","chapter":"21 Probabilidade e Estatística","heading":"Exercícios","text":"","code":""},{"path":"regression.html","id":"regression","chapter":"22 Regressão","heading":"22 Regressão","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"regression.html","id":"introdução-23","chapter":"22 Regressão","heading":"22.1 Introdução","text":"Neste capítulo, apresentarei como realizar análises de regressões, com base nos vários modelos comuns inclusos R.","code":""},{"path":"regression.html","id":"fundamentals","chapter":"22 Regressão","heading":"22.2 Fundamentals","text":"","code":""},{"path":"regression.html","id":"data","chapter":"22 Regressão","heading":"22.2.1 Data","text":"","code":""},{"path":"regression.html","id":"formulas","chapter":"22 Regressão","heading":"22.2.2 Formulas","text":"","code":""},{"path":"regression.html","id":"fitting","chapter":"22 Regressão","heading":"22.2.3 Fitting","text":"","code":""},{"path":"regression.html","id":"visualizing","chapter":"22 Regressão","heading":"22.2.4 Visualizing","text":"","code":""},{"path":"regression.html","id":"testing","chapter":"22 Regressão","heading":"22.2.5 Testing","text":"","code":""},{"path":"regression.html","id":"correcting","chapter":"22 Regressão","heading":"22.2.6 Correcting","text":"","code":""},{"path":"regression.html","id":"linear-models","chapter":"22 Regressão","heading":"22.3 Linear Models","text":"","code":""},{"path":"regression.html","id":"non-linear-models","chapter":"22 Regressão","heading":"22.4 Non-Linear Models","text":"","code":""},{"path":"regression.html","id":"time-series-models","chapter":"22 Regressão","heading":"22.5 Time-Series Models","text":"","code":""},{"path":"regression.html","id":"complemento-20","chapter":"22 Regressão","heading":"Complemento","text":"","code":""},{"path":"regression.html","id":"recapitulando-20","chapter":"22 Regressão","heading":"Recapitulando","text":"","code":""},{"path":"regression.html","id":"dicionário-de-funções-23","chapter":"22 Regressão","heading":"Dicionário de Funções","text":"","code":""},{"path":"regression.html","id":"referências-20","chapter":"22 Regressão","heading":"Referências","text":"","code":""},{"path":"regression.html","id":"exercícios-20","chapter":"22 Regressão","heading":"Exercícios","text":"","code":""},{"path":"ml.html","id":"ml","chapter":"23 Aprendizado de Máquina","heading":"23 Aprendizado de Máquina","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"ml.html","id":"introdução-24","chapter":"23 Aprendizado de Máquina","heading":"23.1 Introdução","text":"Neste capítulo, apresentarei rapidamente alguns frameworks para modelos mais complexos de machine learning.","code":""},{"path":"ml.html","id":"fundamentals-1","chapter":"23 Aprendizado de Máquina","heading":"23.2 Fundamentals","text":"","code":""},{"path":"ml.html","id":"ml-in-built-in-r","chapter":"23 Aprendizado de Máquina","heading":"23.3 ML in Built-In R","text":"","code":""},{"path":"ml.html","id":"ml-in-external-packages","chapter":"23 Aprendizado de Máquina","heading":"23.4 ML in External Packages","text":"","code":""},{"path":"ml.html","id":"complemento-21","chapter":"23 Aprendizado de Máquina","heading":"Complemento","text":"","code":""},{"path":"ml.html","id":"recapitulando-21","chapter":"23 Aprendizado de Máquina","heading":"Recapitulando","text":"","code":""},{"path":"ml.html","id":"dicionário-de-funções-24","chapter":"23 Aprendizado de Máquina","heading":"Dicionário de Funções","text":"","code":""},{"path":"ml.html","id":"referências-21","chapter":"23 Aprendizado de Máquina","heading":"Referências","text":"","code":""},{"path":"ml.html","id":"exercícios-21","chapter":"23 Aprendizado de Máquina","heading":"Exercícios","text":"","code":""},{"path":"others4.html","id":"others4","chapter":"24 Outras Aplicações","heading":"24 Outras Aplicações","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.","code":""},{"path":"others4.html","id":"introdução-25","chapter":"24 Outras Aplicações","heading":"24.1 Introdução","text":"Neste capítulo, listarei outras aplicações de possível interesse, especialmente aquelas com relação aos conceitos deste livro.","code":""},{"path":"others4.html","id":"comunicação-com-rmarkdown-stargazer-broom-e-shiny.","chapter":"24 Outras Aplicações","heading":"24.2 Comunicação com RMarkdown, stargazer, broom, e Shiny.","text":"","code":""},{"path":"others4.html","id":"pacotes-1","chapter":"24 Outras Aplicações","heading":"24.3 Pacotes","text":"","code":""},{"path":"others4.html","id":"bioestatística-estatística-geoespacial-e-econometria.","chapter":"24 Outras Aplicações","heading":"24.4 Bioestatística, Estatística geoespacial, e Econometria.","text":"","code":""},{"path":"others4.html","id":"complemento-22","chapter":"24 Outras Aplicações","heading":"Complemento","text":"","code":""},{"path":"others4.html","id":"recapitulando-22","chapter":"24 Outras Aplicações","heading":"Recapitulando","text":"","code":""},{"path":"others4.html","id":"dicionário-de-funções-25","chapter":"24 Outras Aplicações","heading":"Dicionário de Funções","text":"","code":""},{"path":"others4.html","id":"referências-22","chapter":"24 Outras Aplicações","heading":"Referências","text":"","code":""},{"path":"others4.html","id":"exercícios-22","chapter":"24 Outras Aplicações","heading":"Exercícios","text":"","code":""},{"path":"recap4.html","id":"recap4","chapter":"Recapitulando","heading":"Recapitulando","text":"este capítulo está em construção. O que segue abaixo é apenas um rascunho.Aqui, apresentarei o recapitulando da quarta parte, falando dos fundamentos da modelagem e aplicações importantes.","code":""},{"path":"recap4.html","id":"dicionário-de-funções-26","chapter":"Recapitulando","heading":"Dicionário de Funções","text":"","code":""},{"path":"dict.html","id":"dict","chapter":"Dicionário de funções","heading":"Dicionário de funções","text":"Abaixo segue lista de funções vistas neste livro.","code":""},{"path":"refs.html","id":"refs","chapter":"Referências","heading":"Referências","text":"Abaixo seguem principais referências deste livro. Elas estão separadas entre que foram utilizadas para compor o conteúdo, e que foram citadas como sugestões de leitura.","code":""},{"path":"refs.html","id":"referências-23","chapter":"Referências","heading":"25.1 Referências","text":"","code":""},{"path":"refs.html","id":"sugestões-de-leitura","chapter":"Referências","heading":"25.2 Sugestões de Leitura","text":"","code":""}]
